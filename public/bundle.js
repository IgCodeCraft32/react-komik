/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "14bdccf54919af8a9c21"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 	
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(159);
	
	var _Komik = __webpack_require__(160);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var Comic = function Comic(props) {
	    return _react2.default.createElement(
	        _Komik.Strip,
	        { title: 'React Komik!', column: '2', fontFamily: 'Patrick Hand', fontSize: '13', upperCase: true },
	        _react2.default.createElement(
	            _Komik.Panel,
	            null,
	            _react2.default.createElement(
	                _Komik.Character,
	                {
	                    image: 'char1.png',
	                    left: '70',
	                    scale: '0.65' },
	                _react2.default.createElement(_Komik.Balloon, {
	                    left: '-80',
	                    height: '120',
	                    image: 'chat_left.svg',
	                    text: 'Have You heard about ReactJS? You can write HTML in JS...' })
	            )
	        ),
	        _react2.default.createElement(
	            _Komik.Panel,
	            null,
	            _react2.default.createElement(
	                _Komik.Character,
	                {
	                    image: 'char2.png',
	                    left: '30',
	                    scale: '0.65' },
	                _react2.default.createElement(_Komik.Balloon, {
	                    height: '146',
	                    left: '60',
	                    bottom: '-80',
	                    image: 'chat_right.svg',
	                    text: 'Yeah it\'s pretty cool. You can use JSX syntax to write web, mobile app, even presentation'
	                })
	            )
	        ),
	        _react2.default.createElement(
	            _Komik.Panel,
	            null,
	            _react2.default.createElement(
	                _Komik.Character,
	                {
	                    image: 'char1_hype.png',
	                    scale: '0.9',
	                    left: '30' },
	                _react2.default.createElement(_Komik.Balloon, {
	                    height: '130',
	                    left: '-40',
	                    image: 'chat_left.svg',
	                    text: 'Hey look! It\'s React Komik! We can create this comic strip with ReactJS!'
	                })
	            )
	        ),
	        _react2.default.createElement(
	            _Komik.Panel,
	            null,
	            _react2.default.createElement(
	                _Komik.Character,
	                {
	                    image: 'char2_magic.png',
	                    scale: '0.65' },
	                _react2.default.createElement(_Komik.Balloon, {
	                    height: '80',
	                    left: '80',
	                    image: 'chat_right.svg',
	                    text: 'It\'s MAGIC'
	                })
	            )
	        ),
	        _react2.default.createElement(_Komik.Character, { image: 'footer.png', align: 'center', bottom: '20', scale: '0.8' })
	    );
	};
	
	(0, _reactDom.render)(_react2.default.createElement(Comic, null), document.getElementById('root'));

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(3);


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var ReactDOM = __webpack_require__(4);
	var ReactDOMServer = __webpack_require__(149);
	var ReactIsomorphic = __webpack_require__(153);
	
	var assign = __webpack_require__(40);
	var deprecated = __webpack_require__(158);
	
	// `version` will be added here by ReactIsomorphic.
	var React = {};
	
	assign(React, ReactIsomorphic);
	
	assign(React, {
	  // ReactDOM
	  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
	  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
	  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),
	
	  // ReactDOMServer
	  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
	  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
	});
	
	React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
	React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;
	
	module.exports = React;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(6);
	var ReactDOMTextComponent = __webpack_require__(7);
	var ReactDefaultInjection = __webpack_require__(72);
	var ReactInstanceHandles = __webpack_require__(46);
	var ReactMount = __webpack_require__(29);
	var ReactPerf = __webpack_require__(19);
	var ReactReconciler = __webpack_require__(51);
	var ReactUpdates = __webpack_require__(55);
	var ReactVersion = __webpack_require__(147);
	
	var findDOMNode = __webpack_require__(92);
	var renderSubtreeIntoContainer = __webpack_require__(148);
	var warning = __webpack_require__(26);
	
	ReactDefaultInjection.inject();
	
	var render = ReactPerf.measure('React', 'render', ReactMount.render);
	
	var React = {
	  findDOMNode: findDOMNode,
	  render: render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(10);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,
	
	    // shams
	    Object.create, Object.freeze];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
	        break;
	      }
	    }
	  }
	}
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(8);
	var DOMPropertyOperations = __webpack_require__(23);
	var ReactComponentBrowserEnvironment = __webpack_require__(27);
	var ReactMount = __webpack_require__(29);
	
	var assign = __webpack_require__(40);
	var escapeTextContentForBrowser = __webpack_require__(22);
	var setTextContent = __webpack_require__(21);
	var validateDOMNesting = __webpack_require__(71);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (props) {
	  // This constructor and its argument is currently used by mocks.
	};
	
	assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function (text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;
	
	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    this._rootNodeID = rootID;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement('span');
	      DOMPropertyOperations.setAttributeForID(el, rootID);
	      // Populate node cache
	      ReactMount.getID(el);
	      setTextContent(el, this._stringText);
	      return el;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this in a `span` for the reasons stated above, but
	        // since this is a situation where React won't take over (static pages),
	        // we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var node = ReactMount.getNode(this._rootNodeID);
	        DOMChildrenOperations.updateTextContent(node, nextStringText);
	      }
	    }
	  },
	
	  unmountComponent: function () {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var Danger = __webpack_require__(9);
	var ReactMultiChildUpdateTypes = __webpack_require__(17);
	var ReactPerf = __webpack_require__(19);
	
	var setInnerHTML = __webpack_require__(20);
	var setTextContent = __webpack_require__(21);
	var invariant = __webpack_require__(14);
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.
	
	  // fix render order error in safari
	  // IE8 will throw error when index out of list size.
	  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
	
	  parentNode.insertBefore(childNode, beforeChild);
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
	
	  updateTextContent: setTextContent,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function (updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;
	
	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;
	
	        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
	
	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;
	
	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }
	
	    var renderedMarkup;
	    // markupList is either a list of markup or just a list of elements
	    if (markupList.length && typeof markupList[0] === 'string') {
	      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	    } else {
	      renderedMarkup = markupList;
	    }
	
	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
	  updateTextContent: 'updateTextContent'
	});
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(10);
	
	var createNodesFromMarkup = __webpack_require__(11);
	var emptyFunction = __webpack_require__(16);
	var getMarkupWrap = __webpack_require__(15);
	var invariant = __webpack_require__(14);
	
	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';
	
	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}
	
	var Danger = {
	
	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function (markupList) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];
	
	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];
	
	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
	          // This index will be parsed back out below.
	          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
	        }
	      }
	
	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
	      );
	
	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
	
	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);
	
	          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
	
	          resultList[resultIndex] = renderNode;
	
	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	        } else if (process.env.NODE_ENV !== 'production') {
	          console.error('Danger: Discarding unexpected node:', renderNode);
	        }
	      }
	    }
	
	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
	
	    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
	
	    return resultList;
	  },
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
	    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;
	
	    var newChild;
	    if (typeof markup === 'string') {
	      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    } else {
	      newChild = markup;
	    }
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(10);
	
	var createArrayFromMixed = __webpack_require__(12);
	var getMarkupWrap = __webpack_require__(15);
	var invariant = __webpack_require__(14);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */
	
	'use strict';
	
	var toArray = __webpack_require__(13);
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return(
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(14);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	module.exports = toArray;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(10);
	
	var invariant = __webpack_require__(14);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 16 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	"use strict";
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(18);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(14);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function (obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,
	
	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,
	
	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function (object, objectName, methodNames) {
	    if (process.env.NODE_ENV !== 'production') {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },
	
	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function (objName, fnName, func) {
	    if (process.env.NODE_ENV !== 'production') {
	      var measuredFunc = null;
	      var wrapper = function () {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },
	
	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function (measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};
	
	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}
	
	module.exports = ReactPerf;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(10);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function (node, html) {
	  node.innerHTML = html;
	};
	
	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function (node, html) {
	    MSApp.execUnsafeLocalFunction(function () {
	      node.innerHTML = html;
	    });
	  };
	}
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}
	
	module.exports = setInnerHTML;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(10);
	var escapeTextContentForBrowser = __webpack_require__(22);
	var setInnerHTML = __webpack_require__(20);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};
	
	var ESCAPE_REGEX = /[&><"']/g;
	
	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(24);
	var ReactPerf = __webpack_require__(19);
	
	var quoteAttributeValueForBrowser = __webpack_require__(25);
	var warning = __webpack_require__(26);
	
	// Simplified subset
	var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};
	
	  var warnUnknownProperty = function (name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }
	
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
	  };
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (propertyInfo.mustUseAttribute) {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      } else {
	        var propName = propertyInfo.propertyName;
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  },
	
	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseAttribute) {
	        node.removeAttribute(propertyInfo.attributeName);
	      } else {
	        var propName = propertyInfo.propertyName;
	        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
	  setValueForProperty: 'setValueForProperty',
	  setValueForAttribute: 'setValueForAttribute',
	  deleteValueForProperty: 'deleteValueForProperty'
	});
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(14);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	
	      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	var defaultValueCache = {};
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseAttribute:
	   *   Whether the property must be accessed and mutated using `*Attribute()`.
	   *   (This includes anything that fails `<propName> in <element>`.)
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasSideEffects:
	   *   Whether or not setting a value causes side effects such as triggering
	   *   resources to be loaded or text selection changes. If true, we read from
	   *   the DOM before updating to ensure that the value is only set if it has
	   *   changed.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function (nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElement(nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(22);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(16);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(28);
	var ReactMount = __webpack_require__(29);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
	
	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function (rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(8);
	var DOMPropertyOperations = __webpack_require__(23);
	var ReactMount = __webpack_require__(29);
	var ReactPerf = __webpack_require__(19);
	
	var invariant = __webpack_require__(14);
	
	/**
	 * Errors for properties that should not be updated with `updatePropertyByID()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function (id, name, value) {
	    var node = ReactMount.getNode(id);
	    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
	
	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },
	
	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};
	
	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});
	
	module.exports = ReactDOMIDOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(24);
	var ReactBrowserEventEmitter = __webpack_require__(30);
	var ReactCurrentOwner = __webpack_require__(6);
	var ReactDOMFeatureFlags = __webpack_require__(42);
	var ReactElement = __webpack_require__(43);
	var ReactEmptyComponentRegistry = __webpack_require__(45);
	var ReactInstanceHandles = __webpack_require__(46);
	var ReactInstanceMap = __webpack_require__(48);
	var ReactMarkupChecksum = __webpack_require__(49);
	var ReactPerf = __webpack_require__(19);
	var ReactReconciler = __webpack_require__(51);
	var ReactUpdateQueue = __webpack_require__(54);
	var ReactUpdates = __webpack_require__(55);
	
	var assign = __webpack_require__(40);
	var emptyObject = __webpack_require__(59);
	var containsNode = __webpack_require__(60);
	var instantiateReactComponent = __webpack_require__(63);
	var invariant = __webpack_require__(14);
	var setInnerHTML = __webpack_require__(20);
	var shouldUpdateReactComponent = __webpack_require__(68);
	var validateDOMNesting = __webpack_require__(71);
	var warning = __webpack_require__(26);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);
	
	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};
	
	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}
	
	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}
	
	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
	
	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }
	
	  return id;
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}
	
	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
	
	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}
	
	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}
	
	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
	
	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	  if (ReactDOMFeatureFlags.useCreateElement) {
	    context = assign({}, context);
	    if (container.nodeType === DOC_NODE_TYPE) {
	      context[ownerDocumentContextKey] = container;
	    } else {
	      context[ownerDocumentContextKey] = container.ownerDocument;
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (context === emptyObject) {
	      context = {};
	    }
	    var tag = container.nodeName.toLowerCase();
	    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
	  }
	  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
	  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* forceHTML */shouldReuseMarkup);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container) {
	  ReactReconciler.unmountComponent(instance);
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(node) {
	  var reactRootID = getReactRootID(node);
	  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
	}
	
	/**
	 * Returns the first (deepest) ancestor of a node which is rendered by this copy
	 * of React.
	 */
	function findFirstReactDOMImpl(node) {
	  // This node might be from another React instance, so we make sure not to
	  // examine the node cache here
	  for (; node && node.parentNode !== node; node = node.parentNode) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      continue;
	    }
	    var nodeID = internalGetID(node);
	    if (!nodeID) {
	      continue;
	    }
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	
	    // If containersByReactRootID contains the container we find by crawling up
	    // the tree, we know that this instance of React rendered the node.
	    // nb. isValid's strategy (with containsNode) does not work because render
	    // trees may be nested and we don't want a false positive in that case.
	    var current = node;
	    var lastID;
	    do {
	      lastID = internalGetID(current);
	      current = current.parentNode;
	      if (current == null) {
	        // The passed-in node has been detached from the container it was
	        // originally rendered into.
	        return null;
	      }
	    } while (lastID !== reactRootID);
	
	    if (current === containersByReactRootID[reactRootID]) {
	      return node;
	    }
	  }
	  return null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var TopLevelWrapper = function () {};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
	    }
	
	    return prevComponent;
	  },
	
	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function (nextComponent, container) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	
	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },
	
	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(componentInstance, container);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
	    }
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
	
	    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var prevComponent = instancesByReactRootID[getReactRootID(container)];
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function (container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var containerID = internalGetID(container);
	      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
	      }
	
	      return false;
	    }
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if (process.env.NODE_ENV !== 'production') {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },
	
	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function (id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];
	
	    if (process.env.NODE_ENV !== 'production') {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        process.env.NODE_ENV !== 'production' ? warning(
	        // Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
	        var containerChild = container.firstChild;
	        if (containerChild && reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
	        }
	      }
	    }
	
	    return container;
	  },
	
	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function (id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },
	
	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component rendered by this copy of React.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function (node) {
	    return findFirstReactDOMImpl(node);
	  },
	
	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function (ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;
	
	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw on the next line; give an early warning
	      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
	    }
	
	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;
	
	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;
	
	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.
	
	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }
	
	        child = child.nextSibling;
	      }
	
	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;
	
	        return targetChild;
	      }
	    }
	
	    firstChildren.length = 0;
	
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
	  },
	
	  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      container.appendChild(markup);
	    } else {
	      setInnerHTML(container, markup);
	    }
	  },
	
	  ownerDocumentContextKey: ownerDocumentContextKey,
	
	  /**
	   * React ID utilities.
	   */
	
	  getReactRootID: getReactRootID,
	
	  getID: getID,
	
	  setID: setID,
	
	  getNode: getNode,
	
	  getNodeFromInstance: getNodeFromInstance,
	
	  isValid: isValid,
	
	  purgeID: purgeID
	};
	
	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(31);
	var EventPluginHub = __webpack_require__(32);
	var EventPluginRegistry = __webpack_require__(33);
	var ReactEventEmitterMixin = __webpack_require__(38);
	var ReactPerf = __webpack_require__(19);
	var ViewportMetrics = __webpack_require__(39);
	
	var assign = __webpack_require__(40);
	var isEventSupported = __webpack_require__(41);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },
	
	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginHub.registrationNameModules,
	
	  putListener: EventPluginHub.putListener,
	
	  getListener: EventPluginHub.getListener,
	
	  deleteListener: EventPluginHub.deleteListener,
	
	  deleteAllListeners: EventPluginHub.deleteAllListeners
	
	});
	
	ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
	  putListener: 'putListener',
	  deleteListener: 'deleteListener'
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(18);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var EventPluginRegistry = __webpack_require__(33);
	var EventPluginUtils = __webpack_require__(34);
	var ReactErrorUtils = __webpack_require__(35);
	
	var accumulateInto = __webpack_require__(36);
	var forEachAccumulated = __webpack_require__(37);
	var invariant = __webpack_require__(14);
	var warning = __webpack_require__(26);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;
	
	function validateInstanceHandle() {
	  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
	  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,
	
	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function (InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	    },
	
	    getInstanceHandle: function () {
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginRegistry.registrationNameModules,
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function (id, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;
	
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(id, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (id, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(id, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function (id) {
	    for (var registrationName in listenerBank) {
	      if (!listenerBank[registrationName][id]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(id, registrationName);
	      }
	
	      delete listenerBank[registrationName][id];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function () {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(14);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(31);
	var ReactErrorUtils = __webpack_require__(35);
	
	var invariant = __webpack_require__(14);
	var warning = __webpack_require__(26);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function (InjectedMount) {
	    injection.Mount = InjectedMount;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, simulated, listener, domID) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = injection.Mount.getNode(domID);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
	  }
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
	  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getNode: function (id) {
	    return injection.Mount.getNode(id);
	  },
	  getID: function (node) {
	    return injection.Mount.getID(node);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(14);
	
	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);
	
	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }
	
	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }
	
	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 37 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	var forEachAccumulated = function (arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};
	
	module.exports = forEachAccumulated;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(32);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
	
	'use strict';
	
	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }
	
	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }
	
	    var from = Object(nextSource);
	
	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.
	
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }
	
	  return to;
	}
	
	module.exports = assign;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(10);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = (eventName in document);
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(6);
	
	var assign = __webpack_require__(40);
	var canDefineProperty = __webpack_require__(44);
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    Object.freeze(element.props);
	    Object.freeze(element);
	  }
	
	  return element;
	};
	
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
	  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);
	
	  if (process.env.NODE_ENV !== 'production') {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }
	
	  return newElement;
	};
	
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 45 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponentRegistry
	 */
	
	'use strict';
	
	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	var nullComponentIDsRegistry = {};
	
	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}
	
	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}
	
	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}
	
	var ReactEmptyComponentRegistry = {
	  isNullComponentID: isNullComponentID,
	  registerNullComponentID: registerNullComponentID,
	  deregisterNullComponentID: deregisterNullComponentID
	};
	
	module.exports = ReactEmptyComponentRegistry;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactRootIndex = __webpack_require__(47);
	
	var invariant = __webpack_require__(14);
	
	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;
	
	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 10000;
	
	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}
	
	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}
	
	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
	}
	
	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
	}
	
	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}
	
	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
	  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}
	
	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
	  return longestCommonID;
	}
	
	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {*} arg Argument to invoke the callback with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
	  var traverseUp = isAncestorIDOf(stop, start);
	  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start;; /* until break */id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {
	
	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function () {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },
	
	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function (rootID, name) {
	    return rootID + name;
	  },
	
	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function (id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },
	
	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },
	
	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },
	
	  /**
	   * Same as `traverseTwoPhase` but skips the `targetID`.
	   */
	  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, true);
	      traverseParentPath(targetID, '', cb, arg, true, true);
	    }
	  },
	
	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function (targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },
	
	  getFirstCommonAncestorID: getFirstCommonAncestorID,
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,
	
	  isAncestorIDOf: isAncestorIDOf,
	
	  SEPARATOR: SEPARATOR
	
	};
	
	module.exports = ReactInstanceHandles;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 47 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function (_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};
	
	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};
	
	module.exports = ReactRootIndex;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function (key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(50);
	
	var TAG_END = /\/?>/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags and self-closing tags)
	    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ }),
/* 50 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    for (; i < Math.min(i + 4096, m); i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(52);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }
	
	};
	
	module.exports = ReactReconciler;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(53);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return(
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(14);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function (object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(6);
	var ReactElement = __webpack_require__(43);
	var ReactInstanceMap = __webpack_require__(48);
	var ReactUpdates = __webpack_require__(55);
	
	var assign = __webpack_require__(40);
	var invariant = __webpack_require__(14);
	var warning = __webpack_require__(26);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function (internalInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
	  },
	
	  enqueueSetPropsInternal: function (internalInstance, partialProps) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    var props = assign({}, element.props, partialProps);
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
	  },
	
	  enqueueReplacePropsInternal: function (internalInstance, props) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  enqueueElementInternal: function (internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(56);
	var PooledClass = __webpack_require__(57);
	var ReactPerf = __webpack_require__(19);
	var ReactReconciler = __webpack_require__(51);
	var Transaction = __webpack_require__(58);
	
	var assign = __webpack_require__(40);
	var invariant = __webpack_require__(14);
	
	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
	}
	
	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
	}
	
	assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(57);
	
	var assign = __webpack_require__(40);
	var invariant = __webpack_require__(14);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function (callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function () {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function () {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function () {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(14);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(14);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isTextNode = __webpack_require__(61);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(_x, _x2) {
	  var _again = true;
	
	  _function: while (_again) {
	    var outerNode = _x,
	        innerNode = _x2;
	    _again = false;
	
	    if (!outerNode || !innerNode) {
	      return false;
	    } else if (outerNode === innerNode) {
	      return true;
	    } else if (isTextNode(outerNode)) {
	      return false;
	    } else if (isTextNode(innerNode)) {
	      _x = outerNode;
	      _x2 = innerNode.parentNode;
	      _again = true;
	      continue _function;
	    } else if (outerNode.contains) {
	      return outerNode.contains(innerNode);
	    } else if (outerNode.compareDocumentPosition) {
	      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	    } else {
	      return false;
	    }
	  }
	}
	
	module.exports = containsNode;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isNode = __webpack_require__(62);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ }),
/* 62 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	'use strict';
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCompositeComponent = __webpack_require__(64);
	var ReactEmptyComponent = __webpack_require__(69);
	var ReactNativeComponent = __webpack_require__(70);
	
	var assign = __webpack_require__(40);
	var invariant = __webpack_require__(14);
	var warning = __webpack_require__(26);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function () {};
	assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = new ReactEmptyComponent(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactNativeComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
	  }
	
	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(65);
	var ReactCurrentOwner = __webpack_require__(6);
	var ReactElement = __webpack_require__(43);
	var ReactInstanceMap = __webpack_require__(48);
	var ReactPerf = __webpack_require__(19);
	var ReactPropTypeLocations = __webpack_require__(66);
	var ReactPropTypeLocationNames = __webpack_require__(67);
	var ReactReconciler = __webpack_require__(51);
	var ReactUpdateQueue = __webpack_require__(54);
	
	var assign = __webpack_require__(40);
	var emptyObject = __webpack_require__(59);
	var invariant = __webpack_require__(14);
	var shouldUpdateReactComponent = __webpack_require__(68);
	var warning = __webpack_require__(26);
	
	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  return Component(this.props, this.context, this.updater);
	};
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;
	
	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedComponent = null;
	
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;
	
	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    // Initialize the public class
	    var inst;
	    var renderedElement;
	
	    // This is a way to detect if Component is a stateless arrow function
	    // component, which is not newable. It might not be 100% reliable but is
	    // something we can do until we start detecting that Component extends
	    // React.Component. We already assume that typeof Component === 'function'.
	    var canInstantiate = ('prototype' in Component);
	
	    if (canInstantiate) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactCurrentOwner.current = this;
	        try {
	          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	        } finally {
	          ReactCurrentOwner.current = null;
	        }
	      } else {
	        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	      }
	    }
	
	    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
	      renderedElement = inst;
	      inst = new StatelessComponent(Component);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
	      } else {
	        // We support ES6 inheriting from React.Component, the module pattern,
	        // and stateless components, but not ES6 classes that don't extend
	        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
	      }
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = ReactUpdateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    if (inst.componentWillMount) {
	      inst.componentWillMount();
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    this._renderedComponent = this._instantiateReactComponent(renderedElement);
	
	    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }
	
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function () {
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount) {
	      inst.componentWillUnmount();
	    }
	
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	    this._instance = null;
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var maskedContext = null;
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
	      }
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function (newProps) {
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.propTypes) {
	        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
	      }
	    }
	    return newProps;
	  },
	
	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function (propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	          error = propTypes[propName](props, propName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // top-level render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);
	
	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
	          } else {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
	          }
	        }
	      }
	    }
	  },
	
	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
	    }
	
	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	
	    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
	    var nextProps;
	
	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement === nextParentElement) {
	      // Skip checking prop types again -- we don't read inst.props to avoid
	      // warning for DOM component props in this upgrade
	      nextProps = nextParentElement.props;
	    } else {
	      nextProps = this._processProps(nextParentElement.props);
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.
	
	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	
	    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
	    }
	
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);
	
	      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
	      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },
	
	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedComponent;
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactCurrentOwner.current = null;
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (inst instanceof StatelessComponent) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent',
	  _renderValidatedComponent: '_renderValidatedComponent'
	});
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(14);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
	      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(18);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 68 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	  return false;
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(43);
	var ReactEmptyComponentRegistry = __webpack_require__(45);
	var ReactReconciler = __webpack_require__(51);
	
	var assign = __webpack_require__(40);
	
	var placeholderElement;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function (component) {
	    placeholderElement = ReactElement.createElement(component);
	  }
	};
	
	function registerNullComponentID() {
	  ReactEmptyComponentRegistry.registerNullComponentID(this._rootNodeID);
	}
	
	var ReactEmptyComponent = function (instantiate) {
	  this._currentElement = null;
	  this._rootNodeID = null;
	  this._renderedComponent = instantiate(placeholderElement);
	};
	assign(ReactEmptyComponent.prototype, {
	  construct: function (element) {},
	  mountComponent: function (rootID, transaction, context) {
	    transaction.getReactMountReady().enqueue(registerNullComponentID, this);
	    this._rootNodeID = rootID;
	    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
	  },
	  receiveComponent: function () {},
	  unmountComponent: function (rootID, transaction, context) {
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
	    this._rootNodeID = null;
	    this._renderedComponent = null;
	  }
	});
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */
	
	'use strict';
	
	var assign = __webpack_require__(40);
	var invariant = __webpack_require__(14);
	
	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}
	
	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
	  return new genericComponentClass(element.type, element.props);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};
	
	module.exports = ReactNativeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var assign = __webpack_require__(40);
	var emptyFunction = __webpack_require__(16);
	var warning = __webpack_require__(26);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    parentTag: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.parentTag = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    /*eslint-disable space-after-keywords */
	    do {
	      /*eslint-enable space-after-keywords */
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
	      }
	    }
	  };
	
	  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(73);
	var ChangeEventPlugin = __webpack_require__(81);
	var ClientReactRootIndex = __webpack_require__(84);
	var DefaultEventPluginOrder = __webpack_require__(85);
	var EnterLeaveEventPlugin = __webpack_require__(86);
	var ExecutionEnvironment = __webpack_require__(10);
	var HTMLDOMPropertyConfig = __webpack_require__(90);
	var ReactBrowserComponentMixin = __webpack_require__(91);
	var ReactComponentBrowserEnvironment = __webpack_require__(27);
	var ReactDefaultBatchingStrategy = __webpack_require__(93);
	var ReactDOMComponent = __webpack_require__(94);
	var ReactDOMTextComponent = __webpack_require__(7);
	var ReactEventListener = __webpack_require__(119);
	var ReactInjection = __webpack_require__(122);
	var ReactInstanceHandles = __webpack_require__(46);
	var ReactMount = __webpack_require__(29);
	var ReactReconcileTransaction = __webpack_require__(126);
	var SelectEventPlugin = __webpack_require__(131);
	var ServerReactRootIndex = __webpack_require__(132);
	var SimpleEventPlugin = __webpack_require__(133);
	var SVGDOMPropertyConfig = __webpack_require__(142);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	
	  if (process.env.NODE_ENV !== 'production') {
	    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	    if (/[?&]react_perf\b/.test(url)) {
	      var ReactDefaultPerf = __webpack_require__(143);
	      ReactDefaultPerf.start();
	    }
	  }
	}
	
	module.exports = {
	  inject: inject
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(31);
	var EventPropagators = __webpack_require__(74);
	var ExecutionEnvironment = __webpack_require__(10);
	var FallbackCompositionState = __webpack_require__(75);
	var SyntheticCompositionEvent = __webpack_require__(77);
	var SyntheticInputEvent = __webpack_require__(79);
	
	var keyOf = __webpack_require__(80);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(31);
	var EventPluginHub = __webpack_require__(32);
	
	var warning = __webpack_require__(26);
	
	var accumulateInto = __webpack_require__(36);
	var forEachAccumulated = __webpack_require__(37);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(57);
	
	var assign = __webpack_require__(40);
	var getTextContentAccessor = __webpack_require__(76);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(10);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(78);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(57);
	
	var assign = __webpack_require__(40);
	var emptyFunction = __webpack_require__(16);
	var warning = __webpack_require__(26);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}
	
	assign(SyntheticEvent.prototype, {
	
	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(78);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ }),
/* 80 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	"use strict";
	
	var keyOf = function (oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(31);
	var EventPluginHub = __webpack_require__(32);
	var EventPropagators = __webpack_require__(74);
	var ExecutionEnvironment = __webpack_require__(10);
	var ReactUpdates = __webpack_require__(55);
	var SyntheticEvent = __webpack_require__(78);
	
	var getEventTarget = __webpack_require__(82);
	var isEventSupported = __webpack_require__(41);
	var isTextInputElement = __webpack_require__(83);
	var keyOf = __webpack_require__(80);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}
	
	function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}
	
	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}
	
	// For IE8 and IE9.
	function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	
	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }
	
	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ }),
/* 82 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ }),
/* 83 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
	}
	
	module.exports = isTextInputElement;

/***/ }),
/* 84 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var nextReactRootIndex = 0;
	
	var ClientReactRootIndex = {
	  createReactRootIndex: function () {
	    return nextReactRootIndex++;
	  }
	};
	
	module.exports = ClientReactRootIndex;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(80);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(31);
	var EventPropagators = __webpack_require__(74);
	var SyntheticMouseEvent = __webpack_require__(87);
	
	var ReactMount = __webpack_require__(29);
	var keyOf = __webpack_require__(80);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var extractedEvents = [null, null];
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    var fromID = '';
	    var toID = '';
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      fromID = topLevelTargetID;
	      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
	      if (to) {
	        toID = ReactMount.getID(to);
	      } else {
	        to = win;
	      }
	      to = to || win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	      toID = topLevelTargetID;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
	
	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;
	
	    return extractedEvents;
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(88);
	var ViewportMetrics = __webpack_require__(39);
	
	var getEventModifierState = __webpack_require__(89);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(78);
	
	var getEventTarget = __webpack_require__(82);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ }),
/* 89 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(24);
	var ExecutionEnvironment = __webpack_require__(10);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	}
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    challenge: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    inputMode: MUST_USE_ATTRIBUTE,
	    integrity: null,
	    is: MUST_USE_ATTRIBUTE,
	    keyParams: MUST_USE_ATTRIBUTE,
	    keyType: MUST_USE_ATTRIBUTE,
	    kind: null,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    minLength: MUST_USE_ATTRIBUTE,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    nonce: MUST_USE_ATTRIBUTE,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcLang: null,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    summary: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	    wrap: null,
	
	    /**
	     * RDFa Properties
	     */
	    about: MUST_USE_ATTRIBUTE,
	    datatype: MUST_USE_ATTRIBUTE,
	    inlist: MUST_USE_ATTRIBUTE,
	    prefix: MUST_USE_ATTRIBUTE,
	    // property is also supported for OpenGraph in meta tags.
	    property: MUST_USE_ATTRIBUTE,
	    resource: MUST_USE_ATTRIBUTE,
	    'typeof': MUST_USE_ATTRIBUTE,
	    vocab: MUST_USE_ATTRIBUTE,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: MUST_USE_ATTRIBUTE,
	    autoCorrect: MUST_USE_ATTRIBUTE,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: null,
	    // color is for Safari mask-icon link
	    color: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: null,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: MUST_USE_ATTRIBUTE,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoComplete: 'autocomplete',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    autoSave: 'autosave',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */
	
	'use strict';
	
	var ReactInstanceMap = __webpack_require__(48);
	
	var findDOMNode = __webpack_require__(92);
	var warning = __webpack_require__(26);
	
	var didWarnKey = '_getDOMNodeDidWarn';
	
	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function () {
	    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
	    this.constructor[didWarnKey] = true;
	    return findDOMNode(this);
	  }
	};
	
	module.exports = ReactBrowserComponentMixin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(6);
	var ReactInstanceMap = __webpack_require__(48);
	var ReactMount = __webpack_require__(29);
	
	var invariant = __webpack_require__(14);
	var warning = __webpack_require__(26);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
	   true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var ReactUpdates = __webpack_require__(55);
	var Transaction = __webpack_require__(58);
	
	var assign = __webpack_require__(40);
	var emptyFunction = __webpack_require__(16);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var AutoFocusUtils = __webpack_require__(95);
	var CSSPropertyOperations = __webpack_require__(97);
	var DOMProperty = __webpack_require__(24);
	var DOMPropertyOperations = __webpack_require__(23);
	var EventConstants = __webpack_require__(31);
	var ReactBrowserEventEmitter = __webpack_require__(30);
	var ReactComponentBrowserEnvironment = __webpack_require__(27);
	var ReactDOMButton = __webpack_require__(105);
	var ReactDOMInput = __webpack_require__(106);
	var ReactDOMOption = __webpack_require__(110);
	var ReactDOMSelect = __webpack_require__(113);
	var ReactDOMTextarea = __webpack_require__(114);
	var ReactMount = __webpack_require__(29);
	var ReactMultiChild = __webpack_require__(115);
	var ReactPerf = __webpack_require__(19);
	var ReactUpdateQueue = __webpack_require__(54);
	
	var assign = __webpack_require__(40);
	var canDefineProperty = __webpack_require__(44);
	var escapeTextContentForBrowser = __webpack_require__(22);
	var invariant = __webpack_require__(14);
	var isEventSupported = __webpack_require__(41);
	var keyOf = __webpack_require__(80);
	var setInnerHTML = __webpack_require__(20);
	var setTextContent = __webpack_require__(21);
	var shallowEqual = __webpack_require__(118);
	var validateDOMNesting = __webpack_require__(71);
	var warning = __webpack_require__(26);
	
	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var CHILDREN = keyOf({ children: null });
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	
	var ELEMENT_NODE_TYPE = 1;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	var legacyPropsDescriptor;
	if (process.env.NODE_ENV !== 'production') {
	  legacyPropsDescriptor = {
	    props: {
	      enumerable: false,
	      get: function () {
	        var component = this._reactInternalComponent;
	        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
	        return component._currentElement.props;
	      }
	    }
	  };
	}
	
	function legacyGetDOMNode() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return this;
	}
	
	function legacyIsMounted() {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return !!component;
	}
	
	function legacySetStateEtc() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	}
	
	function legacySetProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function legacyReplaceProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined becauses undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (process.env.NODE_ENV !== 'production') {
	    if (voidElementTags[component._tag]) {
	      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
	    }
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
	    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
	  }
	  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
	}
	
	function enqueuePutListener(id, registrationName, listener, transaction) {
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getReactMountReady().enqueue(putListener, {
	    id: id,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
	  var node = ReactMount.getNode(inst._rootNodeID);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
	
	  switch (inst._tag) {
	    case 'iframe':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	  }
	}
	
	function mountReadyInputWrapper() {
	  ReactDOMInput.mountReadyWrapper(this);
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = ({}).hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function processChildContextDev(context, inst) {
	  // Pass down our tag name to child components for validation purposes
	  context = assign({}, context);
	  var info = context[validateDOMNesting.ancestorInfoContextKey];
	  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  return context;
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag.toLowerCase();
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._nodeWithLegacyProperties = null;
	  if (process.env.NODE_ENV !== 'production') {
	    this._unprocessedContextDev = null;
	    this._processedContextDev = null;
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  construct: function (element) {
	    this._currentElement = element;
	  },
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._rootNodeID = rootID;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getNativeProps(this, props, context);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, context);
	        props = ReactDOMInput.getNativeProps(this, props, context);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, context);
	        props = ReactDOMOption.getNativeProps(this, props, context);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, context);
	        props = ReactDOMSelect.getNativeProps(this, props, context);
	        context = ReactDOMSelect.processChildContext(this, props, context);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, context);
	        props = ReactDOMTextarea.getNativeProps(this, props, context);
	        break;
	    }
	
	    assertValidProps(this, props);
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._unprocessedContextDev = context;
	      this._processedContextDev = processChildContextDev(context, this);
	      context = this._processedContextDev;
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement(this._currentElement.type);
	      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
	      // Populate node cache
	      ReactMount.getID(el);
	      this._updateDOMProperties({}, props, transaction, el);
	      this._createInitialChildren(transaction, props, context, el);
	      mountImage = el;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
	      // falls through
	      case 'button':
	      case 'select':
	      case 'textarea':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (propKey !== CHILDREN) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function (transaction, props, context, el) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        setInnerHTML(el, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        setTextContent(el, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          el.appendChild(mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
	        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
	        break;
	      case 'input':
	        ReactDOMInput.updateWrapper(this);
	        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
	        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
	        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
	        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
	        break;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // If the context is reference-equal to the old one, pass down the same
	      // processed object so the update bailout in ReactReconciler behaves
	      // correctly (and identically in dev and prod). See #5005.
	      if (this._unprocessedContextDev !== context) {
	        this._unprocessedContextDev = context;
	        this._processedContextDev = processChildContextDev(context, this);
	      }
	      context = this._processedContextDev;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction, null);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    if (!canDefineProperty && this._nodeWithLegacyProperties) {
	      this._nodeWithLegacyProperties.props = nextProps;
	    }
	
	    if (this._tag === 'select') {
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        DOMPropertyOperations.deleteValueForProperty(node, propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        if (propKey === CHILDREN) {
	          nextProp = null;
	        }
	        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertantly setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      if (!node) {
	        node = ReactMount.getNode(this._rootNodeID);
	      }
	      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function () {
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	        ReactDOMInput.unmountWrapper(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
	        break;
	    }
	
	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	    this._wrapperState = null;
	    if (this._nodeWithLegacyProperties) {
	      var node = this._nodeWithLegacyProperties;
	      node._reactInternalComponent = null;
	      this._nodeWithLegacyProperties = null;
	    }
	  },
	
	  getPublicInstance: function () {
	    if (!this._nodeWithLegacyProperties) {
	      var node = ReactMount.getNode(this._rootNodeID);
	
	      node._reactInternalComponent = this;
	      node.getDOMNode = legacyGetDOMNode;
	      node.isMounted = legacyIsMounted;
	      node.setState = legacySetStateEtc;
	      node.replaceState = legacySetStateEtc;
	      node.forceUpdate = legacySetStateEtc;
	      node.setProps = legacySetProps;
	      node.replaceProps = legacyReplaceProps;
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (canDefineProperty) {
	          Object.defineProperties(node, legacyPropsDescriptor);
	        } else {
	          // updateComponent will update this property on subsequent renders
	          node.props = this._currentElement.props;
	        }
	      } else {
	        // updateComponent will update this property on subsequent renders
	        node.props = this._currentElement.props;
	      }
	
	      this._nodeWithLegacyProperties = node;
	    }
	    return this._nodeWithLegacyProperties;
	  }
	
	};
	
	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});
	
	assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(29);
	
	var findDOMNode = __webpack_require__(92);
	var focusNode = __webpack_require__(96);
	
	var Mixin = {
	  componentDidMount: function () {
	    if (this.props.autoFocus) {
	      focusNode(findDOMNode(this));
	    }
	  }
	};
	
	var AutoFocusUtils = {
	  Mixin: Mixin,
	
	  focusDOMComponent: function () {
	    focusNode(ReactMount.getNode(this._rootNodeID));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ }),
/* 96 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	var ExecutionEnvironment = __webpack_require__(10);
	var ReactPerf = __webpack_require__(19);
	
	var camelizeStyleName = __webpack_require__(99);
	var dangerousStyleValue = __webpack_require__(101);
	var hyphenateStyleName = __webpack_require__(102);
	var memoizeStringOnly = __webpack_require__(104);
	var warning = __webpack_require__(26);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	
	  var warnHyphenatedStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };
	
	  var warnBadVendoredStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };
	
	  var warnStyleValueWithSemicolon = function (name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function (name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function (node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 98 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(100);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ }),
/* 100 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	"use strict";
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(98);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(103);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ }),
/* 103 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */
	
	'use strict';
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ }),
/* 104 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ }),
/* 105 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var mouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getNativeProps: function (inst, props, context) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var nativeProps = {};
	    for (var key in props) {
	      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
	        nativeProps[key] = props[key];
	      }
	    }
	
	    return nativeProps;
	  }
	};
	
	module.exports = ReactDOMButton;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(28);
	var LinkedValueUtils = __webpack_require__(107);
	var ReactMount = __webpack_require__(29);
	var ReactUpdates = __webpack_require__(55);
	
	var assign = __webpack_require__(40);
	var invariant = __webpack_require__(14);
	
	var instancesByReactID = {};
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getNativeProps: function (inst, props, context) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var nativeProps = assign({}, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  mountReadyWrapper: function (inst) {
	    // Can't be in mountWrapper or else server rendering leaks.
	    instancesByReactID[inst._rootNodeID] = inst;
	  },
	
	  unmountWrapper: function (inst) {
	    delete instancesByReactID[inst._rootNodeID];
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactMount.getNode(this._rootNodeID);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React with non-React.
	      var otherID = ReactMount.getID(otherNode);
	      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
	      var otherInstance = instancesByReactID[otherID];
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactPropTypes = __webpack_require__(108);
	var ReactPropTypeLocations = __webpack_require__(66);
	
	var invariant = __webpack_require__(14);
	var warning = __webpack_require__(26);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
	}
	
	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(43);
	var ReactPropTypeLocationNames = __webpack_require__(67);
	
	var emptyFunction = __webpack_require__(16);
	var getIteratorFn = __webpack_require__(109);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED') == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;

/***/ }),
/* 109 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/* global Symbol */
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(111);
	var ReactDOMSelect = __webpack_require__(113);
	
	var assign = __webpack_require__(40);
	var warning = __webpack_require__(26);
	
	var valueContextKey = ReactDOMSelect.valueContextKey;
	
	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, context) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
	    }
	
	    // Look up whether this option is 'selected' via context
	    var selectValue = context[valueContextKey];
	
	    // If context key is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === '' + props.value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === '' + props.value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  getNativeProps: function (inst, props, context) {
	    var nativeProps = assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      nativeProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = '';
	
	    // Flatten children and warn if they aren't strings or numbers;
	    // invalid types are ignored.
	    ReactChildren.forEach(props.children, function (child) {
	      if (child == null) {
	        return;
	      }
	      if (typeof child === 'string' || typeof child === 'number') {
	        content += child;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
	      }
	    });
	
	    if (content) {
	      nativeProps.children = content;
	    }
	
	    return nativeProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(57);
	var ReactElement = __webpack_require__(43);
	
	var emptyFunction = __webpack_require__(16);
	var traverseAllChildren = __webpack_require__(112);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(6);
	var ReactElement = __webpack_require__(43);
	var ReactInstanceHandles = __webpack_require__(46);
	
	var getIteratorFn = __webpack_require__(109);
	var invariant = __webpack_require__(14);
	var warning = __webpack_require__(26);
	
	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};
	
	var userProvidedKeyEscapeRegex = /[=.:]/g;
	
	var didWarnAboutMaps = false;
	
	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} text Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
	}
	
	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(107);
	var ReactMount = __webpack_require__(29);
	var ReactUpdates = __webpack_require__(55);
	
	var assign = __webpack_require__(40);
	var warning = __webpack_require__(26);
	
	var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    if (props.multiple) {
	      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    } else {
	      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactMount.getNode(inst._rootNodeID).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  valueContextKey: valueContextKey,
	
	  getNativeProps: function (inst, props, context) {
	    return assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	  },
	
	  processChildContext: function (inst, props, context) {
	    // Pass down initial value so initial generated markup has correct
	    // `selected` attributes
	    var childContext = assign({}, context);
	    childContext[valueContextKey] = inst._wrapperState.initialValue;
	    return childContext;
	  },
	
	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // the context value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  this._wrapperState.pendingUpdate = true;
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(107);
	var ReactDOMIDOperations = __webpack_require__(28);
	var ReactUpdates = __webpack_require__(55);
	
	var assign = __webpack_require__(40);
	var invariant = __webpack_require__(14);
	var warning = __webpack_require__(26);
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getNativeProps: function (inst, props, context) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    var nativeProps = assign({}, props, {
	      defaultValue: undefined,
	      value: undefined,
	      children: inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function (inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
	      }
	      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
	        children = children[0];
	      }
	
	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(props);
	
	    inst._wrapperState = {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue),
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(65);
	var ReactMultiChildUpdateTypes = __webpack_require__(17);
	
	var ReactCurrentOwner = __webpack_require__(6);
	var ReactReconciler = __webpack_require__(51);
	var ReactChildReconciler = __webpack_require__(116);
	
	var flattenChildren = __webpack_require__(117);
	
	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;
	
	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];
	
	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];
	
	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueInsertMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    content: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the markup of a node.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function enqueueSetMarkup(parentID, markup) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    markupIndex: null,
	    content: markup,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    content: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
	    clearQueue();
	  }
	}
	
	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements);
	      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChild(prevChildren[name]);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        this.setMarkup(nextMarkup);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildrenElements, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChild(prevChild);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChild(prevChildren[name]);
	        }
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function () {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, mountImage) {
	      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },
	
	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function (textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },
	
	    /**
	     * Sets this markup string.
	     *
	     * @param {string} markup Markup to set.
	     * @protected
	     */
	    setMarkup: function (markup) {
	      enqueueSetMarkup(this._rootNodeID, markup);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(51);
	
	var instantiateReactComponent = __webpack_require__(63);
	var shouldUpdateReactComponent = __webpack_require__(68);
	var traverseAllChildren = __webpack_require__(112);
	var warning = __webpack_require__(26);
	
	function instantiateChild(childInstances, child, name) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, null);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, transaction, context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, null);
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */
	
	'use strict';
	
	var traverseAllChildren = __webpack_require__(112);
	var warning = __webpack_require__(26);
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = result[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 118 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventListener = __webpack_require__(120);
	var ExecutionEnvironment = __webpack_require__(10);
	var PooledClass = __webpack_require__(57);
	var ReactInstanceHandles = __webpack_require__(46);
	var ReactMount = __webpack_require__(29);
	var ReactUpdates = __webpack_require__(55);
	
	var assign = __webpack_require__(40);
	var getEventTarget = __webpack_require__(82);
	var getUnboundedScrollPosition = __webpack_require__(121);
	
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  // TODO: Re-enable event.path handling
	  //
	  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
	  //   // New browsers have a path attribute on native events
	  //   handleTopLevelWithPath(bookKeeping);
	  // } else {
	  //   // Legacy browsers don't have a path attribute on native events
	  //   handleTopLevelWithoutPath(bookKeeping);
	  // }
	
	  void handleTopLevelWithPath; // temporarily unused
	  handleTopLevelWithoutPath(bookKeeping);
	}
	
	// Legacy browsers don't have a path attribute on native events
	function handleTopLevelWithoutPath(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	// New browsers have a path attribute on native events
	function handleTopLevelWithPath(bookKeeping) {
	  var path = bookKeeping.nativeEvent.path;
	  var currentNativeTarget = path[0];
	  var eventsFired = 0;
	  for (var i = 0; i < path.length; i++) {
	    var currentPathElement = path[i];
	    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
	      currentNativeTarget = path[i + 1];
	    }
	    // TODO: slow
	    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
	    if (reactParent === currentPathElement) {
	      var currentPathElementID = ReactMount.getID(currentPathElement);
	      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
	      bookKeeping.ancestors.push(currentPathElement);
	
	      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
	      eventsFired++;
	      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
	
	      // Jump to the root of this React render tree
	      while (currentPathElementID !== newRootID) {
	        i++;
	        currentPathElement = path[i];
	        currentPathElementID = ReactMount.getID(currentPathElement);
	      }
	    }
	  }
	  if (eventsFired === 0) {
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(16);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function () {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function () {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 121 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(24);
	var EventPluginHub = __webpack_require__(32);
	var ReactComponentEnvironment = __webpack_require__(65);
	var ReactClass = __webpack_require__(123);
	var ReactEmptyComponent = __webpack_require__(69);
	var ReactBrowserEventEmitter = __webpack_require__(30);
	var ReactNativeComponent = __webpack_require__(70);
	var ReactPerf = __webpack_require__(19);
	var ReactRootIndex = __webpack_require__(47);
	var ReactUpdates = __webpack_require__(55);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var ReactComponent = __webpack_require__(124);
	var ReactElement = __webpack_require__(43);
	var ReactPropTypeLocations = __webpack_require__(66);
	var ReactPropTypeLocationNames = __webpack_require__(67);
	var ReactNoopUpdateQueue = __webpack_require__(125);
	
	var assign = __webpack_require__(40);
	var emptyObject = __webpack_require__(59);
	var invariant = __webpack_require__(14);
	var keyMirror = __webpack_require__(18);
	var keyOf = __webpack_require__(80);
	var warning = __webpack_require__(26);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	var warnedSetProps = false;
	function warnSetProps() {
	  if (!warnedSetProps) {
	    warnedSetProps = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
	  }
	}
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
	    }
	  }
	}
	
	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	
	  var proto = Constructor.prototype;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    validateMethodOverride(proto, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = (name in RESERVED_SPEC_KEYS);
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
	
	    var isInherited = (name in Constructor);
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function (partialProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueSetProps(this, partialProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function (newProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  }
	};
	
	var ReactClassComponent = function () {};
	assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var ReactNoopUpdateQueue = __webpack_require__(125);
	
	var canDefineProperty = __webpack_require__(44);
	var emptyObject = __webpack_require__(59);
	var invariant = __webpack_require__(14);
	var warning = __webpack_require__(26);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
	  }
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
	    setProps: ['setProps', 'Instead, call render again at the top level.']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(26);
	
	function warnTDZ(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnTDZ(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnTDZ(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnTDZ(publicInstance, 'setState');
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    warnTDZ(publicInstance, 'setProps');
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    warnTDZ(publicInstance, 'replaceProps');
	  }
	
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(56);
	var PooledClass = __webpack_require__(57);
	var ReactBrowserEventEmitter = __webpack_require__(30);
	var ReactDOMFeatureFlags = __webpack_require__(42);
	var ReactInputSelection = __webpack_require__(127);
	var Transaction = __webpack_require__(58);
	
	var assign = __webpack_require__(40);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(forceHTML) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(128);
	
	var containsNode = __webpack_require__(60);
	var focusNode = __webpack_require__(96);
	var getActiveElement = __webpack_require__(130);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(10);
	
	var getNodeForCharacterOffset = __webpack_require__(129);
	var getTextContentAccessor = __webpack_require__(76);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ }),
/* 129 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ }),
/* 130 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	'use strict';
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(31);
	var EventPropagators = __webpack_require__(74);
	var ExecutionEnvironment = __webpack_require__(10);
	var ReactInputSelection = __webpack_require__(127);
	var SyntheticEvent = __webpack_require__(78);
	
	var getActiveElement = __webpack_require__(130);
	var isTextInputElement = __webpack_require__(83);
	var keyOf = __webpack_require__(80);
	var shallowEqual = __webpack_require__(118);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function (id, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ }),
/* 132 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
	
	var ServerReactRootIndex = {
	  createReactRootIndex: function () {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};
	
	module.exports = ServerReactRootIndex;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(31);
	var EventListener = __webpack_require__(120);
	var EventPropagators = __webpack_require__(74);
	var ReactMount = __webpack_require__(29);
	var SyntheticClipboardEvent = __webpack_require__(134);
	var SyntheticEvent = __webpack_require__(78);
	var SyntheticFocusEvent = __webpack_require__(135);
	var SyntheticKeyboardEvent = __webpack_require__(136);
	var SyntheticMouseEvent = __webpack_require__(87);
	var SyntheticDragEvent = __webpack_require__(139);
	var SyntheticTouchEvent = __webpack_require__(140);
	var SyntheticUIEvent = __webpack_require__(88);
	var SyntheticWheelEvent = __webpack_require__(141);
	
	var emptyFunction = __webpack_require__(16);
	var getEventCharCode = __webpack_require__(137);
	var invariant = __webpack_require__(14);
	var keyOf = __webpack_require__(80);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
	    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function (id, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var node = ReactMount.getNode(id);
	      if (!onClickListeners[id]) {
	        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function (id, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      onClickListeners[id].remove();
	      delete onClickListeners[id];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(78);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(88);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(88);
	
	var getEventCharCode = __webpack_require__(137);
	var getEventKey = __webpack_require__(138);
	var getEventModifierState = __webpack_require__(89);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(137);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(87);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(88);
	
	var getEventModifierState = __webpack_require__(89);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(87);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(24);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    xlinkActuate: MUST_USE_ATTRIBUTE,
	    xlinkArcrole: MUST_USE_ATTRIBUTE,
	    xlinkHref: MUST_USE_ATTRIBUTE,
	    xlinkRole: MUST_USE_ATTRIBUTE,
	    xlinkShow: MUST_USE_ATTRIBUTE,
	    xlinkTitle: MUST_USE_ATTRIBUTE,
	    xlinkType: MUST_USE_ATTRIBUTE,
	    xmlBase: MUST_USE_ATTRIBUTE,
	    xmlLang: MUST_USE_ATTRIBUTE,
	    xmlSpace: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox',
	    xlinkActuate: 'xlink:actuate',
	    xlinkArcrole: 'xlink:arcrole',
	    xlinkHref: 'xlink:href',
	    xlinkRole: 'xlink:role',
	    xlinkShow: 'xlink:show',
	    xlinkTitle: 'xlink:title',
	    xlinkType: 'xlink:type',
	    xmlBase: 'xml:base',
	    xmlLang: 'xml:lang',
	    xmlSpace: 'xml:space'
	  }
	};
	
	module.exports = SVGDOMPropertyConfig;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(24);
	var ReactDefaultPerfAnalysis = __webpack_require__(144);
	var ReactMount = __webpack_require__(29);
	var ReactPerf = __webpack_require__(19);
	
	var performanceNow = __webpack_require__(145);
	
	function roundFloat(val) {
	  return Math.floor(val * 100) / 100;
	}
	
	function addValue(obj, key, val) {
	  obj[key] = (obj[key] || 0) + val;
	}
	
	var ReactDefaultPerf = {
	  _allMeasurements: [], // last item in the list is the current one
	  _mountStack: [0],
	  _injected: false,
	
	  start: function () {
	    if (!ReactDefaultPerf._injected) {
	      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
	    }
	
	    ReactDefaultPerf._allMeasurements.length = 0;
	    ReactPerf.enableMeasure = true;
	  },
	
	  stop: function () {
	    ReactPerf.enableMeasure = false;
	  },
	
	  getLastMeasurements: function () {
	    return ReactDefaultPerf._allMeasurements;
	  },
	
	  printExclusive: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Component class name': item.componentName,
	        'Total inclusive time (ms)': roundFloat(item.inclusive),
	        'Exclusive mount time (ms)': roundFloat(item.exclusive),
	        'Exclusive render time (ms)': roundFloat(item.render),
	        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
	        'Render time per instance (ms)': roundFloat(item.render / item.count),
	        'Instances': item.count
	      };
	    }));
	    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
	    // number.
	  },
	
	  printInclusive: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Inclusive time (ms)': roundFloat(item.time),
	        'Instances': item.count
	      };
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  getMeasurementsSummaryMap: function (measurements) {
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
	    return summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Wasted time (ms)': item.time,
	        'Instances': item.count
	      };
	    });
	  },
	
	  printWasted: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  printDOM: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
	    console.table(summary.map(function (item) {
	      var result = {};
	      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
	      result.type = item.type;
	      result.args = JSON.stringify(item.args);
	      return result;
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  _recordWrite: function (id, fnName, totalTime, args) {
	    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
	    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
	    writes[id] = writes[id] || [];
	    writes[id].push({
	      type: fnName,
	      time: totalTime,
	      args: args
	    });
	  },
	
	  measure: function (moduleName, fnName, func) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      var totalTime;
	      var rv;
	      var start;
	
	      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
	        // A "measurement" is a set of metrics recorded for each flush. We want
	        // to group the metrics for a given flush together so we can look at the
	        // components that rendered and the DOM operations that actually
	        // happened to determine the amount of "wasted work" performed.
	        ReactDefaultPerf._allMeasurements.push({
	          exclusive: {},
	          inclusive: {},
	          render: {},
	          counts: {},
	          writes: {},
	          displayNames: {},
	          totalTime: 0,
	          created: {}
	        });
	        start = performanceNow();
	        rv = func.apply(this, args);
	        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
	        return rv;
	      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (fnName === '_mountImageIntoNode') {
	          var mountID = ReactMount.getID(args[1]);
	          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
	        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
	          // special format
	          args[0].forEach(function (update) {
	            var writeArgs = {};
	            if (update.fromIndex !== null) {
	              writeArgs.fromIndex = update.fromIndex;
	            }
	            if (update.toIndex !== null) {
	              writeArgs.toIndex = update.toIndex;
	            }
	            if (update.textContent !== null) {
	              writeArgs.textContent = update.textContent;
	            }
	            if (update.markupIndex !== null) {
	              writeArgs.markup = args[1][update.markupIndex];
	            }
	            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
	          });
	        } else {
	          // basic format
	          var id = args[0];
	          if (typeof id === 'object') {
	            id = ReactMount.getID(args[0]);
	          }
	          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
	        }
	        return rv;
	      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
	      fnName === '_renderValidatedComponent')) {
	
	        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
	          return func.apply(this, args);
	        }
	
	        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
	        var isRender = fnName === '_renderValidatedComponent';
	        var isMount = fnName === 'mountComponent';
	
	        var mountStack = ReactDefaultPerf._mountStack;
	        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
	
	        if (isRender) {
	          addValue(entry.counts, rootNodeID, 1);
	        } else if (isMount) {
	          entry.created[rootNodeID] = true;
	          mountStack.push(0);
	        }
	
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (isRender) {
	          addValue(entry.render, rootNodeID, totalTime);
	        } else if (isMount) {
	          var subMountTime = mountStack.pop();
	          mountStack[mountStack.length - 1] += totalTime;
	          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        } else {
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        }
	
	        entry.displayNames[rootNodeID] = {
	          current: this.getName(),
	          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
	        };
	
	        return rv;
	      } else {
	        return func.apply(this, args);
	      }
	    };
	  }
	};
	
	module.exports = ReactDefaultPerf;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerfAnalysis
	 */
	
	'use strict';
	
	var assign = __webpack_require__(40);
	
	// Don't try to save users less than 1.2ms (a number I made up)
	var DONT_CARE_THRESHOLD = 1.2;
	var DOM_OPERATION_TYPES = {
	  '_mountImageIntoNode': 'set innerHTML',
	  INSERT_MARKUP: 'set innerHTML',
	  MOVE_EXISTING: 'move',
	  REMOVE_NODE: 'remove',
	  SET_MARKUP: 'set innerHTML',
	  TEXT_CONTENT: 'set textContent',
	  'setValueForProperty': 'update attribute',
	  'setValueForAttribute': 'update attribute',
	  'deleteValueForProperty': 'remove attribute',
	  'setValueForStyles': 'update styles',
	  'replaceNodeWithMarkup': 'replace',
	  'updateTextContent': 'set textContent'
	};
	
	function getTotalTime(measurements) {
	  // TODO: return number of DOM ops? could be misleading.
	  // TODO: measure dropped frames after reconcile?
	  // TODO: log total time of each reconcile and the top-level component
	  // class that triggered it.
	  var totalTime = 0;
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    totalTime += measurement.totalTime;
	  }
	  return totalTime;
	}
	
	function getDOMSummary(measurements) {
	  var items = [];
	  measurements.forEach(function (measurement) {
	    Object.keys(measurement.writes).forEach(function (id) {
	      measurement.writes[id].forEach(function (write) {
	        items.push({
	          id: id,
	          type: DOM_OPERATION_TYPES[write.type] || write.type,
	          args: write.args
	        });
	      });
	    });
	  });
	  return items;
	}
	
	function getExclusiveSummary(measurements) {
	  var candidates = {};
	  var displayName;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	    for (var id in allIDs) {
	      displayName = measurement.displayNames[id].current;
	
	      candidates[displayName] = candidates[displayName] || {
	        componentName: displayName,
	        inclusive: 0,
	        exclusive: 0,
	        render: 0,
	        count: 0
	      };
	      if (measurement.render[id]) {
	        candidates[displayName].render += measurement.render[id];
	      }
	      if (measurement.exclusive[id]) {
	        candidates[displayName].exclusive += measurement.exclusive[id];
	      }
	      if (measurement.inclusive[id]) {
	        candidates[displayName].inclusive += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[displayName].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (displayName in candidates) {
	    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[displayName]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.exclusive - a.exclusive;
	  });
	
	  return arr;
	}
	
	function getInclusiveSummary(measurements, onlyClean) {
	  var candidates = {};
	  var inclusiveKey;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	    var cleanComponents;
	
	    if (onlyClean) {
	      cleanComponents = getUnchangedComponents(measurement);
	    }
	
	    for (var id in allIDs) {
	      if (onlyClean && !cleanComponents[id]) {
	        continue;
	      }
	
	      var displayName = measurement.displayNames[id];
	
	      // Inclusive time is not useful for many components without knowing where
	      // they are instantiated. So we aggregate inclusive time with both the
	      // owner and current displayName as the key.
	      inclusiveKey = displayName.owner + ' > ' + displayName.current;
	
	      candidates[inclusiveKey] = candidates[inclusiveKey] || {
	        componentName: inclusiveKey,
	        time: 0,
	        count: 0
	      };
	
	      if (measurement.inclusive[id]) {
	        candidates[inclusiveKey].time += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[inclusiveKey].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (inclusiveKey in candidates) {
	    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[inclusiveKey]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.time - a.time;
	  });
	
	  return arr;
	}
	
	function getUnchangedComponents(measurement) {
	  // For a given reconcile, look at which components did not actually
	  // render anything to the DOM and return a mapping of their ID to
	  // the amount of time it took to render the entire subtree.
	  var cleanComponents = {};
	  var dirtyLeafIDs = Object.keys(measurement.writes);
	  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	  for (var id in allIDs) {
	    var isDirty = false;
	    // For each component that rendered, see if a component that triggered
	    // a DOM op is in its subtree.
	    for (var i = 0; i < dirtyLeafIDs.length; i++) {
	      if (dirtyLeafIDs[i].indexOf(id) === 0) {
	        isDirty = true;
	        break;
	      }
	    }
	    // check if component newly created
	    if (measurement.created[id]) {
	      isDirty = true;
	    }
	    if (!isDirty && measurement.counts[id] > 0) {
	      cleanComponents[id] = true;
	    }
	  }
	  return cleanComponents;
	}
	
	var ReactDefaultPerfAnalysis = {
	  getExclusiveSummary: getExclusiveSummary,
	  getInclusiveSummary: getInclusiveSummary,
	  getDOMSummary: getDOMSummary,
	  getTotalTime: getTotalTime
	};
	
	module.exports = ReactDefaultPerfAnalysis;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performanceNow
	 * @typechecks
	 */
	
	'use strict';
	
	var performance = __webpack_require__(146);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function () {
	    return performance.now();
	  };
	} else {
	  performanceNow = function () {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performance
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(10);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ }),
/* 147 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '0.14.10';


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(29);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMServer
	 */
	
	'use strict';
	
	var ReactDefaultInjection = __webpack_require__(72);
	var ReactServerRendering = __webpack_require__(150);
	var ReactVersion = __webpack_require__(147);
	
	ReactDefaultInjection.inject();
	
	var ReactDOMServer = {
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  version: ReactVersion
	};
	
	module.exports = ReactDOMServer;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';
	
	var ReactDefaultBatchingStrategy = __webpack_require__(93);
	var ReactElement = __webpack_require__(43);
	var ReactInstanceHandles = __webpack_require__(46);
	var ReactMarkupChecksum = __webpack_require__(49);
	var ReactServerBatchingStrategy = __webpack_require__(151);
	var ReactServerRenderingTransaction = __webpack_require__(152);
	var ReactUpdates = __webpack_require__(55);
	
	var emptyObject = __webpack_require__(59);
	var instantiateReactComponent = __webpack_require__(63);
	var invariant = __webpack_require__(14);
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 151 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerBatchingStrategy
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactServerBatchingStrategy = {
	  isBatchingUpdates: false,
	  batchedUpdates: function (callback) {
	    // Don't do anything here. During the server rendering we don't want to
	    // schedule any updates. We will simply ignore them.
	  }
	};
	
	module.exports = ReactServerBatchingStrategy;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(57);
	var CallbackQueue = __webpack_require__(56);
	var Transaction = __webpack_require__(58);
	
	var assign = __webpack_require__(40);
	var emptyFunction = __webpack_require__(16);
	
	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },
	
	  close: emptyFunction
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = false;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactIsomorphic
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(111);
	var ReactComponent = __webpack_require__(124);
	var ReactClass = __webpack_require__(123);
	var ReactDOMFactories = __webpack_require__(154);
	var ReactElement = __webpack_require__(43);
	var ReactElementValidator = __webpack_require__(155);
	var ReactPropTypes = __webpack_require__(108);
	var ReactVersion = __webpack_require__(147);
	
	var assign = __webpack_require__(40);
	var onlyChild = __webpack_require__(157);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(43);
	var ReactElementValidator = __webpack_require__(155);
	
	var mapObject = __webpack_require__(156);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if (process.env.NODE_ENV !== 'production') {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hgroup: 'hgroup',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',
	
	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  image: 'image',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'
	
	}, createDOMFactory);
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(43);
	var ReactPropTypeLocations = __webpack_require__(66);
	var ReactPropTypeLocationNames = __webpack_require__(67);
	var ReactCurrentOwner = __webpack_require__(6);
	
	var canDefineProperty = __webpack_require__(44);
	var getIteratorFn = __webpack_require__(109);
	var invariant = __webpack_require__(14);
	var warning = __webpack_require__(26);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	var loggedTypeFailures = {};
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
	  if (addenda === null) {
	    // we already showed the warning
	    return;
	  }
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
	}
	
	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} messageType A key used for de-duping warnings.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 * @returns {?object} A set of addenda to use in the warning message, or null
	 * if the warning has already been shown before (and shouldn't be shown again).
	 */
	function getAddendaForKeyUse(messageType, element, parentType) {
	  var addendum = getDeclarationErrorAddendum();
	  if (!addendum) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      addendum = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	
	  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
	  if (memoizer[addendum]) {
	    return null;
	  }
	  memoizer[addendum] = true;
	
	  var addenda = {
	    parentOrOwner: addendum,
	    url: ' See https://fb.me/react-warning-keys for more information.',
	    childOwner: null
	  };
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  return addenda;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	        error = propTypes[propName](props, propName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum();
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 156 */
/***/ (function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}
	
	module.exports = mapObject;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var ReactElement = __webpack_require__(43);
	
	var invariant = __webpack_require__(14);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule deprecated
	 */
	
	'use strict';
	
	var assign = __webpack_require__(40);
	var warning = __webpack_require__(26);
	
	/**
	 * This will log a single deprecation notice per function and forward the call
	 * on to the new API.
	 *
	 * @param {string} fnName The name of the function
	 * @param {string} newModule The module that fn will exist in
	 * @param {string} newPackage The module that fn will exist in
	 * @param {*} ctx The context this forwarded call should run in
	 * @param {function} fn The function to forward on to
	 * @return {function} The function that will warn once and then call fn
	 */
	function deprecated(fnName, newModule, newPackage, ctx, fn) {
	  var warned = false;
	  if (process.env.NODE_ENV !== 'production') {
	    var newFn = function () {
	      process.env.NODE_ENV !== 'production' ? warning(warned,
	      // Require examples in this string must be split to prevent React's
	      // build tools from mistaking them for real requires.
	      // Otherwise the build tools will attempt to build a '%s' module.
	      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
	      warned = true;
	      return fn.apply(ctx, arguments);
	    };
	    // We need to make sure all properties of the original fn are copied over.
	    // In particular, this is needed to support PropTypes
	    return assign(newFn, fn);
	  }
	
	  return fn;
	}
	
	module.exports = deprecated;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(4);


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Panel = __webpack_require__(161);
	
	var _Panel2 = _interopRequireDefault(_Panel);
	
	var _Strip = __webpack_require__(163);
	
	var _Strip2 = _interopRequireDefault(_Strip);
	
	var _Character = __webpack_require__(164);
	
	var _Character2 = _interopRequireDefault(_Character);
	
	var _Balloon = __webpack_require__(165);
	
	var _Balloon2 = _interopRequireDefault(_Balloon);
	
	var _fabricWebpack = __webpack_require__(166);
	
	var _fabricWebpack2 = _interopRequireDefault(_fabricWebpack);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	module.exports = {
	    Panel: _Panel2.default,
	    Strip: _Strip2.default,
	    Balloon: _Balloon2.default,
	    Character: _Character2.default
	};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _objectAssign = __webpack_require__(162);
	
	var _objectAssign2 = _interopRequireDefault(_objectAssign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Panel = function (_Component) {
	    _inherits(Panel, _Component);
	
	    function Panel(props) {
	        _classCallCheck(this, Panel);
	
	        var _this2 = _possibleConstructorReturn(this, (Panel.__proto__ || Object.getPrototypeOf(Panel)).call(this, props));
	
	        _this2.state = {
	            props: {},
	            rect: null,
	            background: null
	        };
	        return _this2;
	    }
	
	    _createClass(Panel, [{
	        key: 'update',
	        value: function update() {
	            var _this3 = this;
	
	            var _this = this;
	            setTimeout(function () {
	                var _props = _this3.props,
	                    canvas = _props.canvas,
	                    index = _props.index;
	                var _props2 = _this3.props,
	                    parent = _props2.parent,
	                    height = _props2.height,
	                    padding = _props2.padding,
	                    fill = _props2.fill,
	                    stroke = _props2.stroke,
	                    strokeWidth = _props2.strokeWidth,
	                    background = _props2.background;
	
	
	                if (!canvas) return;
	
	                var _top = index * height + index * padding / 2;
	                var _left = 0;
	                var _width = parent.width - 2 * parent.padding - 2 * padding;
	                var _height = height;
	
	                if (parent.column > 1) {
	                    _top = Math.floor(index / parent.column) * height + Math.floor(index / parent.column) * padding;
	                    _width = Math.floor(parent.width / parent.column) - parent.padding - 2 * padding;
	                    _left = index % parent.column * _width + index % parent.column * padding;
	                }
	
	                // add padding
	                _top += parent.padding + padding;
	                _left += parent.padding + padding;
	
	                // add title padding
	                _top += 40;
	
	                var currentProps = {
	                    top: _top,
	                    left: _left,
	                    width: _width,
	                    height: _height,
	                    fill: fill,
	                    stroke: stroke,
	                    strokeWidth: strokeWidth,
	                    selectable: false
	                };
	
	                if (!_this3.state.rect) {
	                    var rect = new fabric.Rect(currentProps);
	                } else {
	                    var rect = _this3.state.rect;
	                    rect.set(currentProps);
	                }
	                _this3.setState({
	                    props: currentProps,
	                    rect: rect
	                });
	
	                if (background) {
	                    if (!_this3.state.background) {
	                        fabric.Image.fromURL(background, function (image) {
	                            _this3.setState({ background: image });
	                            image.set(currentProps);
	                            canvas.add(image);
	                        });
	                    }
	                }
	
	                canvas.add(rect);
	            });
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.update();
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps() {
	            this.update();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this = this;
	            var parentProps = (0, _objectAssign2.default)({}, _this.props, _this.state.props);
	            delete parentProps.children;
	            var childProps = (0, _objectAssign2.default)({}, { canvas: _this.props.canvas, parent: parentProps, rootParent: _this.props.rootParent });
	            var childrenWithProps = _react2.default.Children.map(this.props.children, function (child, id) {
	                var currentProps = (0, _objectAssign2.default)({}, childProps, { index: id });
	                return _react2.default.cloneElement(child, currentProps);
	            });
	            return _react2.default.createElement(
	                'div',
	                null,
	                childrenWithProps
	            );
	        }
	    }]);
	
	    return Panel;
	}(_react.Component);
	
	;
	
	Panel.defaultProps = {
	    height: 180,
	    padding: 20,
	    fill: 'white',
	    stroke: 'black',
	    strokeWidth: 3,
	    background: null
	};
	
	exports.default = Panel;

/***/ }),
/* 162 */
/***/ (function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	
	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _objectAssign = __webpack_require__(162);
	
	var _objectAssign2 = _interopRequireDefault(_objectAssign);
	
	var _reactDom = __webpack_require__(159);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Strip = function (_Component) {
	    _inherits(Strip, _Component);
	
	    function Strip(props) {
	        _classCallCheck(this, Strip);
	
	        var _this2 = _possibleConstructorReturn(this, (Strip.__proto__ || Object.getPrototypeOf(Strip)).call(this, props));
	
	        _this2.state = {
	            canvas: null
	        };
	        return _this2;
	    }
	
	    _createClass(Strip, [{
	        key: 'onDownload',
	        value: function onDownload() {
	            var canvas = this.state.canvas;
	
	            var link = this.downloadLink;
	            link.setAttribute('href', canvas.toDataURL());
	            link.setAttribute('download', this.props.title + '-react-komik.png');
	            link.click();
	        }
	    }, {
	        key: 'onEffect',
	        value: function onEffect(effect) {
	            var canvas = this.state.canvas;
	
	            canvas.deactivateAll();
	            var overlayImageUrl = canvas.toDataURL('png');
	            var imageDOM = _reactDom2.default.findDOMNode(this.imageBuffer);
	            imageDOM.setAttribute('src', overlayImageUrl);
	            imageDOM.setAttribute('crossOrigin', 'anonymous');
	            var filterImageUrl = imageDOM.getAttribute('src');
	            // patch fabric for cross domain image jazz
	
	            fabric.Image.fromURL(filterImageUrl, function (img) {
	                switch (effect) {
	                    case 'grayscale':
	                        img.filters.push(new fabric.Image.filters.Grayscale());
	                        break;
	                    case 'sepia':
	                        img.filters.push(new fabric.Image.filters.Sepia());
	                        break;
	                    case 'sepia2':
	                        img.filters.push(new fabric.Image.filters.Sepia2());
	                        break;
	                    case 'invert':
	                        img.filters.push(new fabric.Image.filters.Invert());
	                        break;
	                }
	                img.applyFilters(canvas.renderAll.bind(canvas));
	                canvas.add(img);
	            }, {
	                crossOrigin: 'anonymous'
	            });
	            canvas.deactivateAll().renderAll();
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            var canvas = new fabric.Canvas('canvas');
	            var _props = this.props,
	                padding = _props.padding,
	                width = _props.width,
	                height = _props.height,
	                fill = _props.fill,
	                stroke = _props.stroke,
	                fontFamily = _props.fontFamily,
	                strokeWidth = _props.strokeWidth,
	                fontSize = _props.fontSize;
	
	            var rect = new fabric.Rect({
	                top: padding,
	                left: padding,
	                width: width - 2 * padding,
	                height: height - 2 * padding,
	                fill: fill,
	                stroke: stroke,
	                selectable: false,
	                strokeWidth: strokeWidth
	            });
	            canvas.add(rect);
	
	            var title = this.props.title;
	            if (this.props.upperCase) title = title.toUpperCase();
	
	            var text = new fabric.Text(title, {
	                top: padding + 20,
	                left: width / 2,
	                originX: 'center',
	                textAlign: 'center',
	                fontSize: 26,
	                fontWeight: 'bold',
	                fontFamily: fontFamily
	            });
	            canvas.add(text);
	
	            this.setState({ canvas: canvas });
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this3 = this;
	
	            var _this = this;
	            var parentProps = (0, _objectAssign2.default)({}, _this.props);
	            delete parentProps.children;
	            var childProps = (0, _objectAssign2.default)({}, { canvas: _this.state.canvas, parent: parentProps, rootParent: parentProps });
	            var childrenWithProps = _react2.default.Children.map(this.props.children, function (child, id) {
	                var currentProps = (0, _objectAssign2.default)({}, childProps, { index: id });
	                return _react2.default.cloneElement(child, currentProps);
	            });
	            return _react2.default.createElement(
	                'div',
	                null,
	                _react2.default.createElement('canvas', _extends({ id: 'canvas' }, this.props)),
	                childrenWithProps,
	                _react2.default.createElement(
	                    'div',
	                    null,
	                    _react2.default.createElement(
	                        'button',
	                        { onClick: this.onEffect.bind(this, 'grayscale') },
	                        'Grayscale'
	                    ),
	                    _react2.default.createElement(
	                        'button',
	                        { onClick: this.onEffect.bind(this, 'sepia') },
	                        'Sepia'
	                    ),
	                    _react2.default.createElement(
	                        'button',
	                        { onClick: this.onEffect.bind(this, 'sepia2') },
	                        'Sepia 2'
	                    ),
	                    _react2.default.createElement(
	                        'button',
	                        { onClick: this.onEffect.bind(this, 'invert') },
	                        'Invert'
	                    ),
	                    _react2.default.createElement(
	                        'button',
	                        { onClick: this.onDownload.bind(this) },
	                        'Download'
	                    ),
	                    _react2.default.createElement('img', { ref: function ref(_ref) {
	                            return _this3.imageBuffer = _ref;
	                        }, crossOrigin: 'anonymous', src: '', style: { display: 'none' } }),
	                    _react2.default.createElement(
	                        'a',
	                        { ref: function ref(_ref2) {
	                                return _this3.downloadLink = _ref2;
	                            }, style: { display: 'none' } },
	                        'Download'
	                    )
	                )
	            );
	        }
	    }]);
	
	    return Strip;
	}(_react.Component);
	
	;
	
	Strip.defaultProps = {
	    width: 500,
	    height: 500,
	    top: 0,
	    left: 0,
	    padding: 0,
	    title: 'Comic Title',
	    column: 2,
	    fill: 'white',
	    stroke: 'black',
	    strokeWidth: 0,
	    fontFamily: 'Arial',
	    fontSize: 13,
	    upperCase: false
	};
	
	exports.default = Strip;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _objectAssign = __webpack_require__(162);
	
	var _objectAssign2 = _interopRequireDefault(_objectAssign);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Character = function (_Component) {
	    _inherits(Character, _Component);
	
	    function Character(props) {
	        _classCallCheck(this, Character);
	
	        var _this2 = _possibleConstructorReturn(this, (Character.__proto__ || Object.getPrototypeOf(Character)).call(this, props));
	
	        _this2.state = {
	            props: {},
	            image: null
	        };
	        return _this2;
	    }
	
	    _createClass(Character, [{
	        key: 'update',
	        value: function update() {
	            var _this3 = this;
	
	            var _this = this;
	            setTimeout(function () {
	                var _props = _this3.props,
	                    canvas = _props.canvas,
	                    index = _props.index;
	
	                if (!canvas) return;
	                fabric.Image.fromURL(_this3.props.image, function (image) {
	                    var _props2 = _this3.props,
	                        parent = _props2.parent,
	                        scale = _props2.scale,
	                        top = _props2.top,
	                        left = _props2.left,
	                        bottom = _props2.bottom,
	                        align = _props2.align;
	
	                    bottom = parseInt(bottom);
	
	                    if (_this3.state.image) image = _this3.state.image;
	
	                    image.scale(scale);
	                    // default use bottom
	                    var _top = parent.height - image.height * image.scaleY - bottom;
	                    if (top) _top = parseInt(top);
	
	                    // add parent top
	                    _top += parent.top;
	
	                    // default use align
	                    switch (align) {
	                        case 'center':
	                            var _left = parent.width / 2 - image.width * image.scaleX / 2;
	                            break;
	                        case 'right':
	                            var _left = parent.width - image.width * image.scaleX;
	                            break;
	                        case 'left':
	                        default:
	                            var _left = 0;
	                    }
	
	                    if (left) _left = parseInt(left);
	                    // add parent left
	                    _left += parent.left;
	
	                    var currentProps = {
	                        top: _top,
	                        left: _left,
	                        height: image.height,
	                        width: image.width
	                    };
	
	                    image.set(currentProps);
	
	                    if (!_this3.state.image) {
	                        _this3.setState({
	                            props: currentProps,
	                            image: image
	                        });
	                        canvas.add(image);
	                    }
	                }, {
	                    crossOrigin: 'anonymous'
	                });
	            });
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.update();
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps() {
	            this.update();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            var _this = this;
	            var parentProps = (0, _objectAssign2.default)({}, _this.props, _this.state.props);
	            delete parentProps.children;
	
	            var childProps = (0, _objectAssign2.default)({}, { canvas: _this.props.canvas, parent: parentProps, rootParent: _this.props.rootParent });
	            var childrenWithProps = _react2.default.Children.map(this.props.children, function (child, id) {
	                var currentProps = (0, _objectAssign2.default)({}, childProps, { index: id });
	                return _react2.default.cloneElement(child, currentProps);
	            });
	            return _react2.default.createElement(
	                'div',
	                null,
	                childrenWithProps
	            );
	        }
	    }]);
	
	    return Character;
	}(_react.Component);
	
	Character.defaultProps = {
	    image: 'char1.png',
	    scale: 1,
	    top: null,
	    left: null,
	    bottom: 0,
	    align: 'center'
	};
	
	exports.default = Character;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Balloon = function (_Component) {
	    _inherits(Balloon, _Component);
	
	    function Balloon(props) {
	        _classCallCheck(this, Balloon);
	
	        var _this2 = _possibleConstructorReturn(this, (Balloon.__proto__ || Object.getPrototypeOf(Balloon)).call(this, props));
	
	        _this2.state = {
	            image: null,
	            text: null,
	            group: null
	        };
	        return _this2;
	    }
	
	    _createClass(Balloon, [{
	        key: 'createBalloon',
	        value: function createBalloon() {
	            var _this3 = this;
	
	            var _this = this;
	            var _props = this.props,
	                canvas = _props.canvas,
	                index = _props.index;
	
	            return new Promise(function (resolve, reject) {
	                if (!canvas) reject(false);
	                fabric.loadSVGFromURL(_this3.props.image, function (objects, options) {
	                    var _this$props = _this.props,
	                        parent = _this$props.parent,
	                        top = _this$props.top,
	                        left = _this$props.left,
	                        bottom = _this$props.bottom,
	                        align = _this$props.align,
	                        scale = _this$props.scale,
	                        height = _this$props.height;
	
	                    bottom = parseInt(bottom);
	
	                    var image = fabric.util.groupSVGElements(objects, options);
	                    // if (this.state.image) image = this.state.image;
	
	                    image.scaleToHeight(height);
	
	                    // default use bottom
	                    var _top = -(image.height * image.scaleY) - bottom;
	                    if (top) _top = parseInt(top);
	
	                    // add parent top
	                    _top += parent.top;
	
	                    // default use align
	                    switch (align) {
	                        case 'center':
	                            var _left = parent.width / 2 - image.width * image.scaleX / 2;
	                            break;
	                        case 'right':
	                            var _left = parent.width - image.width * image.scaleX;
	                            break;
	                        case 'left':
	                        default:
	                            var _left = 0;
	                    }
	
	                    if (left) _left = parseInt(left);
	                    // add parent left
	                    _left += parent.left;
	
	                    var currentProps = {
	                        top: _top,
	                        left: _left
	                    };
	
	                    // canvas.add(image);
	
	                    _this3.setState({
	                        image: image
	                    });
	                    image.set(currentProps);
	                    resolve(image);
	                });
	            });
	        }
	    }, {
	        key: 'createText',
	        value: function createText(_this, image) {
	            var _this$props2 = _this.props,
	                canvas = _this$props2.canvas,
	                index = _this$props2.index;
	            var _this$props3 = _this.props,
	                parent = _this$props3.parent,
	                top = _this$props3.top,
	                left = _this$props3.left,
	                bottom = _this$props3.bottom,
	                align = _this$props3.align,
	                scale = _this$props3.scale,
	                fontFamily = _this$props3.fontFamily,
	                textAlign = _this$props3.textAlign,
	                padding = _this$props3.padding,
	                fontSize = _this$props3.fontSize;
	
	
	            if (!canvas) return;
	
	            var text = _this.props.text;
	            if (_this.props.rootParent.upperCase) text = text.toUpperCase();
	
	            var currentProps = {
	                top: image.top + padding,
	                left: image.left + padding,
	                width: image.width * image.scaleX - 2 * padding - 5,
	                height: image.height * image.scaleY - 2 * padding - 5,
	                fontSize: fontSize || _this.props.rootParent.fontSize,
	                fontWeight: 'bold',
	                textAlign: textAlign,
	                fontFamily: fontFamily || _this.props.rootParent.fontFamily
	            };
	
	            var text = new fabric.Textbox(text, currentProps);
	            var balloonGroup = new fabric.Group([image, text], {});
	
	            if (!this.state.group) {
	                this.setState({
	                    group: balloonGroup
	                });
	                canvas.add(balloonGroup);
	            } else {
	                canvas.remove(this.state.group);
	                this.setState({
	                    group: balloonGroup
	                });
	                canvas.add(balloonGroup);
	            }
	        }
	    }, {
	        key: 'update',
	        value: function update() {
	            var _this = this;
	            setTimeout(function () {
	                _this.createBalloon().then(function (image) {
	                    _this.createText(_this, image);
	                }, function () {});
	            });
	        }
	    }, {
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.update();
	        }
	    }, {
	        key: 'componentWillReceiveProps',
	        value: function componentWillReceiveProps() {
	            this.update();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement('div', null);
	        }
	    }]);
	
	    return Balloon;
	}(_react.Component);
	
	;
	
	Balloon.defaultProps = {
	    text: 'Hi Bro!',
	    image: 'chat_right.svg',
	    top: null,
	    left: null,
	    bottom: -70,
	    scale: 0.8,
	    align: 'left',
	    padding: 12,
	    height: 150,
	    textAlign: 'center',
	    fontFamily: null,
	    fontSize: null
	};
	
	exports.default = Balloon;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, process) {/* build: `node build.js modules=ALL exclude=json,gestures minifier=uglifyjs` */
	/*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */
	
	var fabric = fabric || { version: "1.6.0-rc.1" };
	if (true) {
	  exports.fabric = fabric;
	}
	
	if (typeof document !== 'undefined' && typeof window !== 'undefined') {
	  fabric.document = document;
	  fabric.window = window;
	  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
	  window.fabric = fabric;
	}
	else {
	  // assume we're running under node.js when document/window are not present
	  fabric.document = __webpack_require__(171)
	    .jsdom("<!DOCTYPE html><html><head></head><body></body></html>");
	
	  if (fabric.document.createWindow) {
	    fabric.window = fabric.document.createWindow();
	  } else {
	    fabric.window = fabric.document.parentWindow;
	  }
	}
	
	/**
	 * True when in environment that supports touch events
	 * @type boolean
	 */
	fabric.isTouchSupported = "ontouchstart" in fabric.document.documentElement;
	
	/**
	 * True when in environment that's probably Node.js
	 * @type boolean
	 */
	fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
	                      typeof window === 'undefined';
	
	/* _FROM_SVG_START_ */
	/**
	 * Attributes parsed from all SVG elements
	 * @type array
	 */
	fabric.SHARED_ATTRIBUTES = [
	  "display",
	  "transform",
	  "fill", "fill-opacity", "fill-rule",
	  "opacity",
	  "stroke", "stroke-dasharray", "stroke-linecap",
	  "stroke-linejoin", "stroke-miterlimit",
	  "stroke-opacity", "stroke-width",
	  "id"
	];
	/* _FROM_SVG_END_ */
	
	/**
	 * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
	 */
	fabric.DPI = 96;
	fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)';
	
	
	/**
	 * Device Pixel Ratio
	 * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
	 */
	fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
	                          fabric.window.webkitDevicePixelRatio ||
	                          fabric.window.mozDevicePixelRatio ||
	                          1;
	
	
	(function() {
	
	  /**
	   * @private
	   * @param {String} eventName
	   * @param {Function} handler
	   */
	  function _removeEventListener(eventName, handler) {
	    if (!this.__eventListeners[eventName]) {
	      return;
	    }
	
	    if (handler) {
	      fabric.util.removeFromArray(this.__eventListeners[eventName], handler);
	    }
	    else {
	      this.__eventListeners[eventName].length = 0;
	    }
	  }
	
	  /**
	   * Observes specified event
	   * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)
	   * @memberOf fabric.Observable
	   * @alias on
	   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
	   * @param {Function} handler Function that receives a notification when an event of the specified type occurs
	   * @return {Self} thisArg
	   * @chainable
	   */
	  function observe(eventName, handler) {
	    if (!this.__eventListeners) {
	      this.__eventListeners = { };
	    }
	    // one object with key/value pairs was passed
	    if (arguments.length === 1) {
	      for (var prop in eventName) {
	        this.on(prop, eventName[prop]);
	      }
	    }
	    else {
	      if (!this.__eventListeners[eventName]) {
	        this.__eventListeners[eventName] = [ ];
	      }
	      this.__eventListeners[eventName].push(handler);
	    }
	    return this;
	  }
	
	  /**
	   * Stops event observing for a particular event handler. Calling this method
	   * without arguments removes all handlers for all events
	   * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)
	   * @memberOf fabric.Observable
	   * @alias off
	   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
	   * @param {Function} handler Function to be deleted from EventListeners
	   * @return {Self} thisArg
	   * @chainable
	   */
	  function stopObserving(eventName, handler) {
	    if (!this.__eventListeners) {
	      return;
	    }
	
	    // remove all key/value pairs (event name -> event handler)
	    if (arguments.length === 0) {
	      this.__eventListeners = { };
	    }
	    // one object with key/value pairs was passed
	    else if (arguments.length === 1 && typeof arguments[0] === 'object') {
	      for (var prop in eventName) {
	        _removeEventListener.call(this, prop, eventName[prop]);
	      }
	    }
	    else {
	      _removeEventListener.call(this, eventName, handler);
	    }
	    return this;
	  }
	
	  /**
	   * Fires event with an optional options object
	   * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)
	   * @memberOf fabric.Observable
	   * @alias trigger
	   * @param {String} eventName Event name to fire
	   * @param {Object} [options] Options object
	   * @return {Self} thisArg
	   * @chainable
	   */
	  function fire(eventName, options) {
	    if (!this.__eventListeners) {
	      return;
	    }
	
	    var listenersForEvent = this.__eventListeners[eventName];
	    if (!listenersForEvent) {
	      return;
	    }
	
	    for (var i = 0, len = listenersForEvent.length; i < len; i++) {
	      // avoiding try/catch for perf. reasons
	      listenersForEvent[i].call(this, options || { });
	    }
	    return this;
	  }
	
	  /**
	   * @namespace fabric.Observable
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#events}
	   * @see {@link http://fabricjs.com/events/|Events demo}
	   */
	  fabric.Observable = {
	    observe: observe,
	    stopObserving: stopObserving,
	    fire: fire,
	
	    on: observe,
	    off: stopObserving,
	    trigger: fire
	  };
	})();
	
	
	/**
	 * @namespace fabric.Collection
	 */
	fabric.Collection = {
	
	  /**
	   * Adds objects to collection, then renders canvas (if `renderOnAddRemove` is not `false`)
	   * Objects should be instances of (or inherit from) fabric.Object
	   * @param {...fabric.Object} object Zero or more fabric instances
	   * @return {Self} thisArg
	   */
	  add: function () {
	    this._objects.push.apply(this._objects, arguments);
	    for (var i = 0, length = arguments.length; i < length; i++) {
	      this._onObjectAdded(arguments[i]);
	    }
	    this.renderOnAddRemove && this.renderAll();
	    return this;
	  },
	
	  /**
	   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
	   * An object should be an instance of (or inherit from) fabric.Object
	   * @param {Object} object Object to insert
	   * @param {Number} index Index to insert object at
	   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
	   * @return {Self} thisArg
	   * @chainable
	   */
	  insertAt: function (object, index, nonSplicing) {
	    var objects = this.getObjects();
	    if (nonSplicing) {
	      objects[index] = object;
	    }
	    else {
	      objects.splice(index, 0, object);
	    }
	    this._onObjectAdded(object);
	    this.renderOnAddRemove && this.renderAll();
	    return this;
	  },
	
	  /**
	   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
	   * @param {...fabric.Object} object Zero or more fabric instances
	   * @return {Self} thisArg
	   * @chainable
	   */
	  remove: function() {
	    var objects = this.getObjects(),
	        index;
	
	    for (var i = 0, length = arguments.length; i < length; i++) {
	      index = objects.indexOf(arguments[i]);
	
	      // only call onObjectRemoved if an object was actually removed
	      if (index !== -1) {
	        objects.splice(index, 1);
	        this._onObjectRemoved(arguments[i]);
	      }
	    }
	
	    this.renderOnAddRemove && this.renderAll();
	    return this;
	  },
	
	  /**
	   * Executes given function for each object in this group
	   * @param {Function} callback
	   *                   Callback invoked with current object as first argument,
	   *                   index - as second and an array of all objects - as third.
	   *                   Iteration happens in reverse order (for performance reasons).
	   *                   Callback is invoked in a context of Global Object (e.g. `window`)
	   *                   when no `context` argument is given
	   *
	   * @param {Object} context Context (aka thisObject)
	   * @return {Self} thisArg
	   */
	  forEachObject: function(callback, context) {
	    var objects = this.getObjects(),
	        i = objects.length;
	    while (i--) {
	      callback.call(context, objects[i], i, objects);
	    }
	    return this;
	  },
	
	  /**
	   * Returns an array of children objects of this instance
	   * Type parameter introduced in 1.3.10
	   * @param {String} [type] When specified, only objects of this type are returned
	   * @return {Array}
	   */
	  getObjects: function(type) {
	    if (typeof type === 'undefined') {
	      return this._objects;
	    }
	    return this._objects.filter(function(o) {
	      return o.type === type;
	    });
	  },
	
	  /**
	   * Returns object at specified index
	   * @param {Number} index
	   * @return {Self} thisArg
	   */
	  item: function (index) {
	    return this.getObjects()[index];
	  },
	
	  /**
	   * Returns true if collection contains no objects
	   * @return {Boolean} true if collection is empty
	   */
	  isEmpty: function () {
	    return this.getObjects().length === 0;
	  },
	
	  /**
	   * Returns a size of a collection (i.e: length of an array containing its objects)
	   * @return {Number} Collection size
	   */
	  size: function() {
	    return this.getObjects().length;
	  },
	
	  /**
	   * Returns true if collection contains an object
	   * @param {Object} object Object to check against
	   * @return {Boolean} `true` if collection contains an object
	   */
	  contains: function(object) {
	    return this.getObjects().indexOf(object) > -1;
	  },
	
	  /**
	   * Returns number representation of a collection complexity
	   * @return {Number} complexity
	   */
	  complexity: function () {
	    return this.getObjects().reduce(function (memo, current) {
	      memo += current.complexity ? current.complexity() : 0;
	      return memo;
	    }, 0);
	  }
	};
	
	
	(function(global) {
	
	  var sqrt = Math.sqrt,
	      atan2 = Math.atan2,
	      PiBy180 = Math.PI / 180;
	
	  /**
	   * @namespace fabric.util
	   */
	  fabric.util = {
	
	    /**
	     * Removes value from an array.
	     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} array
	     * @param {Any} value
	     * @return {Array} original array
	     */
	    removeFromArray: function(array, value) {
	      var idx = array.indexOf(value);
	      if (idx !== -1) {
	        array.splice(idx, 1);
	      }
	      return array;
	    },
	
	    /**
	     * Returns random number between 2 specified ones.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number} min lower limit
	     * @param {Number} max upper limit
	     * @return {Number} random value (between min and max)
	     */
	    getRandomInt: function(min, max) {
	      return Math.floor(Math.random() * (max - min + 1)) + min;
	    },
	
	    /**
	     * Transforms degrees to radians.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number} degrees value in degrees
	     * @return {Number} value in radians
	     */
	    degreesToRadians: function(degrees) {
	      return degrees * PiBy180;
	    },
	
	    /**
	     * Transforms radians to degrees.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number} radians value in radians
	     * @return {Number} value in degrees
	     */
	    radiansToDegrees: function(radians) {
	      return radians / PiBy180;
	    },
	
	    /**
	     * Rotates `point` around `origin` with `radians`
	     * @static
	     * @memberOf fabric.util
	     * @param {fabric.Point} point The point to rotate
	     * @param {fabric.Point} origin The origin of the rotation
	     * @param {Number} radians The radians of the angle for the rotation
	     * @return {fabric.Point} The new rotated point
	     */
	    rotatePoint: function(point, origin, radians) {
	      point.subtractEquals(origin);
	      var sin = Math.sin(radians),
	          cos = Math.cos(radians),
	          rx = point.x * cos - point.y * sin,
	          ry = point.x * sin + point.y * cos;
	      return new fabric.Point(rx, ry).addEquals(origin);
	    },
	
	    /**
	     * Apply transform t to point p
	     * @static
	     * @memberOf fabric.util
	     * @param  {fabric.Point} p The point to transform
	     * @param  {Array} t The transform
	     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
	     * @return {fabric.Point} The transformed point
	     */
	    transformPoint: function(p, t, ignoreOffset) {
	      if (ignoreOffset) {
	        return new fabric.Point(
	          t[0] * p.x + t[2] * p.y,
	          t[1] * p.x + t[3] * p.y
	        );
	      }
	      return new fabric.Point(
	        t[0] * p.x + t[2] * p.y + t[4],
	        t[1] * p.x + t[3] * p.y + t[5]
	      );
	    },
	
	    /**
	     * Invert transformation t
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} t The transform
	     * @return {Array} The inverted transform
	     */
	    invertTransform: function(t) {
	      var a = 1 / (t[0] * t[3] - t[1] * t[2]),
	          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
	          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
	      r[4] = -o.x;
	      r[5] = -o.y;
	      return r;
	    },
	
	    /**
	     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
	     * @static
	     * @memberOf fabric.util
	     * @param {Number|String} number number to operate on
	     * @param {Number} fractionDigits number of fraction digits to "leave"
	     * @return {Number}
	     */
	    toFixed: function(number, fractionDigits) {
	      return parseFloat(Number(number).toFixed(fractionDigits));
	    },
	
	    /**
	     * Converts from attribute value to pixel value if applicable.
	     * Returns converted pixels or original value not converted.
	     * @param {Number|String} value number to operate on
	     * @return {Number|String}
	     */
	    parseUnit: function(value, fontSize) {
	      var unit = /\D{0,2}$/.exec(value),
	          number = parseFloat(value);
	      if (!fontSize) {
	        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
	      }
	      switch (unit[0]) {
	        case 'mm':
	          return number * fabric.DPI / 25.4;
	
	        case 'cm':
	          return number * fabric.DPI / 2.54;
	
	        case 'in':
	          return number * fabric.DPI;
	
	        case 'pt':
	          return number * fabric.DPI / 72; // or * 4 / 3
	
	        case 'pc':
	          return number * fabric.DPI / 72 * 12; // or * 16
	
	        case 'em':
	          return number * fontSize;
	
	        default:
	          return number;
	      }
	    },
	
	    /**
	     * Function which always returns `false`.
	     * @static
	     * @memberOf fabric.util
	     * @return {Boolean}
	     */
	    falseFunction: function() {
	      return false;
	    },
	
	    /**
	     * Returns klass "Class" object of given namespace
	     * @memberOf fabric.util
	     * @param {String} type Type of object (eg. 'circle')
	     * @param {String} namespace Namespace to get klass "Class" object from
	     * @return {Object} klass "Class"
	     */
	    getKlass: function(type, namespace) {
	      // capitalize first letter only
	      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
	      return fabric.util.resolveNamespace(namespace)[type];
	    },
	
	    /**
	     * Returns object of given namespace
	     * @memberOf fabric.util
	     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
	     * @return {Object} Object for given namespace (default fabric)
	     */
	    resolveNamespace: function(namespace) {
	      if (!namespace) {
	        return fabric;
	      }
	
	      var parts = namespace.split('.'),
	          len = parts.length,
	          obj = global || fabric.window;
	
	      for (var i = 0; i < len; ++i) {
	        obj = obj[parts[i]];
	      }
	
	      return obj;
	    },
	
	    /**
	     * Loads image element from given url and passes it to a callback
	     * @memberOf fabric.util
	     * @param {String} url URL representing an image
	     * @param {Function} callback Callback; invoked with loaded image
	     * @param {Any} [context] Context to invoke callback in
	     * @param {Object} [crossOrigin] crossOrigin value to set image element to
	     */
	    loadImage: function(url, callback, context, crossOrigin) {
	      if (!url) {
	        callback && callback.call(context, url);
	        return;
	      }
	
	      var img = fabric.util.createImage();
	
	      /** @ignore */
	      img.onload = function () {
	        callback && callback.call(context, img);
	        img = img.onload = img.onerror = null;
	      };
	
	      /** @ignore */
	      img.onerror = function() {
	        fabric.log('Error loading ' + img.src);
	        callback && callback.call(context, null, true);
	        img = img.onload = img.onerror = null;
	      };
	
	      // data-urls appear to be buggy with crossOrigin
	      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
	      // see https://code.google.com/p/chromium/issues/detail?id=315152
	      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
	      if (url.indexOf('data') !== 0 && typeof crossOrigin !== 'undefined') {
	        img.crossOrigin = crossOrigin;
	      }
	
	      img.src = url;
	    },
	
	    /**
	     * Creates corresponding fabric instances from their object representations
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} objects Objects to enliven
	     * @param {Function} callback Callback to invoke when all objects are created
	     * @param {String} namespace Namespace to get klass "Class" object from
	     * @param {Function} reviver Method for further parsing of object elements,
	     * called after each fabric object created.
	     */
	    enlivenObjects: function(objects, callback, namespace, reviver) {
	      objects = objects || [ ];
	
	      function onLoaded() {
	        if (++numLoadedObjects === numTotalObjects) {
	          callback && callback(enlivenedObjects);
	        }
	      }
	
	      var enlivenedObjects = [ ],
	          numLoadedObjects = 0,
	          numTotalObjects = objects.length;
	
	      if (!numTotalObjects) {
	        callback && callback(enlivenedObjects);
	        return;
	      }
	
	      objects.forEach(function (o, index) {
	        // if sparse array
	        if (!o || !o.type) {
	          onLoaded();
	          return;
	        }
	        var klass = fabric.util.getKlass(o.type, namespace);
	        if (klass.async) {
	          klass.fromObject(o, function (obj, error) {
	            if (!error) {
	              enlivenedObjects[index] = obj;
	              reviver && reviver(o, enlivenedObjects[index]);
	            }
	            onLoaded();
	          });
	        }
	        else {
	          enlivenedObjects[index] = klass.fromObject(o);
	          reviver && reviver(o, enlivenedObjects[index]);
	          onLoaded();
	        }
	      });
	    },
	
	    /**
	     * Groups SVG elements (usually those retrieved from SVG document)
	     * @static
	     * @memberOf fabric.util
	     * @param {Array} elements SVG elements to group
	     * @param {Object} [options] Options object
	     * @return {fabric.Object|fabric.PathGroup}
	     */
	    groupSVGElements: function(elements, options, path) {
	      var object;
	
	      object = new fabric.PathGroup(elements, options);
	
	      if (typeof path !== 'undefined') {
	        object.setSourcePath(path);
	      }
	      return object;
	    },
	
	    /**
	     * Populates an object with properties of another object
	     * @static
	     * @memberOf fabric.util
	     * @param {Object} source Source object
	     * @param {Object} destination Destination object
	     * @return {Array} properties Propertie names to include
	     */
	    populateWithProperties: function(source, destination, properties) {
	      if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
	        for (var i = 0, len = properties.length; i < len; i++) {
	          if (properties[i] in source) {
	            destination[properties[i]] = source[properties[i]];
	          }
	        }
	      }
	    },
	
	    /**
	     * Draws a dashed line between two points
	     *
	     * This method is used to draw dashed line around selection area.
	     * See <a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas">dotted stroke in canvas</a>
	     *
	     * @param {CanvasRenderingContext2D} ctx context
	     * @param {Number} x  start x coordinate
	     * @param {Number} y start y coordinate
	     * @param {Number} x2 end x coordinate
	     * @param {Number} y2 end y coordinate
	     * @param {Array} da dash array pattern
	     */
	    drawDashedLine: function(ctx, x, y, x2, y2, da) {
	      var dx = x2 - x,
	          dy = y2 - y,
	          len = sqrt(dx * dx + dy * dy),
	          rot = atan2(dy, dx),
	          dc = da.length,
	          di = 0,
	          draw = true;
	
	      ctx.save();
	      ctx.translate(x, y);
	      ctx.moveTo(0, 0);
	      ctx.rotate(rot);
	
	      x = 0;
	      while (len > x) {
	        x += da[di++ % dc];
	        if (x > len) {
	          x = len;
	        }
	        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
	        draw = !draw;
	      }
	
	      ctx.restore();
	    },
	
	    /**
	     * Creates canvas element and initializes it via excanvas if necessary
	     * @static
	     * @memberOf fabric.util
	     * @param {CanvasElement} [canvasEl] optional canvas element to initialize;
	     * when not given, element is created implicitly
	     * @return {CanvasElement} initialized canvas element
	     */
	    createCanvasElement: function(canvasEl) {
	      canvasEl || (canvasEl = fabric.document.createElement('canvas'));
	      //jscs:disable requireCamelCaseOrUpperCaseIdentifiers
	      if (!canvasEl.getContext && typeof G_vmlCanvasManager !== 'undefined') {
	        G_vmlCanvasManager.initElement(canvasEl);
	      }
	      //jscs:enable requireCamelCaseOrUpperCaseIdentifiers
	      return canvasEl;
	    },
	
	    /**
	     * Creates image element (works on client and node)
	     * @static
	     * @memberOf fabric.util
	     * @return {HTMLImageElement} HTML image element
	     */
	    createImage: function() {
	      return fabric.isLikelyNode
	        ? new (__webpack_require__(172).Image)()
	        : fabric.document.createElement('img');
	    },
	
	    /**
	     * Creates accessors (getXXX, setXXX) for a "class", based on "stateProperties" array
	     * @static
	     * @memberOf fabric.util
	     * @param {Object} klass "Class" to create accessors for
	     */
	    createAccessors: function(klass) {
	      var proto = klass.prototype;
	
	      for (var i = proto.stateProperties.length; i--; ) {
	
	        var propName = proto.stateProperties[i],
	            capitalizedPropName = propName.charAt(0).toUpperCase() + propName.slice(1),
	            setterName = 'set' + capitalizedPropName,
	            getterName = 'get' + capitalizedPropName;
	
	        // using `new Function` for better introspection
	        if (!proto[getterName]) {
	          proto[getterName] = (function(property) {
	            return new Function('return this.get("' + property + '")');
	          })(propName);
	        }
	        if (!proto[setterName]) {
	          proto[setterName] = (function(property) {
	            return new Function('value', 'return this.set("' + property + '", value)');
	          })(propName);
	        }
	      }
	    },
	
	    /**
	     * @static
	     * @memberOf fabric.util
	     * @param {fabric.Object} receiver Object implementing `clipTo` method
	     * @param {CanvasRenderingContext2D} ctx Context to clip
	     */
	    clipContext: function(receiver, ctx) {
	      ctx.save();
	      ctx.beginPath();
	      receiver.clipTo(ctx);
	      ctx.clip();
	    },
	
	    /**
	     * Multiply matrix A by matrix B to nest transformations
	     * @static
	     * @memberOf fabric.util
	     * @param  {Array} a First transformMatrix
	     * @param  {Array} b Second transformMatrix
	     * @return {Array} The product of the two transform matrices
	     */
	    multiplyTransformMatrices: function(a, b) {
	      // Matrix multiply a * b
	      return [
	        a[0] * b[0] + a[2] * b[1],
	        a[1] * b[0] + a[3] * b[1],
	        a[0] * b[2] + a[2] * b[3],
	        a[1] * b[2] + a[3] * b[3],
	        a[0] * b[4] + a[2] * b[5] + a[4],
	        a[1] * b[4] + a[3] * b[5] + a[5]
	      ];
	    },
	
	    /**
	     * Returns string representation of function body
	     * @param {Function} fn Function to get body of
	     * @return {String} Function body
	     */
	    getFunctionBody: function(fn) {
	      return (String(fn).match(/function[^{]*\{([\s\S]*)\}/) || {})[1];
	    },
	
	    /**
	     * Returns true if context has transparent pixel
	     * at specified location (taking tolerance into account)
	     * @param {CanvasRenderingContext2D} ctx context
	     * @param {Number} x x coordinate
	     * @param {Number} y y coordinate
	     * @param {Number} tolerance Tolerance
	     */
	    isTransparent: function(ctx, x, y, tolerance) {
	
	      // If tolerance is > 0 adjust start coords to take into account.
	      // If moves off Canvas fix to 0
	      if (tolerance > 0) {
	        if (x > tolerance) {
	          x -= tolerance;
	        }
	        else {
	          x = 0;
	        }
	        if (y > tolerance) {
	          y -= tolerance;
	        }
	        else {
	          y = 0;
	        }
	      }
	
	      var _isTransparent = true,
	          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1);
	
	      // Split image data - for tolerance > 1, pixelDataSize = 4;
	      for (var i = 3, l = imageData.data.length; i < l; i += 4) {
	        var temp = imageData.data[i];
	        _isTransparent = temp <= 0;
	        if (_isTransparent === false) {
	          break; // Stop if colour found
	        }
	      }
	
	      imageData = null;
	
	      return _isTransparent;
	    }
	  };
	
	})( true ? exports : this);
	
	
	(function() {
	
	  var arcToSegmentsCache = { },
	      segmentToBezierCache = { },
	      boundsOfCurveCache = { },
	      _join = Array.prototype.join;
	
	  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
	   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
	   * http://mozilla.org/MPL/2.0/
	   */
	  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
	    var argsString = _join.call(arguments);
	    if (arcToSegmentsCache[argsString]) {
	      return arcToSegmentsCache[argsString];
	    }
	
	    var PI = Math.PI, th = rotateX * PI / 180,
	        sinTh = Math.sin(th),
	        cosTh = Math.cos(th),
	        fromX = 0, fromY = 0;
	
	    rx = Math.abs(rx);
	    ry = Math.abs(ry);
	
	    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
	        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
	        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
	        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
	        root = 0;
	
	    if (pl < 0) {
	      var s = Math.sqrt(1 - pl/(rx2 * ry2));
	      rx *= s;
	      ry *= s;
	    }
	    else {
	      root = (large === sweep ? -1.0 : 1.0) *
	              Math.sqrt( pl /(rx2 * py2 + ry2 * px2));
	    }
	
	    var cx = root * rx * py / ry,
	        cy = -root * ry * px / rx,
	        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
	        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
	        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
	        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);
	
	    if (sweep === 0 && dtheta > 0) {
	      dtheta -= 2 * PI;
	    }
	    else if (sweep === 1 && dtheta < 0) {
	      dtheta += 2 * PI;
	    }
	
	    // Convert into cubic bezier segments <= 90deg
	    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
	        result = [], mDelta = dtheta / segments,
	        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
	        th3 = mTheta + mDelta;
	
	    for (var i = 0; i < segments; i++) {
	      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
	      fromX = result[i][4];
	      fromY = result[i][5];
	      mTheta = th3;
	      th3 += mDelta;
	    }
	    arcToSegmentsCache[argsString] = result;
	    return result;
	  }
	
	  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
	    var argsString2 = _join.call(arguments);
	    if (segmentToBezierCache[argsString2]) {
	      return segmentToBezierCache[argsString2];
	    }
	
	    var costh2 = Math.cos(th2),
	        sinth2 = Math.sin(th2),
	        costh3 = Math.cos(th3),
	        sinth3 = Math.sin(th3),
	        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
	        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
	        cp1X = fromX + mT * ( - cosTh * rx * sinth2 - sinTh * ry * costh2),
	        cp1Y = fromY + mT * ( - sinTh * rx * sinth2 + cosTh * ry * costh2),
	        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
	        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);
	
	    segmentToBezierCache[argsString2] = [
	      cp1X, cp1Y,
	      cp2X, cp2Y,
	      toX, toY
	    ];
	    return segmentToBezierCache[argsString2];
	  }
	
	  /*
	   * Private
	   */
	  function calcVectorAngle(ux, uy, vx, vy) {
	    var ta = Math.atan2(uy, ux),
	        tb = Math.atan2(vy, vx);
	    if (tb >= ta) {
	      return tb - ta;
	    }
	    else {
	      return 2 * Math.PI - (ta - tb);
	    }
	  }
	
	  /**
	   * Draws arc
	   * @param {CanvasRenderingContext2D} ctx
	   * @param {Number} fx
	   * @param {Number} fy
	   * @param {Array} coords
	   */
	  fabric.util.drawArc = function(ctx, fx, fy, coords) {
	    var rx = coords[0],
	        ry = coords[1],
	        rot = coords[2],
	        large = coords[3],
	        sweep = coords[4],
	        tx = coords[5],
	        ty = coords[6],
	        segs = [[ ], [ ], [ ], [ ]],
	        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
	
	    for (var i = 0, len = segsNorm.length; i < len; i++) {
	      segs[i][0] = segsNorm[i][0] + fx;
	      segs[i][1] = segsNorm[i][1] + fy;
	      segs[i][2] = segsNorm[i][2] + fx;
	      segs[i][3] = segsNorm[i][3] + fy;
	      segs[i][4] = segsNorm[i][4] + fx;
	      segs[i][5] = segsNorm[i][5] + fy;
	      ctx.bezierCurveTo.apply(ctx, segs[i]);
	    }
	  };
	
	  /**
	   * Calculate bounding box of a elliptic-arc
	   * @param {Number} fx start point of arc
	   * @param {Number} fy
	   * @param {Number} rx horizontal radius
	   * @param {Number} ry vertical radius
	   * @param {Number} rot angle of horizontal axe
	   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
	   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
	   * @param {Number} tx end point of arc
	   * @param {Number} ty
	   */
	  fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {
	
	    var fromX = 0, fromY = 0, bound = [ ], bounds = [ ],
	    segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot),
	    boundCopy = [[ ], [ ]];
	
	    for (var i = 0, len = segs.length; i < len; i++) {
	      bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
	      boundCopy[0].x = bound[0].x + fx;
	      boundCopy[0].y = bound[0].y + fy;
	      boundCopy[1].x = bound[1].x + fx;
	      boundCopy[1].y = bound[1].y + fy;
	      bounds.push(boundCopy[0]);
	      bounds.push(boundCopy[1]);
	      fromX = segs[i][4];
	      fromY = segs[i][5];
	    }
	    return bounds;
	  };
	
	  /**
	   * Calculate bounding box of a beziercurve
	   * @param {Number} x0 starting point
	   * @param {Number} y0
	   * @param {Number} x1 first control point
	   * @param {Number} y1
	   * @param {Number} x2 secondo control point
	   * @param {Number} y2
	   * @param {Number} x3 end of beizer
	   * @param {Number} y3
	   */
	  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
	  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
	    var argsString = _join.call(arguments);
	    if (boundsOfCurveCache[argsString]) {
	      return boundsOfCurveCache[argsString];
	    }
	
	    var sqrt = Math.sqrt,
	        min = Math.min, max = Math.max,
	        abs = Math.abs, tvalues = [ ],
	        bounds = [[ ], [ ]],
	        a, b, c, t, t1, t2, b2ac, sqrtb2ac;
	
	    b = 6 * x0 - 12 * x1 + 6 * x2;
	    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
	    c = 3 * x1 - 3 * x0;
	
	    for (var i = 0; i < 2; ++i) {
	      if (i > 0) {
	        b = 6 * y0 - 12 * y1 + 6 * y2;
	        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
	        c = 3 * y1 - 3 * y0;
	      }
	
	      if (abs(a) < 1e-12) {
	        if (abs(b) < 1e-12) {
	          continue;
	        }
	        t = -c / b;
	        if (0 < t && t < 1) {
	          tvalues.push(t);
	        }
	        continue;
	      }
	      b2ac = b * b - 4 * c * a;
	      if (b2ac < 0) {
	        continue;
	      }
	      sqrtb2ac = sqrt(b2ac);
	      t1 = (-b + sqrtb2ac) / (2 * a);
	      if (0 < t1 && t1 < 1) {
	        tvalues.push(t1);
	      }
	      t2 = (-b - sqrtb2ac) / (2 * a);
	      if (0 < t2 && t2 < 1) {
	        tvalues.push(t2);
	      }
	    }
	
	    var x, y, j = tvalues.length, jlen = j, mt;
	    while (j--) {
	      t = tvalues[j];
	      mt = 1 - t;
	      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
	      bounds[0][j] = x;
	
	      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
	      bounds[1][j] = y;
	    }
	
	    bounds[0][jlen] = x0;
	    bounds[1][jlen] = y0;
	    bounds[0][jlen + 1] = x3;
	    bounds[1][jlen + 1] = y3;
	    var result = [
	      {
	        x: min.apply(null, bounds[0]),
	        y: min.apply(null, bounds[1])
	      },
	      {
	        x: max.apply(null, bounds[0]),
	        y: max.apply(null, bounds[1])
	      }
	    ];
	    boundsOfCurveCache[argsString] = result;
	    return result;
	  }
	
	  fabric.util.getBoundsOfCurve = getBoundsOfCurve;
	
	})();
	
	
	(function() {
	
	  var slice = Array.prototype.slice;
	
	  /* _ES5_COMPAT_START_ */
	
	  if (!Array.prototype.indexOf) {
	    /**
	     * Finds index of an element in an array
	     * @param {Any} searchElement
	     * @param {Number} [fromIndex]
	     * @return {Number}
	     */
	    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
	      if (this === void 0 || this === null) {
	        throw new TypeError();
	      }
	      var t = Object(this), len = t.length >>> 0;
	      if (len === 0) {
	        return -1;
	      }
	      var n = 0;
	      if (arguments.length > 0) {
	        n = Number(arguments[1]);
	        if (n !== n) { // shortcut for verifying if it's NaN
	          n = 0;
	        }
	        else if (n !== 0 && n !== Number.POSITIVE_INFINITY && n !== Number.NEGATIVE_INFINITY) {
	          n = (n > 0 || -1) * Math.floor(Math.abs(n));
	        }
	      }
	      if (n >= len) {
	        return -1;
	      }
	      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
	      for (; k < len; k++) {
	        if (k in t && t[k] === searchElement) {
	          return k;
	        }
	      }
	      return -1;
	    };
	  }
	
	  if (!Array.prototype.forEach) {
	    /**
	     * Iterates an array, invoking callback for each element
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Array}
	     */
	    Array.prototype.forEach = function(fn, context) {
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this) {
	          fn.call(context, this[i], i, this);
	        }
	      }
	    };
	  }
	
	  if (!Array.prototype.map) {
	    /**
	     * Returns a result of iterating over an array, invoking callback for each element
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Array}
	     */
	    Array.prototype.map = function(fn, context) {
	      var result = [ ];
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this) {
	          result[i] = fn.call(context, this[i], i, this);
	        }
	      }
	      return result;
	    };
	  }
	
	  if (!Array.prototype.every) {
	    /**
	     * Returns true if a callback returns truthy value for all elements in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Boolean}
	     */
	    Array.prototype.every = function(fn, context) {
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this && !fn.call(context, this[i], i, this)) {
	          return false;
	        }
	      }
	      return true;
	    };
	  }
	
	  if (!Array.prototype.some) {
	    /**
	     * Returns true if a callback returns truthy value for at least one element in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Boolean}
	     */
	    Array.prototype.some = function(fn, context) {
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this && fn.call(context, this[i], i, this)) {
	          return true;
	        }
	      }
	      return false;
	    };
	  }
	
	  if (!Array.prototype.filter) {
	    /**
	     * Returns the result of iterating over elements in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [context] Context to invoke callback in
	     * @return {Array}
	     */
	    Array.prototype.filter = function(fn, context) {
	      var result = [ ], val;
	      for (var i = 0, len = this.length >>> 0; i < len; i++) {
	        if (i in this) {
	          val = this[i]; // in case fn mutates this
	          if (fn.call(context, val, i, this)) {
	            result.push(val);
	          }
	        }
	      }
	      return result;
	    };
	  }
	
	  if (!Array.prototype.reduce) {
	    /**
	     * Returns "folded" (reduced) result of iterating over elements in an array
	     * @param {Function} fn Callback to invoke for each element
	     * @param {Object} [initial] Object to use as the first argument to the first call of the callback
	     * @return {Any}
	     */
	    Array.prototype.reduce = function(fn /*, initial*/) {
	      var len = this.length >>> 0,
	          i = 0,
	          rv;
	
	      if (arguments.length > 1) {
	        rv = arguments[1];
	      }
	      else {
	        do {
	          if (i in this) {
	            rv = this[i++];
	            break;
	          }
	          // if array contains no values, no initial value to return
	          if (++i >= len) {
	            throw new TypeError();
	          }
	        }
	        while (true);
	      }
	      for (; i < len; i++) {
	        if (i in this) {
	          rv = fn.call(null, rv, this[i], i, this);
	        }
	      }
	      return rv;
	    };
	  }
	
	  /* _ES5_COMPAT_END_ */
	
	  /**
	   * Invokes method on all items in a given array
	   * @memberOf fabric.util.array
	   * @param {Array} array Array to iterate over
	   * @param {String} method Name of a method to invoke
	   * @return {Array}
	   */
	  function invoke(array, method) {
	    var args = slice.call(arguments, 2), result = [ ];
	    for (var i = 0, len = array.length; i < len; i++) {
	      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
	    }
	    return result;
	  }
	
	  /**
	   * Finds maximum value in array (not necessarily "first" one)
	   * @memberOf fabric.util.array
	   * @param {Array} array Array to iterate over
	   * @param {String} byProperty
	   * @return {Any}
	   */
	  function max(array, byProperty) {
	    return find(array, byProperty, function(value1, value2) {
	      return value1 >= value2;
	    });
	  }
	
	  /**
	   * Finds minimum value in array (not necessarily "first" one)
	   * @memberOf fabric.util.array
	   * @param {Array} array Array to iterate over
	   * @param {String} byProperty
	   * @return {Any}
	   */
	  function min(array, byProperty) {
	    return find(array, byProperty, function(value1, value2) {
	      return value1 < value2;
	    });
	  }
	
	  /**
	   * @private
	   */
	  function find(array, byProperty, condition) {
	    if (!array || array.length === 0) {
	      return;
	    }
	
	    var i = array.length - 1,
	        result = byProperty ? array[i][byProperty] : array[i];
	    if (byProperty) {
	      while (i--) {
	        if (condition(array[i][byProperty], result)) {
	          result = array[i][byProperty];
	        }
	      }
	    }
	    else {
	      while (i--) {
	        if (condition(array[i], result)) {
	          result = array[i];
	        }
	      }
	    }
	    return result;
	  }
	
	  /**
	   * @namespace fabric.util.array
	   */
	  fabric.util.array = {
	    invoke: invoke,
	    min: min,
	    max: max
	  };
	
	})();
	
	
	(function() {
	
	  /**
	   * Copies all enumerable properties of one object to another
	   * @memberOf fabric.util.object
	   * @param {Object} destination Where to copy to
	   * @param {Object} source Where to copy from
	   * @return {Object}
	   */
	  function extend(destination, source) {
	    // JScript DontEnum bug is not taken care of
	    for (var property in source) {
	      destination[property] = source[property];
	    }
	    return destination;
	  }
	
	  /**
	   * Creates an empty object and copies all enumerable properties of another object to it
	   * @memberOf fabric.util.object
	   * @param {Object} object Object to clone
	   * @return {Object}
	   */
	  function clone(object) {
	    return extend({ }, object);
	  }
	
	  /** @namespace fabric.util.object */
	  fabric.util.object = {
	    extend: extend,
	    clone: clone
	  };
	
	})();
	
	
	(function() {
	
	  /* _ES5_COMPAT_START_ */
	  if (!String.prototype.trim) {
	    /**
	     * Trims a string (removing whitespace from the beginning and the end)
	     * @function external:String#trim
	     * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/String/Trim">String#trim on MDN</a>
	     */
	    String.prototype.trim = function () {
	      // this trim is not fully ES3 or ES5 compliant, but it should cover most cases for now
	      return this.replace(/^[\s\xA0]+/, '').replace(/[\s\xA0]+$/, '');
	    };
	  }
	  /* _ES5_COMPAT_END_ */
	
	  /**
	   * Camelizes a string
	   * @memberOf fabric.util.string
	   * @param {String} string String to camelize
	   * @return {String} Camelized version of a string
	   */
	  function camelize(string) {
	    return string.replace(/-+(.)?/g, function(match, character) {
	      return character ? character.toUpperCase() : '';
	    });
	  }
	
	  /**
	   * Capitalizes a string
	   * @memberOf fabric.util.string
	   * @param {String} string String to capitalize
	   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
	   * and other letters stay untouched, if false first letter is capitalized
	   * and other letters are converted to lowercase.
	   * @return {String} Capitalized version of a string
	   */
	  function capitalize(string, firstLetterOnly) {
	    return string.charAt(0).toUpperCase() +
	      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
	  }
	
	  /**
	   * Escapes XML in a string
	   * @memberOf fabric.util.string
	   * @param {String} string String to escape
	   * @return {String} Escaped version of a string
	   */
	  function escapeXml(string) {
	    return string.replace(/&/g, '&amp;')
	       .replace(/"/g, '&quot;')
	       .replace(/'/g, '&apos;')
	       .replace(/</g, '&lt;')
	       .replace(/>/g, '&gt;');
	  }
	
	  /**
	   * String utilities
	   * @namespace fabric.util.string
	   */
	  fabric.util.string = {
	    camelize: camelize,
	    capitalize: capitalize,
	    escapeXml: escapeXml
	  };
	}());
	
	
	/* _ES5_COMPAT_START_ */
	(function() {
	
	  var slice = Array.prototype.slice,
	      apply = Function.prototype.apply,
	      Dummy = function() { };
	
	  if (!Function.prototype.bind) {
	    /**
	     * Cross-browser approximation of ES5 Function.prototype.bind (not fully spec conforming)
	     * @see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Function#bind on MDN</a>
	     * @param {Object} thisArg Object to bind function to
	     * @param {Any[]} [...] Values to pass to a bound function
	     * @return {Function}
	     */
	    Function.prototype.bind = function(thisArg) {
	      var _this = this, args = slice.call(arguments, 1), bound;
	      if (args.length) {
	        bound = function() {
	          return apply.call(_this, this instanceof Dummy ? this : thisArg, args.concat(slice.call(arguments)));
	        };
	      }
	      else {
	        /** @ignore */
	        bound = function() {
	          return apply.call(_this, this instanceof Dummy ? this : thisArg, arguments);
	        };
	      }
	      Dummy.prototype = this.prototype;
	      bound.prototype = new Dummy();
	
	      return bound;
	    };
	  }
	
	})();
	/* _ES5_COMPAT_END_ */
	
	
	(function() {
	
	  var slice = Array.prototype.slice, emptyFunction = function() { },
	
	      IS_DONTENUM_BUGGY = (function() {
	        for (var p in { toString: 1 }) {
	          if (p === 'toString') {
	            return false;
	          }
	        }
	        return true;
	      })(),
	
	      /** @ignore */
	      addMethods = function(klass, source, parent) {
	        for (var property in source) {
	
	          if (property in klass.prototype &&
	              typeof klass.prototype[property] === 'function' &&
	              (source[property] + '').indexOf('callSuper') > -1) {
	
	            klass.prototype[property] = (function(property) {
	              return function() {
	
	                var superclass = this.constructor.superclass;
	                this.constructor.superclass = parent;
	                var returnValue = source[property].apply(this, arguments);
	                this.constructor.superclass = superclass;
	
	                if (property !== 'initialize') {
	                  return returnValue;
	                }
	              };
	            })(property);
	          }
	          else {
	            klass.prototype[property] = source[property];
	          }
	
	          if (IS_DONTENUM_BUGGY) {
	            if (source.toString !== Object.prototype.toString) {
	              klass.prototype.toString = source.toString;
	            }
	            if (source.valueOf !== Object.prototype.valueOf) {
	              klass.prototype.valueOf = source.valueOf;
	            }
	          }
	        }
	      };
	
	  function Subclass() { }
	
	  function callSuper(methodName) {
	    var fn = this.constructor.superclass.prototype[methodName];
	    return (arguments.length > 1)
	      ? fn.apply(this, slice.call(arguments, 1))
	      : fn.call(this);
	  }
	
	  /**
	   * Helper for creation of "classes".
	   * @memberOf fabric.util
	   * @param {Function} [parent] optional "Class" to inherit from
	   * @param {Object} [properties] Properties shared by all instances of this class
	   *                  (be careful modifying objects defined here as this would affect all instances)
	   */
	  function createClass() {
	    var parent = null,
	        properties = slice.call(arguments, 0);
	
	    if (typeof properties[0] === 'function') {
	      parent = properties.shift();
	    }
	    function klass() {
	      this.initialize.apply(this, arguments);
	    }
	
	    klass.superclass = parent;
	    klass.subclasses = [ ];
	
	    if (parent) {
	      Subclass.prototype = parent.prototype;
	      klass.prototype = new Subclass();
	      parent.subclasses.push(klass);
	    }
	    for (var i = 0, length = properties.length; i < length; i++) {
	      addMethods(klass, properties[i], parent);
	    }
	    if (!klass.prototype.initialize) {
	      klass.prototype.initialize = emptyFunction;
	    }
	    klass.prototype.constructor = klass;
	    klass.prototype.callSuper = callSuper;
	    return klass;
	  }
	
	  fabric.util.createClass = createClass;
	})();
	
	
	(function () {
	
	  var unknown = 'unknown';
	
	  /* EVENT HANDLING */
	
	  function areHostMethods(object) {
	    var methodNames = Array.prototype.slice.call(arguments, 1),
	        t, i, len = methodNames.length;
	    for (i = 0; i < len; i++) {
	      t = typeof object[methodNames[i]];
	      if (!(/^(?:function|object|unknown)$/).test(t)) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  /** @ignore */
	  var getElement,
	      setElement,
	      getUniqueId = (function () {
	        var uid = 0;
	        return function (element) {
	          return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);
	        };
	      })();
	
	  (function () {
	    var elements = { };
	    /** @ignore */
	    getElement = function (uid) {
	      return elements[uid];
	    };
	    /** @ignore */
	    setElement = function (uid, element) {
	      elements[uid] = element;
	    };
	  })();
	
	  function createListener(uid, handler) {
	    return {
	      handler: handler,
	      wrappedHandler: createWrappedHandler(uid, handler)
	    };
	  }
	
	  function createWrappedHandler(uid, handler) {
	    return function (e) {
	      handler.call(getElement(uid), e || fabric.window.event);
	    };
	  }
	
	  function createDispatcher(uid, eventName) {
	    return function (e) {
	      if (handlers[uid] && handlers[uid][eventName]) {
	        var handlersForEvent = handlers[uid][eventName];
	        for (var i = 0, len = handlersForEvent.length; i < len; i++) {
	          handlersForEvent[i].call(this, e || fabric.window.event);
	        }
	      }
	    };
	  }
	
	  var shouldUseAddListenerRemoveListener = (
	        areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &&
	        areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),
	
	      shouldUseAttachEventDetachEvent = (
	        areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &&
	        areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),
	
	      // IE branch
	      listeners = { },
	
	      // DOM L0 branch
	      handlers = { },
	
	      addListener, removeListener;
	
	  if (shouldUseAddListenerRemoveListener) {
	    /** @ignore */
	    addListener = function (element, eventName, handler) {
	      element.addEventListener(eventName, handler, false);
	    };
	    /** @ignore */
	    removeListener = function (element, eventName, handler) {
	      element.removeEventListener(eventName, handler, false);
	    };
	  }
	
	  else if (shouldUseAttachEventDetachEvent) {
	    /** @ignore */
	    addListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element);
	      setElement(uid, element);
	      if (!listeners[uid]) {
	        listeners[uid] = { };
	      }
	      if (!listeners[uid][eventName]) {
	        listeners[uid][eventName] = [ ];
	
	      }
	      var listener = createListener(uid, handler);
	      listeners[uid][eventName].push(listener);
	      element.attachEvent('on' + eventName, listener.wrappedHandler);
	    };
	    /** @ignore */
	    removeListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element), listener;
	      if (listeners[uid] && listeners[uid][eventName]) {
	        for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {
	          listener = listeners[uid][eventName][i];
	          if (listener && listener.handler === handler) {
	            element.detachEvent('on' + eventName, listener.wrappedHandler);
	            listeners[uid][eventName][i] = null;
	          }
	        }
	      }
	    };
	  }
	  else {
	    /** @ignore */
	    addListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element);
	      if (!handlers[uid]) {
	        handlers[uid] = { };
	      }
	      if (!handlers[uid][eventName]) {
	        handlers[uid][eventName] = [ ];
	        var existingHandler = element['on' + eventName];
	        if (existingHandler) {
	          handlers[uid][eventName].push(existingHandler);
	        }
	        element['on' + eventName] = createDispatcher(uid, eventName);
	      }
	      handlers[uid][eventName].push(handler);
	    };
	    /** @ignore */
	    removeListener = function (element, eventName, handler) {
	      var uid = getUniqueId(element);
	      if (handlers[uid] && handlers[uid][eventName]) {
	        var handlersForEvent = handlers[uid][eventName];
	        for (var i = 0, len = handlersForEvent.length; i < len; i++) {
	          if (handlersForEvent[i] === handler) {
	            handlersForEvent.splice(i, 1);
	          }
	        }
	      }
	    };
	  }
	
	  /**
	   * Adds an event listener to an element
	   * @function
	   * @memberOf fabric.util
	   * @param {HTMLElement} element
	   * @param {String} eventName
	   * @param {Function} handler
	   */
	  fabric.util.addListener = addListener;
	
	  /**
	   * Removes an event listener from an element
	   * @function
	   * @memberOf fabric.util
	   * @param {HTMLElement} element
	   * @param {String} eventName
	   * @param {Function} handler
	   */
	  fabric.util.removeListener = removeListener;
	
	  /**
	   * Cross-browser wrapper for getting event's coordinates
	   * @memberOf fabric.util
	   * @param {Event} event Event object
	   */
	  function getPointer(event) {
	    event || (event = fabric.window.event);
	
	    var element = event.target ||
	                  (typeof event.srcElement !== unknown ? event.srcElement : null),
	
	        scroll = fabric.util.getScrollLeftTop(element);
	
	    return {
	      x: pointerX(event) + scroll.left,
	      y: pointerY(event) + scroll.top
	    };
	  }
	
	  var pointerX = function(event) {
	    // looks like in IE (<9) clientX at certain point (apparently when mouseup fires on VML element)
	    // is represented as COM object, with all the consequences, like "unknown" type and error on [[Get]]
	    // need to investigate later
	    return (typeof event.clientX !== unknown ? event.clientX : 0);
	  },
	
	  pointerY = function(event) {
	    return (typeof event.clientY !== unknown ? event.clientY : 0);
	  };
	
	  function _getPointer(event, pageProp, clientProp) {
	    var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';
	
	    return (event[touchProp] && event[touchProp][0]
	      ? (event[touchProp][0][pageProp] - (event[touchProp][0][pageProp] - event[touchProp][0][clientProp]))
	        || event[clientProp]
	      : event[clientProp]);
	  }
	
	  if (fabric.isTouchSupported) {
	    pointerX = function(event) {
	      return _getPointer(event, 'pageX', 'clientX');
	    };
	    pointerY = function(event) {
	      return _getPointer(event, 'pageY', 'clientY');
	    };
	  }
	
	  fabric.util.getPointer = getPointer;
	
	  fabric.util.object.extend(fabric.util, fabric.Observable);
	
	})();
	
	
	(function () {
	
	  /**
	   * Cross-browser wrapper for setting element's style
	   * @memberOf fabric.util
	   * @param {HTMLElement} element
	   * @param {Object} styles
	   * @return {HTMLElement} Element that was passed as a first argument
	   */
	  function setStyle(element, styles) {
	    var elementStyle = element.style;
	    if (!elementStyle) {
	      return element;
	    }
	    if (typeof styles === 'string') {
	      element.style.cssText += ';' + styles;
	      return styles.indexOf('opacity') > -1
	        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
	        : element;
	    }
	    for (var property in styles) {
	      if (property === 'opacity') {
	        setOpacity(element, styles[property]);
	      }
	      else {
	        var normalizedProperty = (property === 'float' || property === 'cssFloat')
	          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
	          : property;
	        elementStyle[normalizedProperty] = styles[property];
	      }
	    }
	    return element;
	  }
	
	  var parseEl = fabric.document.createElement('div'),
	      supportsOpacity = typeof parseEl.style.opacity === 'string',
	      supportsFilters = typeof parseEl.style.filter === 'string',
	      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,
	
	      /** @ignore */
	      setOpacity = function (element) { return element; };
	
	  if (supportsOpacity) {
	    /** @ignore */
	    setOpacity = function(element, value) {
	      element.style.opacity = value;
	      return element;
	    };
	  }
	  else if (supportsFilters) {
	    /** @ignore */
	    setOpacity = function(element, value) {
	      var es = element.style;
	      if (element.currentStyle && !element.currentStyle.hasLayout) {
	        es.zoom = 1;
	      }
	      if (reOpacity.test(es.filter)) {
	        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
	        es.filter = es.filter.replace(reOpacity, value);
	      }
	      else {
	        es.filter += ' alpha(opacity=' + (value * 100) + ')';
	      }
	      return element;
	    };
	  }
	
	  fabric.util.setStyle = setStyle;
	
	})();
	
	
	(function() {
	
	  var _slice = Array.prototype.slice;
	
	  /**
	   * Takes id and returns an element with that id (if one exists in a document)
	   * @memberOf fabric.util
	   * @param {String|HTMLElement} id
	   * @return {HTMLElement|null}
	   */
	  function getById(id) {
	    return typeof id === 'string' ? fabric.document.getElementById(id) : id;
	  }
	
	  var sliceCanConvertNodelists,
	      /**
	       * Converts an array-like object (e.g. arguments or NodeList) to an array
	       * @memberOf fabric.util
	       * @param {Object} arrayLike
	       * @return {Array}
	       */
	      toArray = function(arrayLike) {
	        return _slice.call(arrayLike, 0);
	      };
	
	  try {
	    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
	  }
	  catch (err) { }
	
	  if (!sliceCanConvertNodelists) {
	    toArray = function(arrayLike) {
	      var arr = new Array(arrayLike.length), i = arrayLike.length;
	      while (i--) {
	        arr[i] = arrayLike[i];
	      }
	      return arr;
	    };
	  }
	
	  /**
	   * Creates specified element with specified attributes
	   * @memberOf fabric.util
	   * @param {String} tagName Type of an element to create
	   * @param {Object} [attributes] Attributes to set on an element
	   * @return {HTMLElement} Newly created element
	   */
	  function makeElement(tagName, attributes) {
	    var el = fabric.document.createElement(tagName);
	    for (var prop in attributes) {
	      if (prop === 'class') {
	        el.className = attributes[prop];
	      }
	      else if (prop === 'for') {
	        el.htmlFor = attributes[prop];
	      }
	      else {
	        el.setAttribute(prop, attributes[prop]);
	      }
	    }
	    return el;
	  }
	
	  /**
	   * Adds class to an element
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to add class to
	   * @param {String} className Class to add to an element
	   */
	  function addClass(element, className) {
	    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
	      element.className += (element.className ? ' ' : '') + className;
	    }
	  }
	
	  /**
	   * Wraps element with another element
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to wrap
	   * @param {HTMLElement|String} wrapper Element to wrap with
	   * @param {Object} [attributes] Attributes to set on a wrapper
	   * @return {HTMLElement} wrapper
	   */
	  function wrapElement(element, wrapper, attributes) {
	    if (typeof wrapper === 'string') {
	      wrapper = makeElement(wrapper, attributes);
	    }
	    if (element.parentNode) {
	      element.parentNode.replaceChild(wrapper, element);
	    }
	    wrapper.appendChild(element);
	    return wrapper;
	  }
	
	  /**
	   * Returns element scroll offsets
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to operate on
	   * @return {Object} Object with left/top values
	   */
	  function getScrollLeftTop(element) {
	
	    var left = 0,
	        top = 0,
	        docElement = fabric.document.documentElement,
	        body = fabric.document.body || {
	          scrollLeft: 0, scrollTop: 0
	        };
	
	    while (element && element.parentNode) {
	
	      element = element.parentNode;
	
	      if (element === fabric.document) {
	        left = body.scrollLeft || docElement.scrollLeft || 0;
	        top = body.scrollTop ||  docElement.scrollTop || 0;
	      }
	      else {
	        left += element.scrollLeft || 0;
	        top += element.scrollTop || 0;
	      }
	
	      if (element.nodeType === 1 &&
	          fabric.util.getElementStyle(element, 'position') === 'fixed') {
	        break;
	      }
	    }
	
	    return { left: left, top: top };
	  }
	
	  /**
	   * Returns offset for a given element
	   * @function
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to get offset for
	   * @return {Object} Object with "left" and "top" properties
	   */
	  function getElementOffset(element) {
	    var docElem,
	        doc = element && element.ownerDocument,
	        box = { left: 0, top: 0 },
	        offset = { left: 0, top: 0 },
	        scrollLeftTop,
	        offsetAttributes = {
	          borderLeftWidth: 'left',
	          borderTopWidth:  'top',
	          paddingLeft:     'left',
	          paddingTop:      'top'
	        };
	
	    if (!doc) {
	      return offset;
	    }
	
	    for (var attr in offsetAttributes) {
	      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
	    }
	
	    docElem = doc.documentElement;
	    if ( typeof element.getBoundingClientRect !== 'undefined' ) {
	      box = element.getBoundingClientRect();
	    }
	
	    scrollLeftTop = getScrollLeftTop(element);
	
	    return {
	      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
	      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
	    };
	  }
	
	  /**
	   * Returns style attribute value of a given element
	   * @memberOf fabric.util
	   * @param {HTMLElement} element Element to get style attribute for
	   * @param {String} attr Style attribute to get for element
	   * @return {String} Style attribute value of the given element.
	   */
	  var getElementStyle;
	  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
	    getElementStyle = function(element, attr) {
	      var style = fabric.document.defaultView.getComputedStyle(element, null);
	      return style ? style[attr] : undefined;
	    };
	  }
	  else {
	    getElementStyle = function(element, attr) {
	      var value = element.style[attr];
	      if (!value && element.currentStyle) {
	        value = element.currentStyle[attr];
	      }
	      return value;
	    };
	  }
	
	  (function () {
	    var style = fabric.document.documentElement.style,
	        selectProp = 'userSelect' in style
	          ? 'userSelect'
	          : 'MozUserSelect' in style
	            ? 'MozUserSelect'
	            : 'WebkitUserSelect' in style
	              ? 'WebkitUserSelect'
	              : 'KhtmlUserSelect' in style
	                ? 'KhtmlUserSelect'
	                : '';
	
	    /**
	     * Makes element unselectable
	     * @memberOf fabric.util
	     * @param {HTMLElement} element Element to make unselectable
	     * @return {HTMLElement} Element that was passed in
	     */
	    function makeElementUnselectable(element) {
	      if (typeof element.onselectstart !== 'undefined') {
	        element.onselectstart = fabric.util.falseFunction;
	      }
	      if (selectProp) {
	        element.style[selectProp] = 'none';
	      }
	      else if (typeof element.unselectable === 'string') {
	        element.unselectable = 'on';
	      }
	      return element;
	    }
	
	    /**
	     * Makes element selectable
	     * @memberOf fabric.util
	     * @param {HTMLElement} element Element to make selectable
	     * @return {HTMLElement} Element that was passed in
	     */
	    function makeElementSelectable(element) {
	      if (typeof element.onselectstart !== 'undefined') {
	        element.onselectstart = null;
	      }
	      if (selectProp) {
	        element.style[selectProp] = '';
	      }
	      else if (typeof element.unselectable === 'string') {
	        element.unselectable = '';
	      }
	      return element;
	    }
	
	    fabric.util.makeElementUnselectable = makeElementUnselectable;
	    fabric.util.makeElementSelectable = makeElementSelectable;
	  })();
	
	  (function() {
	
	    /**
	     * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading
	     * @memberOf fabric.util
	     * @param {String} url URL of a script to load
	     * @param {Function} callback Callback to execute when script is finished loading
	     */
	    function getScript(url, callback) {
	      var headEl = fabric.document.getElementsByTagName('head')[0],
	          scriptEl = fabric.document.createElement('script'),
	          loading = true;
	
	      /** @ignore */
	      scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {
	        if (loading) {
	          if (typeof this.readyState === 'string' &&
	              this.readyState !== 'loaded' &&
	              this.readyState !== 'complete') {
	            return;
	          }
	          loading = false;
	          callback(e || fabric.window.event);
	          scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;
	        }
	      };
	      scriptEl.src = url;
	      headEl.appendChild(scriptEl);
	      // causes issue in Opera
	      // headEl.removeChild(scriptEl);
	    }
	
	    fabric.util.getScript = getScript;
	  })();
	
	  fabric.util.getById = getById;
	  fabric.util.toArray = toArray;
	  fabric.util.makeElement = makeElement;
	  fabric.util.addClass = addClass;
	  fabric.util.wrapElement = wrapElement;
	  fabric.util.getScrollLeftTop = getScrollLeftTop;
	  fabric.util.getElementOffset = getElementOffset;
	  fabric.util.getElementStyle = getElementStyle;
	
	})();
	
	
	(function() {
	
	  function addParamToUrl(url, param) {
	    return url + (/\?/.test(url) ? '&' : '?') + param;
	  }
	
	  var makeXHR = (function() {
	    var factories = [
	      function() { return new ActiveXObject('Microsoft.XMLHTTP'); },
	      function() { return new ActiveXObject('Msxml2.XMLHTTP'); },
	      function() { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); },
	      function() { return new XMLHttpRequest(); }
	    ];
	    for (var i = factories.length; i--; ) {
	      try {
	        var req = factories[i]();
	        if (req) {
	          return factories[i];
	        }
	      }
	      catch (err) { }
	    }
	  })();
	
	  function emptyFn() { }
	
	  /**
	   * Cross-browser abstraction for sending XMLHttpRequest
	   * @memberOf fabric.util
	   * @param {String} url URL to send XMLHttpRequest to
	   * @param {Object} [options] Options object
	   * @param {String} [options.method="GET"]
	   * @param {Function} options.onComplete Callback to invoke when request is completed
	   * @return {XMLHttpRequest} request
	   */
	  function request(url, options) {
	
	    options || (options = { });
	
	    var method = options.method ? options.method.toUpperCase() : 'GET',
	        onComplete = options.onComplete || function() { },
	        xhr = makeXHR(),
	        body;
	
	    /** @ignore */
	    xhr.onreadystatechange = function() {
	      if (xhr.readyState === 4) {
	        onComplete(xhr);
	        xhr.onreadystatechange = emptyFn;
	      }
	    };
	
	    if (method === 'GET') {
	      body = null;
	      if (typeof options.parameters === 'string') {
	        url = addParamToUrl(url, options.parameters);
	      }
	    }
	
	    xhr.open(method, url, true);
	
	    if (method === 'POST' || method === 'PUT') {
	      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
	    }
	
	    xhr.send(body);
	    return xhr;
	  }
	
	  fabric.util.request = request;
	})();
	
	
	/**
	 * Wrapper around `console.log` (when available)
	 * @param {Any} [values] Values to log
	 */
	fabric.log = function() { };
	
	/**
	 * Wrapper around `console.warn` (when available)
	 * @param {Any} [values] Values to log as a warning
	 */
	fabric.warn = function() { };
	
	/* jshint ignore:start */
	if (typeof console !== 'undefined') {
	
	  ['log', 'warn'].forEach(function(methodName) {
	
	    if (typeof console[methodName] !== 'undefined' &&
	        typeof console[methodName].apply === 'function') {
	
	      fabric[methodName] = function() {
	        return console[methodName].apply(console, arguments);
	      };
	    }
	  });
	}
	/* jshint ignore:end */
	
	
	(function() {
	
	  /**
	   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
	   * @memberOf fabric.util
	   * @param {Object} [options] Animation options
	   * @param {Function} [options.onChange] Callback; invoked on every value change
	   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
	   * @param {Number} [options.startValue=0] Starting value
	   * @param {Number} [options.endValue=100] Ending value
	   * @param {Number} [options.byValue=100] Value to modify the property by
	   * @param {Function} [options.easing] Easing function
	   * @param {Number} [options.duration=500] Duration of change (in ms)
	   */
	  function animate(options) {
	
	    requestAnimFrame(function(timestamp) {
	      options || (options = { });
	
	      var start = timestamp || +new Date(),
	          duration = options.duration || 500,
	          finish = start + duration, time,
	          onChange = options.onChange || function() { },
	          abort = options.abort || function() { return false; },
	          easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},
	          startValue = 'startValue' in options ? options.startValue : 0,
	          endValue = 'endValue' in options ? options.endValue : 100,
	          byValue = options.byValue || endValue - startValue;
	
	      options.onStart && options.onStart();
	
	      (function tick(ticktime) {
	        time = ticktime || +new Date();
	        var currentTime = time > finish ? duration : (time - start);
	        if (abort()) {
	          options.onComplete && options.onComplete();
	          return;
	        }
	        onChange(easing(currentTime, startValue, byValue, duration));
	        if (time > finish) {
	          options.onComplete && options.onComplete();
	          return;
	        }
	        requestAnimFrame(tick);
	      })(start);
	    });
	
	  }
	
	  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
	                          fabric.window.webkitRequestAnimationFrame ||
	                          fabric.window.mozRequestAnimationFrame    ||
	                          fabric.window.oRequestAnimationFrame      ||
	                          fabric.window.msRequestAnimationFrame     ||
	                          function(callback) {
	                            fabric.window.setTimeout(callback, 1000 / 60);
	                          };
	
	  /**
	   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
	   * @memberOf fabric.util
	   * @param {Function} callback Callback to invoke
	   * @param {DOMElement} element optional Element to associate with animation
	   */
	  function requestAnimFrame() {
	    return _requestAnimFrame.apply(fabric.window, arguments);
	  }
	
	  fabric.util.animate = animate;
	  fabric.util.requestAnimFrame = requestAnimFrame;
	
	})();
	
	
	(function() {
	
	  function normalize(a, c, p, s) {
	    if (a < Math.abs(c)) {
	      a = c;
	      s = p / 4;
	    }
	    else {
	      s = p / (2 * Math.PI) * Math.asin(c / a);
	    }
	    return { a: a, c: c, p: p, s: s };
	  }
	
	  function elastic(opts, t, d) {
	    return opts.a *
	      Math.pow(2, 10 * (t -= 1)) *
	      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
	  }
	
	  /**
	   * Cubic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutCubic(t, b, c, d) {
	    return c * ((t = t / d - 1) * t * t + 1) + b;
	  }
	
	  /**
	   * Cubic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutCubic(t, b, c, d) {
	    t /= d/2;
	    if (t < 1) {
	      return c / 2 * t * t * t + b;
	    }
	    return c / 2 * ((t -= 2) * t * t + 2) + b;
	  }
	
	  /**
	   * Quartic easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInQuart(t, b, c, d) {
	    return c * (t /= d) * t * t * t + b;
	  }
	
	  /**
	   * Quartic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutQuart(t, b, c, d) {
	    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
	  }
	
	  /**
	   * Quartic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutQuart(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * t * t * t * t + b;
	    }
	    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
	  }
	
	  /**
	   * Quintic easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInQuint(t, b, c, d) {
	    return c * (t /= d) * t * t * t * t + b;
	  }
	
	  /**
	   * Quintic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutQuint(t, b, c, d) {
	    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	  }
	
	  /**
	   * Quintic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutQuint(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * t * t * t * t * t + b;
	    }
	    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	  }
	
	  /**
	   * Sinusoidal easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInSine(t, b, c, d) {
	    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
	  }
	
	  /**
	   * Sinusoidal easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutSine(t, b, c, d) {
	    return c * Math.sin(t / d * (Math.PI / 2)) + b;
	  }
	
	  /**
	   * Sinusoidal easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutSine(t, b, c, d) {
	    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	  }
	
	  /**
	   * Exponential easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInExpo(t, b, c, d) {
	    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
	  }
	
	  /**
	   * Exponential easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutExpo(t, b, c, d) {
	    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
	  }
	
	  /**
	   * Exponential easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutExpo(t, b, c, d) {
	    if (t === 0) {
	      return b;
	    }
	    if (t === d) {
	      return b + c;
	    }
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
	    }
	    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
	  }
	
	  /**
	   * Circular easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInCirc(t, b, c, d) {
	    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
	  }
	
	  /**
	   * Circular easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutCirc(t, b, c, d) {
	    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
	  }
	
	  /**
	   * Circular easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutCirc(t, b, c, d) {
	    t /= d / 2;
	    if (t < 1) {
	      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
	    }
	    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
	  }
	
	  /**
	   * Elastic easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInElastic(t, b, c, d) {
	    var s = 1.70158, p = 0, a = c;
	    if (t === 0) {
	      return b;
	    }
	    t /= d;
	    if (t === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    var opts = normalize(a, c, p, s);
	    return -elastic(opts, t, d) + b;
	  }
	
	  /**
	   * Elastic easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutElastic(t, b, c, d) {
	    var s = 1.70158, p = 0, a = c;
	    if (t === 0) {
	      return b;
	    }
	    t /= d;
	    if (t === 1) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * 0.3;
	    }
	    var opts = normalize(a, c, p, s);
	    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
	  }
	
	  /**
	   * Elastic easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutElastic(t, b, c, d) {
	    var s = 1.70158, p = 0, a = c;
	    if (t === 0) {
	      return b;
	    }
	    t /= d / 2;
	    if (t === 2) {
	      return b + c;
	    }
	    if (!p) {
	      p = d * (0.3 * 1.5);
	    }
	    var opts = normalize(a, c, p, s);
	    if (t < 1) {
	      return -0.5 * elastic(opts, t, d) + b;
	    }
	    return opts.a * Math.pow(2, -10 * (t -= 1)) *
	      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
	  }
	
	  /**
	   * Backwards easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInBack(t, b, c, d, s) {
	    if (s === undefined) {
	      s = 1.70158;
	    }
	    return c * (t /= d) * t * ((s + 1) * t - s) + b;
	  }
	
	  /**
	   * Backwards easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutBack(t, b, c, d, s) {
	    if (s === undefined) {
	      s = 1.70158;
	    }
	    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	  }
	
	  /**
	   * Backwards easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutBack(t, b, c, d, s) {
	    if (s === undefined) {
	      s = 1.70158;
	    }
	    t /= d / 2;
	    if (t < 1) {
	      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
	    }
	    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
	  }
	
	  /**
	   * Bouncing easing in
	   * @memberOf fabric.util.ease
	   */
	  function easeInBounce(t, b, c, d) {
	    return c - easeOutBounce (d - t, 0, c, d) + b;
	  }
	
	  /**
	   * Bouncing easing out
	   * @memberOf fabric.util.ease
	   */
	  function easeOutBounce(t, b, c, d) {
	    if ((t /= d) < (1 / 2.75)) {
	      return c * (7.5625 * t * t) + b;
	    }
	    else if (t < (2/2.75)) {
	      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
	    }
	    else if (t < (2.5/2.75)) {
	      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
	    }
	    else {
	      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
	    }
	  }
	
	  /**
	   * Bouncing easing in and out
	   * @memberOf fabric.util.ease
	   */
	  function easeInOutBounce(t, b, c, d) {
	    if (t < d / 2) {
	      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
	    }
	    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
	  }
	
	  /**
	   * Easing functions
	   * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
	   * @namespace fabric.util.ease
	   */
	  fabric.util.ease = {
	
	    /**
	     * Quadratic easing in
	     * @memberOf fabric.util.ease
	     */
	    easeInQuad: function(t, b, c, d) {
	      return c * (t /= d) * t + b;
	    },
	
	    /**
	     * Quadratic easing out
	     * @memberOf fabric.util.ease
	     */
	    easeOutQuad: function(t, b, c, d) {
	      return -c * (t /= d) * (t - 2) + b;
	    },
	
	    /**
	     * Quadratic easing in and out
	     * @memberOf fabric.util.ease
	     */
	    easeInOutQuad: function(t, b, c, d) {
	      t /= (d / 2);
	      if (t < 1) {
	        return c / 2 * t * t + b;
	      }
	      return -c / 2 * ((--t) * (t - 2) - 1) + b;
	    },
	
	    /**
	     * Cubic easing in
	     * @memberOf fabric.util.ease
	     */
	    easeInCubic: function(t, b, c, d) {
	      return c * (t /= d) * t * t + b;
	    },
	
	    easeOutCubic: easeOutCubic,
	    easeInOutCubic: easeInOutCubic,
	    easeInQuart: easeInQuart,
	    easeOutQuart: easeOutQuart,
	    easeInOutQuart: easeInOutQuart,
	    easeInQuint: easeInQuint,
	    easeOutQuint: easeOutQuint,
	    easeInOutQuint: easeInOutQuint,
	    easeInSine: easeInSine,
	    easeOutSine: easeOutSine,
	    easeInOutSine: easeInOutSine,
	    easeInExpo: easeInExpo,
	    easeOutExpo: easeOutExpo,
	    easeInOutExpo: easeInOutExpo,
	    easeInCirc: easeInCirc,
	    easeOutCirc: easeOutCirc,
	    easeInOutCirc: easeInOutCirc,
	    easeInElastic: easeInElastic,
	    easeOutElastic: easeOutElastic,
	    easeInOutElastic: easeInOutElastic,
	    easeInBack: easeInBack,
	    easeOutBack: easeOutBack,
	    easeInOutBack: easeInOutBack,
	    easeInBounce: easeInBounce,
	    easeOutBounce: easeOutBounce,
	    easeInOutBounce: easeInOutBounce
	  };
	
	}());
	
	
	(function(global) {
	
	  'use strict';
	
	  /**
	   * @name fabric
	   * @namespace
	   */
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      capitalize = fabric.util.string.capitalize,
	      clone = fabric.util.object.clone,
	      toFixed = fabric.util.toFixed,
	      parseUnit = fabric.util.parseUnit,
	      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,
	
	      reAllowedSVGTagNames = /^(path|circle|polygon|polyline|ellipse|rect|line|image|text)$/i,
	      reViewBoxTagNames = /^(symbol|image|marker|pattern|view|svg)$/i,
	      reNotAllowedAncestors = /^(?:pattern|defs|symbol|metadata)$/i,
	      reAllowedParents = /^(symbol|g|a|svg)$/i,
	
	      attributesMap = {
	        cx:                   'left',
	        x:                    'left',
	        r:                    'radius',
	        cy:                   'top',
	        y:                    'top',
	        display:              'visible',
	        visibility:           'visible',
	        transform:            'transformMatrix',
	        'fill-opacity':       'fillOpacity',
	        'fill-rule':          'fillRule',
	        'font-family':        'fontFamily',
	        'font-size':          'fontSize',
	        'font-style':         'fontStyle',
	        'font-weight':        'fontWeight',
	        'stroke-dasharray':   'strokeDashArray',
	        'stroke-linecap':     'strokeLineCap',
	        'stroke-linejoin':    'strokeLineJoin',
	        'stroke-miterlimit':  'strokeMiterLimit',
	        'stroke-opacity':     'strokeOpacity',
	        'stroke-width':       'strokeWidth',
	        'text-decoration':    'textDecoration',
	        'text-anchor':        'originX'
	      },
	
	      colorAttributes = {
	        stroke: 'strokeOpacity',
	        fill:   'fillOpacity'
	      };
	
	  fabric.cssRules = { };
	  fabric.gradientDefs = { };
	
	  function normalizeAttr(attr) {
	    // transform attribute names
	    if (attr in attributesMap) {
	      return attributesMap[attr];
	    }
	    return attr;
	  }
	
	  function normalizeValue(attr, value, parentAttributes, fontSize) {
	    var isArray = Object.prototype.toString.call(value) === '[object Array]',
	        parsed;
	
	    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
	      value = '';
	    }
	    else if (attr === 'strokeDashArray') {
	      value = value.replace(/,/g, ' ').split(/\s+/).map(function(n) {
	        return parseFloat(n);
	      });
	    }
	    else if (attr === 'transformMatrix') {
	      if (parentAttributes && parentAttributes.transformMatrix) {
	        value = multiplyTransformMatrices(
	          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
	      }
	      else {
	        value = fabric.parseTransformAttribute(value);
	      }
	    }
	    else if (attr === 'visible') {
	      value = (value === 'none' || value === 'hidden') ? false : true;
	      // display=none on parent element always takes precedence over child element
	      if (parentAttributes && parentAttributes.visible === false) {
	        value = false;
	      }
	    }
	    else if (attr === 'originX' /* text-anchor */) {
	      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
	    }
	    else {
	      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
	    }
	
	    return (!isArray && isNaN(parsed) ? value : parsed);
	  }
	
	  /**
	   * @private
	   * @param {Object} attributes Array of attributes to parse
	   */
	  function _setStrokeFillOpacity(attributes) {
	    for (var attr in colorAttributes) {
	
	      if (!attributes[attr] || typeof attributes[colorAttributes[attr]] === 'undefined') {
	        continue;
	      }
	
	      if (attributes[attr].indexOf('url(') === 0) {
	        continue;
	      }
	
	      var color = new fabric.Color(attributes[attr]);
	      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
	    }
	    return attributes;
	  }
	
	  /**
	   * Parses "transform" attribute, returning an array of values
	   * @static
	   * @function
	   * @memberOf fabric
	   * @param {String} attributeValue String containing attribute value
	   * @return {Array} Array of 6 elements representing transformation matrix
	   */
	  fabric.parseTransformAttribute = (function() {
	    function rotateMatrix(matrix, args) {
	      var angle = args[0];
	
	      matrix[0] = Math.cos(angle);
	      matrix[1] = Math.sin(angle);
	      matrix[2] = -Math.sin(angle);
	      matrix[3] = Math.cos(angle);
	    }
	
	    function scaleMatrix(matrix, args) {
	      var multiplierX = args[0],
	          multiplierY = (args.length === 2) ? args[1] : args[0];
	
	      matrix[0] = multiplierX;
	      matrix[3] = multiplierY;
	    }
	
	    function skewXMatrix(matrix, args) {
	      matrix[2] = Math.tan(fabric.util.degreesToRadians(args[0]));
	    }
	
	    function skewYMatrix(matrix, args) {
	      matrix[1] = Math.tan(fabric.util.degreesToRadians(args[0]));
	    }
	
	    function translateMatrix(matrix, args) {
	      matrix[4] = args[0];
	      if (args.length === 2) {
	        matrix[5] = args[1];
	      }
	    }
	
	    // identity matrix
	    var iMatrix = [
	          1, // a
	          0, // b
	          0, // c
	          1, // d
	          0, // e
	          0  // f
	        ],
	
	        // == begin transform regexp
	        number = fabric.reNum,
	
	        commaWsp = '(?:\\s+,?\\s*|,\\s*)',
	
	        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',
	
	        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',
	
	        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
	                    commaWsp + '(' + number + ')' +
	                    commaWsp + '(' + number + '))?\\s*\\))',
	
	        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
	                    commaWsp + '(' + number + '))?\\s*\\))',
	
	        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
	                    commaWsp + '(' + number + '))?\\s*\\))',
	
	        matrix = '(?:(matrix)\\s*\\(\\s*' +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' + commaWsp +
	                  '(' + number + ')' +
	                  '\\s*\\))',
	
	        transform = '(?:' +
	                    matrix + '|' +
	                    translate + '|' +
	                    scale + '|' +
	                    rotate + '|' +
	                    skewX + '|' +
	                    skewY +
	                    ')',
	
	        transforms = '(?:' + transform + '(?:' + commaWsp + transform + ')*' + ')',
	
	        transformList = '^\\s*(?:' + transforms + '?)\\s*$',
	
	        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
	        reTransformList = new RegExp(transformList),
	        // == end transform regexp
	
	        reTransform = new RegExp(transform, 'g');
	
	    return function(attributeValue) {
	
	      // start with identity matrix
	      var matrix = iMatrix.concat(),
	          matrices = [ ];
	
	      // return if no argument was given or
	      // an argument does not match transform attribute regexp
	      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
	        return matrix;
	      }
	
	      attributeValue.replace(reTransform, function(match) {
	
	        var m = new RegExp(transform).exec(match).filter(function (match) {
	              return (match !== '' && match != null);
	            }),
	            operation = m[1],
	            args = m.slice(2).map(parseFloat);
	
	        switch (operation) {
	          case 'translate':
	            translateMatrix(matrix, args);
	            break;
	          case 'rotate':
	            args[0] = fabric.util.degreesToRadians(args[0]);
	            rotateMatrix(matrix, args);
	            break;
	          case 'scale':
	            scaleMatrix(matrix, args);
	            break;
	          case 'skewX':
	            skewXMatrix(matrix, args);
	            break;
	          case 'skewY':
	            skewYMatrix(matrix, args);
	            break;
	          case 'matrix':
	            matrix = args;
	            break;
	        }
	
	        // snapshot current matrix into matrices array
	        matrices.push(matrix.concat());
	        // reset
	        matrix = iMatrix.concat();
	      });
	
	      var combinedMatrix = matrices[0];
	      while (matrices.length > 1) {
	        matrices.shift();
	        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
	      }
	      return combinedMatrix;
	    };
	  })();
	
	  /**
	   * @private
	   */
	  function parseStyleString(style, oStyle) {
	    var attr, value;
	    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
	      var pair = chunk.split(':');
	
	      attr = normalizeAttr(pair[0].trim().toLowerCase());
	      value = normalizeValue(attr, pair[1].trim());
	
	      oStyle[attr] = value;
	    });
	  }
	
	  /**
	   * @private
	   */
	  function parseStyleObject(style, oStyle) {
	    var attr, value;
	    for (var prop in style) {
	      if (typeof style[prop] === 'undefined') {
	        continue;
	      }
	
	      attr = normalizeAttr(prop.toLowerCase());
	      value = normalizeValue(attr, style[prop]);
	
	      oStyle[attr] = value;
	    }
	  }
	
	  /**
	   * @private
	   */
	  function getGlobalStylesForElement(element, svgUid) {
	    var styles = { };
	    for (var rule in fabric.cssRules[svgUid]) {
	      if (elementMatchesRule(element, rule.split(' '))) {
	        for (var property in fabric.cssRules[svgUid][rule]) {
	          styles[property] = fabric.cssRules[svgUid][rule][property];
	        }
	      }
	    }
	    return styles;
	  }
	
	  /**
	   * @private
	   */
	  function elementMatchesRule(element, selectors) {
	    var firstMatching, parentMatching = true;
	    //start from rightmost selector.
	    firstMatching = selectorMatches(element, selectors.pop());
	    if (firstMatching && selectors.length) {
	      parentMatching = doesSomeParentMatch(element, selectors);
	    }
	    return firstMatching && parentMatching && (selectors.length === 0);
	  }
	
	  function doesSomeParentMatch(element, selectors) {
	    var selector, parentMatching = true;
	    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
	      if (parentMatching) {
	        selector = selectors.pop();
	      }
	      element = element.parentNode;
	      parentMatching = selectorMatches(element, selector);
	    }
	    return selectors.length === 0;
	  }
	
	  /**
	   * @private
	   */
	  function selectorMatches(element, selector) {
	    var nodeName = element.nodeName,
	        classNames = element.getAttribute('class'),
	        id = element.getAttribute('id'), matcher;
	    // i check if a selector matches slicing away part from it.
	    // if i get empty string i should match
	    matcher = new RegExp('^' + nodeName, 'i');
	    selector = selector.replace(matcher, '');
	    if (id && selector.length) {
	      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
	      selector = selector.replace(matcher, '');
	    }
	    if (classNames && selector.length) {
	      classNames = classNames.split(' ');
	      for (var i = classNames.length; i--;) {
	        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
	        selector = selector.replace(matcher, '');
	      }
	    }
	    return selector.length === 0;
	  }
	
	  /**
	   * @private
	   * to support IE8 missing getElementById on SVGdocument
	   */
	  function elementById(doc, id) {
	    var el;
	    doc.getElementById && (el = doc.getElementById(id));
	    if (el) {
	      return el;
	    }
	    var node, i, idAttr, nodelist = doc.getElementsByTagName('*');
	    for (i = 0; i < nodelist.length; i++) {
	      node = nodelist[i];
	      if (idAttr === node.getAttribute('id')) {
	        return node;
	      }
	    }
	  }
	
	  /**
	   * @private
	   */
	  function parseUseDirectives(doc) {
	    var nodelist = doc.getElementsByTagName('use'), i = 0;
	    while (nodelist.length && i < nodelist.length) {
	      var el = nodelist[i],
	          xlink = el.getAttribute('xlink:href').substr(1),
	          x = el.getAttribute('x') || 0,
	          y = el.getAttribute('y') || 0,
	          el2 = elementById(doc, xlink).cloneNode(true),
	          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
	          parentNode, oldLength = nodelist.length, attr, j, attrs, l;
	
	      applyViewboxTransform(el2);
	      if (/^svg$/i.test(el2.nodeName)) {
	        var el3 = el2.ownerDocument.createElement('g');
	        for (j = 0, attrs = el2.attributes, l = attrs.length; j < l; j++) {
	          attr = attrs.item(j);
	          el3.setAttribute(attr.nodeName, attr.nodeValue);
	        }
	        while (el2.firstChild != null) {
	          el3.appendChild(el2.firstChild);
	        }
	        el2 = el3;
	      }
	
	      for (j = 0, attrs = el.attributes, l = attrs.length; j < l; j++) {
	        attr = attrs.item(j);
	        if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {
	          continue;
	        }
	
	        if (attr.nodeName === 'transform') {
	          currentTrans = attr.nodeValue + ' ' + currentTrans;
	        }
	        else {
	          el2.setAttribute(attr.nodeName, attr.nodeValue);
	        }
	      }
	
	      el2.setAttribute('transform', currentTrans);
	      el2.setAttribute('instantiated_by_use', '1');
	      el2.removeAttribute('id');
	      parentNode = el.parentNode;
	      parentNode.replaceChild(el2, el);
	      // some browsers do not shorten nodelist after replaceChild (IE8)
	      if (nodelist.length === oldLength) {
	        i++;
	      }
	    }
	  }
	
	  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
	  // matches, e.g.: +14.56e-12, etc.
	  var reViewBoxAttrValue = new RegExp(
	    '^' +
	    '\\s*(' + fabric.reNum + '+)\\s*,?' +
	    '\\s*(' + fabric.reNum + '+)\\s*,?' +
	    '\\s*(' + fabric.reNum + '+)\\s*,?' +
	    '\\s*(' + fabric.reNum + '+)\\s*' +
	    '$'
	  );
	
	  /**
	   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
	   */
	  function applyViewboxTransform(element) {
	
	    var viewBoxAttr = element.getAttribute('viewBox'),
	        scaleX = 1,
	        scaleY = 1,
	        minX = 0,
	        minY = 0,
	        viewBoxWidth, viewBoxHeight, matrix, el,
	        widthAttr = element.getAttribute('width'),
	        heightAttr = element.getAttribute('height'),
	        missingViewBox = (!viewBoxAttr || !reViewBoxTagNames.test(element.tagName)
	                           || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
	        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
	        toBeParsed = missingViewBox && missingDimAttr,
	        parsedDim = { };
	
	    parsedDim.width = 0;
	    parsedDim.height = 0;
	    parsedDim.toBeParsed = toBeParsed;
	
	    if (toBeParsed) {
	      return parsedDim;
	    }
	
	    if (missingViewBox) {
	      parsedDim.width = parseUnit(widthAttr);
	      parsedDim.height = parseUnit(heightAttr);
	      return parsedDim;
	    }
	
	    minX = -parseFloat(viewBoxAttr[1]),
	    minY = -parseFloat(viewBoxAttr[2]),
	    viewBoxWidth = parseFloat(viewBoxAttr[3]),
	    viewBoxHeight = parseFloat(viewBoxAttr[4]);
	
	    if (!missingDimAttr) {
	      parsedDim.width = parseUnit(widthAttr);
	      parsedDim.height = parseUnit(heightAttr);
	      scaleX = parsedDim.width / viewBoxWidth;
	      scaleY = parsedDim.height / viewBoxHeight;
	    }
	    else {
	      parsedDim.width = viewBoxWidth;
	      parsedDim.height = viewBoxHeight;
	    }
	
	    // default is to preserve aspect ratio
	    // preserveAspectRatio attribute to be implemented
	    scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
	
	    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0) {
	      return parsedDim;
	    }
	
	    matrix = ' matrix(' + scaleX +
	                  ' 0' +
	                  ' 0 ' +
	                  scaleY + ' ' +
	                  (minX * scaleX) + ' ' +
	                  (minY * scaleY) + ') ';
	
	    if (element.tagName === 'svg') {
	      el = element.ownerDocument.createElement('g');
	      while (element.firstChild != null) {
	        el.appendChild(element.firstChild);
	      }
	      element.appendChild(el);
	    }
	    else {
	      el = element;
	      matrix = el.getAttribute('transform') + matrix;
	    }
	
	    el.setAttribute('transform', matrix);
	    return parsedDim;
	  }
	
	  /**
	   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
	   * @static
	   * @function
	   * @memberOf fabric
	   * @param {SVGDocument} doc SVG document to parse
	   * @param {Function} callback Callback to call when parsing is finished; It's being passed an array of elements (parsed from a document).
	   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	   */
	  fabric.parseSVGDocument = (function() {
	
	    function hasAncestorWithNodeName(element, nodeName) {
	      while (element && (element = element.parentNode)) {
	        if (nodeName.test(element.nodeName) && !element.getAttribute('instantiated_by_use')) {
	          return true;
	        }
	      }
	      return false;
	    }
	
	    return function(doc, callback, reviver) {
	      if (!doc) {
	        return;
	      }
	
	      parseUseDirectives(doc);
	
	      var startTime = new Date(),
	          svgUid =  fabric.Object.__uid++,
	          options = applyViewboxTransform(doc),
	          descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
	
	      options.svgUid = svgUid;
	
	      if (descendants.length === 0 && fabric.isLikelyNode) {
	        // we're likely in node, where "o3-xml" library fails to gEBTN("*")
	        // https://github.com/ajaxorg/node-o3-xml/issues/21
	        descendants = doc.selectNodes('//*[name(.)!="svg"]');
	        var arr = [ ];
	        for (var i = 0, len = descendants.length; i < len; i++) {
	          arr[i] = descendants[i];
	        }
	        descendants = arr;
	      }
	
	      var elements = descendants.filter(function(el) {
	        applyViewboxTransform(el);
	        return reAllowedSVGTagNames.test(el.tagName) &&
	              !hasAncestorWithNodeName(el, reNotAllowedAncestors); // http://www.w3.org/TR/SVG/struct.html#DefsElement
	      });
	
	      if (!elements || (elements && !elements.length)) {
	        callback && callback([], {});
	        return;
	      }
	
	      fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
	      fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
	      // Precedence of rules:   style > class > attribute
	      fabric.parseElements(elements, function(instances) {
	        fabric.documentParsingTime = new Date() - startTime;
	        if (callback) {
	          callback(instances, options);
	        }
	      }, clone(options), reviver);
	    };
	  })();
	
	  /**
	   * Used for caching SVG documents (loaded via `fabric.Canvas#loadSVGFromURL`)
	   * @namespace
	   */
	  var svgCache = {
	
	    /**
	     * @param {String} name
	     * @param {Function} callback
	     */
	    has: function (name, callback) {
	      callback(false);
	    },
	
	    get: function () {
	      /* NOOP */
	    },
	
	    set: function () {
	      /* NOOP */
	    }
	  };
	
	  /**
	   * @private
	   */
	  function _enlivenCachedObject(cachedObject) {
	
	    var objects = cachedObject.objects,
	        options = cachedObject.options;
	
	    objects = objects.map(function (o) {
	      return fabric[capitalize(o.type)].fromObject(o);
	    });
	
	    return ({ objects: objects, options: options });
	  }
	
	  /**
	   * @private
	   */
	  function _createSVGPattern(markup, canvas, property) {
	    if (canvas[property] && canvas[property].toSVG) {
	      markup.push(
	        '<pattern x="0" y="0" id="', property, 'Pattern" ',
	          'width="', canvas[property].source.width,
	          '" height="', canvas[property].source.height,
	          '" patternUnits="userSpaceOnUse">',
	        '<image x="0" y="0" ',
	        'width="', canvas[property].source.width,
	        '" height="', canvas[property].source.height,
	        '" xlink:href="', canvas[property].source.src,
	        '"></image></pattern>'
	      );
	    }
	  }
	
	  var reFontDeclaration = new RegExp(
	    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
	    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
	      fabric.reNum +
	    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');
	
	  extend(fabric, {
	    /**
	     * Parses a short font declaration, building adding its properties to a style object
	     * @static
	     * @function
	     * @memberOf fabric
	     * @param {String} value font declaration
	     * @param {Object} oStyle definition
	     */
	    parseFontDeclaration: function(value, oStyle) {
	      var match = value.match(reFontDeclaration);
	
	      if (!match) {
	        return;
	      }
	      var fontStyle = match[1],
	          // font variant is not used
	          // fontVariant = match[2],
	          fontWeight = match[3],
	          fontSize = match[4],
	          lineHeight = match[5],
	          fontFamily = match[6];
	
	      if (fontStyle) {
	        oStyle.fontStyle = fontStyle;
	      }
	      if (fontWeight) {
	        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
	      }
	      if (fontSize) {
	        oStyle.fontSize = parseUnit(fontSize);
	      }
	      if (fontFamily) {
	        oStyle.fontFamily = fontFamily;
	      }
	      if (lineHeight) {
	        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
	      }
	    },
	
	    /**
	     * Parses an SVG document, returning all of the gradient declarations found in it
	     * @static
	     * @function
	     * @memberOf fabric
	     * @param {SVGDocument} doc SVG document to parse
	     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
	     */
	    getGradientDefs: function(doc) {
	      var linearGradientEls = doc.getElementsByTagName('linearGradient'),
	          radialGradientEls = doc.getElementsByTagName('radialGradient'),
	          el, i, j = 0, id, xlink, elList = [ ],
	          gradientDefs = { }, idsToXlinkMap = { };
	
	      elList.length = linearGradientEls.length + radialGradientEls.length;
	      i = linearGradientEls.length;
	      while (i--) {
	        elList[j++] = linearGradientEls[i];
	      }
	      i = radialGradientEls.length;
	      while (i--) {
	        elList[j++] = radialGradientEls[i];
	      }
	
	      while (j--) {
	        el = elList[j];
	        xlink = el.getAttribute('xlink:href');
	        id = el.getAttribute('id');
	        if (xlink) {
	          idsToXlinkMap[id] = xlink.substr(1);
	        }
	        gradientDefs[id] = el;
	      }
	
	      for (id in idsToXlinkMap) {
	        var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);
	        el = gradientDefs[id];
	        while (el2.firstChild) {
	          el.appendChild(el2.firstChild);
	        }
	      }
	      return gradientDefs;
	    },
	
	    /**
	     * Returns an object of attributes' name/value, given element and an array of attribute names;
	     * Parses parent "g" nodes recursively upwards.
	     * @static
	     * @memberOf fabric
	     * @param {DOMElement} element Element to parse
	     * @param {Array} attributes Array of attributes to parse
	     * @return {Object} object containing parsed attributes' names/values
	     */
	    parseAttributes: function(element, attributes, svgUid) {
	
	      if (!element) {
	        return;
	      }
	
	      var value,
	          parentAttributes = { },
	          fontSize;
	
	      if (typeof svgUid === 'undefined') {
	        svgUid = element.getAttribute('svgUid');
	      }
	      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
	      if (element.parentNode && reAllowedParents.test(element.parentNode.nodeName)) {
	        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
	      }
	      fontSize = (parentAttributes && parentAttributes.fontSize ) ||
	                 element.getAttribute('font-size') || fabric.Text.DEFAULT_SVG_FONT_SIZE;
	
	      var ownAttributes = attributes.reduce(function(memo, attr) {
	        value = element.getAttribute(attr);
	        if (value) {
	          attr = normalizeAttr(attr);
	          value = normalizeValue(attr, value, parentAttributes, fontSize);
	
	          memo[attr] = value;
	        }
	        return memo;
	      }, { });
	
	      // add values parsed from style, which take precedence over attributes
	      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
	      ownAttributes = extend(ownAttributes,
	        extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));
	      if (ownAttributes.font) {
	        fabric.parseFontDeclaration(ownAttributes.font, ownAttributes);
	      }
	      return _setStrokeFillOpacity(extend(parentAttributes, ownAttributes));
	    },
	
	    /**
	     * Transforms an array of svg elements to corresponding fabric.* instances
	     * @static
	     * @memberOf fabric
	     * @param {Array} elements Array of elements to parse
	     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
	     * @param {Object} [options] Options object
	     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	     */
	    parseElements: function(elements, callback, options, reviver) {
	      new fabric.ElementsParser(elements, callback, options, reviver).parse();
	    },
	
	    /**
	     * Parses "style" attribute, retuning an object with values
	     * @static
	     * @memberOf fabric
	     * @param {SVGElement} element Element to parse
	     * @return {Object} Objects with values parsed from style attribute of an element
	     */
	    parseStyleAttribute: function(element) {
	      var oStyle = { },
	          style = element.getAttribute('style');
	
	      if (!style) {
	        return oStyle;
	      }
	
	      if (typeof style === 'string') {
	        parseStyleString(style, oStyle);
	      }
	      else {
	        parseStyleObject(style, oStyle);
	      }
	
	      return oStyle;
	    },
	
	    /**
	     * Parses "points" attribute, returning an array of values
	     * @static
	     * @memberOf fabric
	     * @param {String} points points attribute string
	     * @return {Array} array of points
	     */
	    parsePointsAttribute: function(points) {
	
	      // points attribute is required and must not be empty
	      if (!points) {
	        return null;
	      }
	
	      // replace commas with whitespace and remove bookending whitespace
	      points = points.replace(/,/g, ' ').trim();
	
	      points = points.split(/\s+/);
	      var parsedPoints = [ ], i, len;
	
	      i = 0;
	      len = points.length;
	      for (; i < len; i+=2) {
	        parsedPoints.push({
	          x: parseFloat(points[i]),
	          y: parseFloat(points[i + 1])
	        });
	      }
	
	      // odd number of points is an error
	      // if (parsedPoints.length % 2 !== 0) {
	      //   return null;
	      // }
	
	      return parsedPoints;
	    },
	
	    /**
	     * Returns CSS rules for a given SVG document
	     * @static
	     * @function
	     * @memberOf fabric
	     * @param {SVGDocument} doc SVG document to parse
	     * @return {Object} CSS rules of this document
	     */
	    getCSSRules: function(doc) {
	      var styles = doc.getElementsByTagName('style'),
	          allRules = { }, rules;
	
	      // very crude parsing of style contents
	      for (var i = 0, len = styles.length; i < len; i++) {
	        var styleContents = styles[i].textContent;
	
	        // remove comments
	        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
	        if (styleContents.trim() === '') {
	          continue;
	        }
	        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
	        rules = rules.map(function(rule) { return rule.trim(); });
	
	        rules.forEach(function(rule) {
	
	          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
	          ruleObj = { }, declaration = match[2].trim(),
	          propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);
	
	          for (var i = 0, len = propertyValuePairs.length; i < len; i++) {
	            var pair = propertyValuePairs[i].split(/\s*:\s*/),
	                property = normalizeAttr(pair[0]),
	                value = normalizeValue(property, pair[1], pair[0]);
	            ruleObj[property] = value;
	          }
	          rule = match[1];
	          rule.split(',').forEach(function(_rule) {
	            _rule = _rule.replace(/^svg/i, '').trim();
	            if (_rule === '') {
	              return;
	            }
	            allRules[_rule] = fabric.util.object.clone(ruleObj);
	          });
	        });
	      }
	      return allRules;
	    },
	
	    /**
	     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects. Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
	     * @memberOf fabric
	     * @param {String} url
	     * @param {Function} callback
	     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	     */
	    loadSVGFromURL: function(url, callback, reviver) {
	
	      url = url.replace(/^\n\s*/, '').trim();
	      svgCache.has(url, function (hasUrl) {
	        if (hasUrl) {
	          svgCache.get(url, function (value) {
	            var enlivedRecord = _enlivenCachedObject(value);
	            callback(enlivedRecord.objects, enlivedRecord.options);
	          });
	        }
	        else {
	          new fabric.util.request(url, {
	            method: 'get',
	            onComplete: onComplete
	          });
	        }
	      });
	
	      function onComplete(r) {
	
	        var xml = r.responseXML;
	        if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {
	          xml = new ActiveXObject('Microsoft.XMLDOM');
	          xml.async = 'false';
	          //IE chokes on DOCTYPE
	          xml.loadXML(r.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
	        }
	        if (!xml || !xml.documentElement) {
	          return;
	        }
	
	        fabric.parseSVGDocument(xml.documentElement, function (results, options) {
	          svgCache.set(url, {
	            objects: fabric.util.array.invoke(results, 'toObject'),
	            options: options
	          });
	          callback(results, options);
	        }, reviver);
	      }
	    },
	
	    /**
	     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
	     * @memberOf fabric
	     * @param {String} string
	     * @param {Function} callback
	     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
	     */
	    loadSVGFromString: function(string, callback, reviver) {
	      string = string.trim();
	      var doc;
	      if (typeof DOMParser !== 'undefined') {
	        var parser = new DOMParser();
	        if (parser && parser.parseFromString) {
	          doc = parser.parseFromString(string, 'text/xml');
	        }
	      }
	      else if (fabric.window.ActiveXObject) {
	        doc = new ActiveXObject('Microsoft.XMLDOM');
	        doc.async = 'false';
	        // IE chokes on DOCTYPE
	        doc.loadXML(string.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
	      }
	
	      fabric.parseSVGDocument(doc.documentElement, function (results, options) {
	        callback(results, options);
	      }, reviver);
	    },
	
	    /**
	     * Creates markup containing SVG font faces
	     * @param {Array} objects Array of fabric objects
	     * @return {String}
	     */
	    createSVGFontFacesMarkup: function(objects) {
	      var markup = '';
	
	      for (var i = 0, len = objects.length; i < len; i++) {
	        if (objects[i].type !== 'text' || !objects[i].path) {
	          continue;
	        }
	
	        markup += [
	          //jscs:disable validateIndentation
	          '@font-face {',
	            'font-family: ', objects[i].fontFamily, '; ',
	            'src: url(\'', objects[i].path, '\')',
	          '}'
	          //jscs:enable validateIndentation
	        ].join('');
	      }
	
	      if (markup) {
	        markup = [
	          //jscs:disable validateIndentation
	          '<style type="text/css">',
	            '<![CDATA[',
	              markup,
	            ']]>',
	          '</style>'
	          //jscs:enable validateIndentation
	        ].join('');
	      }
	
	      return markup;
	    },
	
	    /**
	     * Creates markup containing SVG referenced elements like patterns, gradients etc.
	     * @param {fabric.Canvas} canvas instance of fabric.Canvas
	     * @return {String}
	     */
	    createSVGRefElementsMarkup: function(canvas) {
	      var markup = [ ];
	
	      _createSVGPattern(markup, canvas, 'backgroundColor');
	      _createSVGPattern(markup, canvas, 'overlayColor');
	
	      return markup.join('');
	    }
	  });
	
	})( true ? exports : this);
	
	
	fabric.ElementsParser = function(elements, callback, options, reviver) {
	  this.elements = elements;
	  this.callback = callback;
	  this.options = options;
	  this.reviver = reviver;
	  this.svgUid = (options && options.svgUid) || 0;
	};
	
	fabric.ElementsParser.prototype.parse = function() {
	  this.instances = new Array(this.elements.length);
	  this.numElements = this.elements.length;
	
	  this.createObjects();
	};
	
	fabric.ElementsParser.prototype.createObjects = function() {
	  for (var i = 0, len = this.elements.length; i < len; i++) {
	    this.elements[i].setAttribute('svgUid', this.svgUid);
	    (function(_this, i) {
	      setTimeout(function() {
	        _this.createObject(_this.elements[i], i);
	      }, 0);
	    })(this, i);
	  }
	};
	
	fabric.ElementsParser.prototype.createObject = function(el, index) {
	  var klass = fabric[fabric.util.string.capitalize(el.tagName)];
	  if (klass && klass.fromElement) {
	    try {
	      this._createObject(klass, el, index);
	    }
	    catch (err) {
	      fabric.log(err);
	    }
	  }
	  else {
	    this.checkIfDone();
	  }
	};
	
	fabric.ElementsParser.prototype._createObject = function(klass, el, index) {
	  if (klass.async) {
	    klass.fromElement(el, this.createCallback(index, el), this.options);
	  }
	  else {
	    var obj = klass.fromElement(el, this.options);
	    this.resolveGradient(obj, 'fill');
	    this.resolveGradient(obj, 'stroke');
	    this.reviver && this.reviver(el, obj);
	    this.instances[index] = obj;
	    this.checkIfDone();
	  }
	};
	
	fabric.ElementsParser.prototype.createCallback = function(index, el) {
	  var _this = this;
	  return function(obj) {
	    _this.resolveGradient(obj, 'fill');
	    _this.resolveGradient(obj, 'stroke');
	    _this.reviver && _this.reviver(el, obj);
	    _this.instances[index] = obj;
	    _this.checkIfDone();
	  };
	};
	
	fabric.ElementsParser.prototype.resolveGradient = function(obj, property) {
	
	  var instanceFillValue = obj.get(property);
	  if (!(/^url\(/).test(instanceFillValue)) {
	    return;
	  }
	  var gradientId = instanceFillValue.slice(5, instanceFillValue.length - 1);
	  if (fabric.gradientDefs[this.svgUid][gradientId]) {
	    obj.set(property,
	      fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][gradientId], obj));
	  }
	};
	
	fabric.ElementsParser.prototype.checkIfDone = function() {
	  if (--this.numElements === 0) {
	    this.instances = this.instances.filter(function(el) {
	      return el != null;
	    });
	    this.callback(this.instances);
	  }
	};
	
	
	(function(global) {
	
	  'use strict';
	
	  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Point) {
	    fabric.warn('fabric.Point is already defined');
	    return;
	  }
	
	  fabric.Point = Point;
	
	  /**
	   * Point class
	   * @class fabric.Point
	   * @memberOf fabric
	   * @constructor
	   * @param {Number} x
	   * @param {Number} y
	   * @return {fabric.Point} thisArg
	   */
	  function Point(x, y) {
	    this.x = x;
	    this.y = y;
	  }
	
	  Point.prototype = /** @lends fabric.Point.prototype */ {
	
	    constructor: Point,
	
	    /**
	     * Adds another point to this one and returns another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point} new Point instance with added values
	     */
	    add: function (that) {
	      return new Point(this.x + that.x, this.y + that.y);
	    },
	
	    /**
	     * Adds another point to this one
	     * @param {fabric.Point} that
	     * @return {fabric.Point} thisArg
	     */
	    addEquals: function (that) {
	      this.x += that.x;
	      this.y += that.y;
	      return this;
	    },
	
	    /**
	     * Adds value to this point and returns a new one
	     * @param {Number} scalar
	     * @return {fabric.Point} new Point with added value
	     */
	    scalarAdd: function (scalar) {
	      return new Point(this.x + scalar, this.y + scalar);
	    },
	
	    /**
	     * Adds value to this point
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     */
	    scalarAddEquals: function (scalar) {
	      this.x += scalar;
	      this.y += scalar;
	      return this;
	    },
	
	    /**
	     * Subtracts another point from this point and returns a new one
	     * @param {fabric.Point} that
	     * @return {fabric.Point} new Point object with subtracted values
	     */
	    subtract: function (that) {
	      return new Point(this.x - that.x, this.y - that.y);
	    },
	
	    /**
	     * Subtracts another point from this point
	     * @param {fabric.Point} that
	     * @return {fabric.Point} thisArg
	     */
	    subtractEquals: function (that) {
	      this.x -= that.x;
	      this.y -= that.y;
	      return this;
	    },
	
	    /**
	     * Subtracts value from this point and returns a new one
	     * @param {Number} scalar
	     * @return {fabric.Point}
	     */
	    scalarSubtract: function (scalar) {
	      return new Point(this.x - scalar, this.y - scalar);
	    },
	
	    /**
	     * Subtracts value from this point
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     */
	    scalarSubtractEquals: function (scalar) {
	      this.x -= scalar;
	      this.y -= scalar;
	      return this;
	    },
	
	    /**
	     * Miltiplies this point by a value and returns a new one
	     * @param {Number} scalar
	     * @return {fabric.Point}
	     */
	    multiply: function (scalar) {
	      return new Point(this.x * scalar, this.y * scalar);
	    },
	
	    /**
	     * Miltiplies this point by a value
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     */
	    multiplyEquals: function (scalar) {
	      this.x *= scalar;
	      this.y *= scalar;
	      return this;
	    },
	
	    /**
	     * Divides this point by a value and returns a new one
	     * @param {Number} scalar
	     * @return {fabric.Point}
	     */
	    divide: function (scalar) {
	      return new Point(this.x / scalar, this.y / scalar);
	    },
	
	    /**
	     * Divides this point by a value
	     * @param {Number} scalar
	     * @return {fabric.Point} thisArg
	     */
	    divideEquals: function (scalar) {
	      this.x /= scalar;
	      this.y /= scalar;
	      return this;
	    },
	
	    /**
	     * Returns true if this point is equal to another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    eq: function (that) {
	      return (this.x === that.x && this.y === that.y);
	    },
	
	    /**
	     * Returns true if this point is less than another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    lt: function (that) {
	      return (this.x < that.x && this.y < that.y);
	    },
	
	    /**
	     * Returns true if this point is less than or equal to another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    lte: function (that) {
	      return (this.x <= that.x && this.y <= that.y);
	    },
	
	    /**
	
	     * Returns true if this point is greater another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    gt: function (that) {
	      return (this.x > that.x && this.y > that.y);
	    },
	
	    /**
	     * Returns true if this point is greater than or equal to another one
	     * @param {fabric.Point} that
	     * @return {Boolean}
	     */
	    gte: function (that) {
	      return (this.x >= that.x && this.y >= that.y);
	    },
	
	    /**
	     * Returns new point which is the result of linear interpolation with this one and another one
	     * @param {fabric.Point} that
	     * @param {Number} t
	     * @return {fabric.Point}
	     */
	    lerp: function (that, t) {
	      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
	    },
	
	    /**
	     * Returns distance from this point and another one
	     * @param {fabric.Point} that
	     * @return {Number}
	     */
	    distanceFrom: function (that) {
	      var dx = this.x - that.x,
	          dy = this.y - that.y;
	      return Math.sqrt(dx * dx + dy * dy);
	    },
	
	    /**
	     * Returns the point between this point and another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point}
	     */
	    midPointFrom: function (that) {
	      return new Point(this.x + (that.x - this.x)/2, this.y + (that.y - this.y)/2);
	    },
	
	    /**
	     * Returns a new point which is the min of this and another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point}
	     */
	    min: function (that) {
	      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
	    },
	
	    /**
	     * Returns a new point which is the max of this and another one
	     * @param {fabric.Point} that
	     * @return {fabric.Point}
	     */
	    max: function (that) {
	      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
	    },
	
	    /**
	     * Returns string representation of this point
	     * @return {String}
	     */
	    toString: function () {
	      return this.x + ',' + this.y;
	    },
	
	    /**
	     * Sets x/y of this point
	     * @param {Number} x
	     * @param {Number} y
	     */
	    setXY: function (x, y) {
	      this.x = x;
	      this.y = y;
	    },
	
	    /**
	     * Sets x/y of this point from another point
	     * @param {fabric.Point} that
	     */
	    setFromPoint: function (that) {
	      this.x = that.x;
	      this.y = that.y;
	    },
	
	    /**
	     * Swaps x/y of this point and another point
	     * @param {fabric.Point} that
	     */
	    swap: function (that) {
	      var x = this.x,
	          y = this.y;
	      this.x = that.x;
	      this.y = that.y;
	      that.x = x;
	      that.y = y;
	    }
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Intersection) {
	    fabric.warn('fabric.Intersection is already defined');
	    return;
	  }
	
	  /**
	   * Intersection class
	   * @class fabric.Intersection
	   * @memberOf fabric
	   * @constructor
	   */
	  function Intersection(status) {
	    this.status = status;
	    this.points = [];
	  }
	
	  fabric.Intersection = Intersection;
	
	  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {
	
	    /**
	     * Appends a point to intersection
	     * @param {fabric.Point} point
	     */
	    appendPoint: function (point) {
	      this.points.push(point);
	    },
	
	    /**
	     * Appends points to intersection
	     * @param {Array} points
	     */
	    appendPoints: function (points) {
	      this.points = this.points.concat(points);
	    }
	  };
	
	  /**
	   * Checks if one line intersects another
	   * @static
	   * @param {fabric.Point} a1
	   * @param {fabric.Point} a2
	   * @param {fabric.Point} b1
	   * @param {fabric.Point} b2
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
	    var result,
	        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
	        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
	        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
	    if (uB !== 0) {
	      var ua = uaT / uB,
	          ub = ubT / uB;
	      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
	        result = new Intersection('Intersection');
	        result.points.push(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
	      }
	      else {
	        result = new Intersection();
	      }
	    }
	    else {
	      if (uaT === 0 || ubT === 0) {
	        result = new Intersection('Coincident');
	      }
	      else {
	        result = new Intersection('Parallel');
	      }
	    }
	    return result;
	  };
	
	  /**
	   * Checks if line intersects polygon
	   * @static
	   * @param {fabric.Point} a1
	   * @param {fabric.Point} a2
	   * @param {Array} points
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
	    var result = new Intersection(),
	        length = points.length;
	
	    for (var i = 0; i < length; i++) {
	      var b1 = points[i],
	          b2 = points[(i + 1) % length],
	          inter = Intersection.intersectLineLine(a1, a2, b1, b2);
	
	      result.appendPoints(inter.points);
	    }
	    if (result.points.length > 0) {
	      result.status = 'Intersection';
	    }
	    return result;
	  };
	
	  /**
	   * Checks if polygon intersects another polygon
	   * @static
	   * @param {Array} points1
	   * @param {Array} points2
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
	    var result = new Intersection(),
	        length = points1.length;
	
	    for (var i = 0; i < length; i++) {
	      var a1 = points1[i],
	          a2 = points1[(i + 1) % length],
	          inter = Intersection.intersectLinePolygon(a1, a2, points2);
	
	      result.appendPoints(inter.points);
	    }
	    if (result.points.length > 0) {
	      result.status = 'Intersection';
	    }
	    return result;
	  };
	
	  /**
	   * Checks if polygon intersects rectangle
	   * @static
	   * @param {Array} points
	   * @param {Number} r1
	   * @param {Number} r2
	   * @return {fabric.Intersection}
	   */
	  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
	    var min = r1.min(r2),
	        max = r1.max(r2),
	        topRight = new fabric.Point(max.x, min.y),
	        bottomLeft = new fabric.Point(min.x, max.y),
	        inter1 = Intersection.intersectLinePolygon(min, topRight, points),
	        inter2 = Intersection.intersectLinePolygon(topRight, max, points),
	        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
	        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
	        result = new Intersection();
	
	    result.appendPoints(inter1.points);
	    result.appendPoints(inter2.points);
	    result.appendPoints(inter3.points);
	    result.appendPoints(inter4.points);
	
	    if (result.points.length > 0) {
	      result.status = 'Intersection';
	    }
	    return result;
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Color) {
	    fabric.warn('fabric.Color is already defined.');
	    return;
	  }
	
	  /**
	   * Color class
	   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
	   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
	   *
	   * @class fabric.Color
	   * @param {String} color optional in hex or rgb(a) format
	   * @return {fabric.Color} thisArg
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
	   */
	  function Color(color) {
	    if (!color) {
	      this.setSource([0, 0, 0, 1]);
	    }
	    else {
	      this._tryParsingColor(color);
	    }
	  }
	
	  fabric.Color = Color;
	
	  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {
	
	    /**
	     * @private
	     * @param {String|Array} color Color value to parse
	     */
	    _tryParsingColor: function(color) {
	      var source;
	
	      if (color in Color.colorNameMap) {
	        color = Color.colorNameMap[color];
	      }
	
	      if (color === 'transparent') {
	        this.setSource([255, 255, 255, 0]);
	        return;
	      }
	
	      source = Color.sourceFromHex(color);
	
	      if (!source) {
	        source = Color.sourceFromRgb(color);
	      }
	      if (!source) {
	        source = Color.sourceFromHsl(color);
	      }
	      if (source) {
	        this.setSource(source);
	      }
	    },
	
	    /**
	     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
	     * @private
	     * @param {Number} r Red color value
	     * @param {Number} g Green color value
	     * @param {Number} b Blue color value
	     * @return {Array} Hsl color
	     */
	    _rgbToHsl: function(r, g, b) {
	      r /= 255, g /= 255, b /= 255;
	
	      var h, s, l,
	          max = fabric.util.array.max([r, g, b]),
	          min = fabric.util.array.min([r, g, b]);
	
	      l = (max + min) / 2;
	
	      if (max === min) {
	        h = s = 0; // achromatic
	      }
	      else {
	        var d = max - min;
	        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
	        switch (max) {
	          case r:
	            h = (g - b) / d + (g < b ? 6 : 0);
	            break;
	          case g:
	            h = (b - r) / d + 2;
	            break;
	          case b:
	            h = (r - g) / d + 4;
	            break;
	        }
	        h /= 6;
	      }
	
	      return [
	        Math.round(h * 360),
	        Math.round(s * 100),
	        Math.round(l * 100)
	      ];
	    },
	
	    /**
	     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
	     * @return {Array}
	     */
	    getSource: function() {
	      return this._source;
	    },
	
	    /**
	     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
	     * @param {Array} source
	     */
	    setSource: function(source) {
	      this._source = source;
	    },
	
	    /**
	     * Returns color represenation in RGB format
	     * @return {String} ex: rgb(0-255,0-255,0-255)
	     */
	    toRgb: function() {
	      var source = this.getSource();
	      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
	    },
	
	    /**
	     * Returns color represenation in RGBA format
	     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
	     */
	    toRgba: function() {
	      var source = this.getSource();
	      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
	    },
	
	    /**
	     * Returns color represenation in HSL format
	     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
	     */
	    toHsl: function() {
	      var source = this.getSource(),
	          hsl = this._rgbToHsl(source[0], source[1], source[2]);
	
	      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
	    },
	
	    /**
	     * Returns color represenation in HSLA format
	     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
	     */
	    toHsla: function() {
	      var source = this.getSource(),
	          hsl = this._rgbToHsl(source[0], source[1], source[2]);
	
	      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
	    },
	
	    /**
	     * Returns color represenation in HEX format
	     * @return {String} ex: FF5555
	     */
	    toHex: function() {
	      var source = this.getSource(), r, g, b;
	
	      r = source[0].toString(16);
	      r = (r.length === 1) ? ('0' + r) : r;
	
	      g = source[1].toString(16);
	      g = (g.length === 1) ? ('0' + g) : g;
	
	      b = source[2].toString(16);
	      b = (b.length === 1) ? ('0' + b) : b;
	
	      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
	    },
	
	    /**
	     * Gets value of alpha channel for this color
	     * @return {Number} 0-1
	     */
	    getAlpha: function() {
	      return this.getSource()[3];
	    },
	
	    /**
	     * Sets value of alpha channel for this color
	     * @param {Number} alpha Alpha value 0-1
	     * @return {fabric.Color} thisArg
	     */
	    setAlpha: function(alpha) {
	      var source = this.getSource();
	      source[3] = alpha;
	      this.setSource(source);
	      return this;
	    },
	
	    /**
	     * Transforms color to its grayscale representation
	     * @return {fabric.Color} thisArg
	     */
	    toGrayscale: function() {
	      var source = this.getSource(),
	          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
	          currentAlpha = source[3];
	      this.setSource([average, average, average, currentAlpha]);
	      return this;
	    },
	
	    /**
	     * Transforms color to its black and white representation
	     * @param {Number} threshold
	     * @return {fabric.Color} thisArg
	     */
	    toBlackWhite: function(threshold) {
	      var source = this.getSource(),
	          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
	          currentAlpha = source[3];
	
	      threshold = threshold || 127;
	
	      average = (Number(average) < Number(threshold)) ? 0 : 255;
	      this.setSource([average, average, average, currentAlpha]);
	      return this;
	    },
	
	    /**
	     * Overlays color with another color
	     * @param {String|fabric.Color} otherColor
	     * @return {fabric.Color} thisArg
	     */
	    overlayWith: function(otherColor) {
	      if (!(otherColor instanceof Color)) {
	        otherColor = new Color(otherColor);
	      }
	
	      var result = [],
	          alpha = this.getAlpha(),
	          otherAlpha = 0.5,
	          source = this.getSource(),
	          otherSource = otherColor.getSource();
	
	      for (var i = 0; i < 3; i++) {
	        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
	      }
	
	      result[3] = alpha;
	      this.setSource(result);
	      return this;
	    }
	  };
	
	  /**
	   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   */
	  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/;
	
	  /**
	   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   */
	  fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/;
	
	  /**
	   * Regex matching color in HEX format (ex: #FF5555, 010155, aff)
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   */
	  fabric.Color.reHex = /^#?([0-9a-f]{6}|[0-9a-f]{3})$/i;
	
	  /**
	   * Map of the 17 basic color names with HEX code
	   * @static
	   * @field
	   * @memberOf fabric.Color
	   * @see: http://www.w3.org/TR/CSS2/syndata.html#color-units
	   */
	  fabric.Color.colorNameMap = {
	    aqua:    '#00FFFF',
	    black:   '#000000',
	    blue:    '#0000FF',
	    fuchsia: '#FF00FF',
	    gray:    '#808080',
	    green:   '#008000',
	    lime:    '#00FF00',
	    maroon:  '#800000',
	    navy:    '#000080',
	    olive:   '#808000',
	    orange:  '#FFA500',
	    purple:  '#800080',
	    red:     '#FF0000',
	    silver:  '#C0C0C0',
	    teal:    '#008080',
	    white:   '#FFFFFF',
	    yellow:  '#FFFF00'
	  };
	
	  /**
	   * @private
	   * @param {Number} p
	   * @param {Number} q
	   * @param {Number} t
	   * @return {Number}
	   */
	  function hue2rgb(p, q, t) {
	    if (t < 0) {
	      t += 1;
	    }
	    if (t > 1) {
	      t -= 1;
	    }
	    if (t < 1/6) {
	      return p + (q - p) * 6 * t;
	    }
	    if (t < 1/2) {
	      return q;
	    }
	    if (t < 2/3) {
	      return p + (q - p) * (2/3 - t) * 6;
	    }
	    return p;
	  }
	
	  /**
	   * Returns new color object, when given a color in RGB format
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromRgb = function(color) {
	    return Color.fromSource(Color.sourceFromRgb(color));
	  };
	
	  /**
	   * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
	   * @return {Array} source
	   */
	  fabric.Color.sourceFromRgb = function(color) {
	    var match = color.match(Color.reRGBa);
	    if (match) {
	      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
	          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
	          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);
	
	      return [
	        parseInt(r, 10),
	        parseInt(g, 10),
	        parseInt(b, 10),
	        match[4] ? parseFloat(match[4]) : 1
	      ];
	    }
	  };
	
	  /**
	   * Returns new color object, when given a color in RGBA format
	   * @static
	   * @function
	   * @memberOf fabric.Color
	   * @param {String} color
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromRgba = Color.fromRgb;
	
	  /**
	   * Returns new color object, when given a color in HSL format
	   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
	   * @memberOf fabric.Color
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromHsl = function(color) {
	    return Color.fromSource(Color.sourceFromHsl(color));
	  };
	
	  /**
	   * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
	   * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
	   * @return {Array} source
	   * @see http://http://www.w3.org/TR/css3-color/#hsl-color
	   */
	  fabric.Color.sourceFromHsl = function(color) {
	    var match = color.match(Color.reHSLa);
	    if (!match) {
	      return;
	    }
	
	    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
	        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
	        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
	        r, g, b;
	
	    if (s === 0) {
	      r = g = b = l;
	    }
	    else {
	      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
	          p = l * 2 - q;
	
	      r = hue2rgb(p, q, h + 1/3);
	      g = hue2rgb(p, q, h);
	      b = hue2rgb(p, q, h - 1/3);
	    }
	
	    return [
	      Math.round(r * 255),
	      Math.round(g * 255),
	      Math.round(b * 255),
	      match[4] ? parseFloat(match[4]) : 1
	    ];
	  };
	
	  /**
	   * Returns new color object, when given a color in HSLA format
	   * @static
	   * @function
	   * @memberOf fabric.Color
	   * @param {String} color
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromHsla = Color.fromHsl;
	
	  /**
	   * Returns new color object, when given a color in HEX format
	   * @static
	   * @memberOf fabric.Color
	   * @param {String} color Color value ex: FF5555
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromHex = function(color) {
	    return Color.fromSource(Color.sourceFromHex(color));
	  };
	
	  /**
	   * Returns array represenatation (ex: [100, 100, 200, 1]) of a color that's in HEX format
	   * @static
	   * @memberOf fabric.Color
	   * @param {String} color ex: FF5555
	   * @return {Array} source
	   */
	  fabric.Color.sourceFromHex = function(color) {
	    if (color.match(Color.reHex)) {
	      var value = color.slice(color.indexOf('#') + 1),
	          isShortNotation = (value.length === 3),
	          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
	          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
	          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6);
	
	      return [
	        parseInt(r, 16),
	        parseInt(g, 16),
	        parseInt(b, 16),
	        1
	      ];
	    }
	  };
	
	  /**
	   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
	   * @static
	   * @memberOf fabric.Color
	   * @param {Array} source
	   * @return {fabric.Color}
	   */
	  fabric.Color.fromSource = function(source) {
	    var oColor = new Color();
	    oColor.setSource(source);
	    return oColor;
	  };
	
	})( true ? exports : this);
	
	
	(function() {
	
	  /* _FROM_SVG_START_ */
	  function getColorStop(el) {
	    var style = el.getAttribute('style'),
	        offset = el.getAttribute('offset'),
	        color, colorAlpha, opacity;
	
	    // convert percents to absolute values
	    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
	    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
	    if (style) {
	      var keyValuePairs = style.split(/\s*;\s*/);
	
	      if (keyValuePairs[keyValuePairs.length - 1] === '') {
	        keyValuePairs.pop();
	      }
	
	      for (var i = keyValuePairs.length; i--; ) {
	
	        var split = keyValuePairs[i].split(/\s*:\s*/),
	            key = split[0].trim(),
	            value = split[1].trim();
	
	        if (key === 'stop-color') {
	          color = value;
	        }
	        else if (key === 'stop-opacity') {
	          opacity = value;
	        }
	      }
	    }
	
	    if (!color) {
	      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
	    }
	    if (!opacity) {
	      opacity = el.getAttribute('stop-opacity');
	    }
	
	    color = new fabric.Color(color);
	    colorAlpha = color.getAlpha();
	    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
	    opacity *= colorAlpha;
	
	    return {
	      offset: offset,
	      color: color.toRgb(),
	      opacity: opacity
	    };
	  }
	
	  function getLinearCoords(el) {
	    return {
	      x1: el.getAttribute('x1') || 0,
	      y1: el.getAttribute('y1') || 0,
	      x2: el.getAttribute('x2') || '100%',
	      y2: el.getAttribute('y2') || 0
	    };
	  }
	
	  function getRadialCoords(el) {
	    return {
	      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
	      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
	      r1: 0,
	      x2: el.getAttribute('cx') || '50%',
	      y2: el.getAttribute('cy') || '50%',
	      r2: el.getAttribute('r') || '50%'
	    };
	  }
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Gradient class
	   * @class fabric.Gradient
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#gradients}
	   * @see {@link fabric.Gradient#initialize} for constructor definition
	   */
	  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {
	
	    /**
	     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
	     * @type Number
	     * @default 0
	     */
	    offsetX: 0,
	
	    /**
	     * Vertical offset for aligning gradients coming from SVG when outside pathgroups
	     * @type Number
	     * @default 0
	     */
	    offsetY: 0,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops
	     * @return {fabric.Gradient} thisArg
	     */
	    initialize: function(options) {
	      options || (options = { });
	
	      var coords = { };
	
	      this.id = fabric.Object.__uid++;
	      this.type = options.type || 'linear';
	
	      coords = {
	        x1: options.coords.x1 || 0,
	        y1: options.coords.y1 || 0,
	        x2: options.coords.x2 || 0,
	        y2: options.coords.y2 || 0
	      };
	
	      if (this.type === 'radial') {
	        coords.r1 = options.coords.r1 || 0;
	        coords.r2 = options.coords.r2 || 0;
	      }
	      this.coords = coords;
	      this.colorStops = options.colorStops.slice();
	      if (options.gradientTransform) {
	        this.gradientTransform = options.gradientTransform;
	      }
	      this.offsetX = options.offsetX || this.offsetX;
	      this.offsetY = options.offsetY || this.offsetY;
	    },
	
	    /**
	     * Adds another colorStop
	     * @param {Object} colorStop Object with offset and color
	     * @return {fabric.Gradient} thisArg
	     */
	    addColorStop: function(colorStop) {
	      for (var position in colorStop) {
	        var color = new fabric.Color(colorStop[position]);
	        this.colorStops.push({
	          offset: position,
	          color: color.toRgb(),
	          opacity: color.getAlpha()
	        });
	      }
	      return this;
	    },
	
	    /**
	     * Returns object representation of a gradient
	     * @return {Object}
	     */
	    toObject: function() {
	      return {
	        type: this.type,
	        coords: this.coords,
	        colorStops: this.colorStops,
	        offsetX: this.offsetX,
	        offsetY: this.offsetY
	      };
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an gradient
	     * @param {Object} object Object to create a gradient for
	     * @param {Boolean} normalize Whether coords should be normalized
	     * @return {String} SVG representation of an gradient (linear/radial)
	     */
	    toSVG: function(object) {
	      var coords = fabric.util.object.clone(this.coords),
	          markup, commonAttributes;
	
	      // colorStops must be sorted ascending
	      this.colorStops.sort(function(a, b) {
	        return a.offset - b.offset;
	      });
	
	      if (!(object.group && object.group.type === 'path-group')) {
	        for (var prop in coords) {
	          if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
	            coords[prop] += this.offsetX - object.width / 2;
	          }
	          else if (prop === 'y1' || prop === 'y2') {
	            coords[prop] += this.offsetY - object.height / 2;
	          }
	        }
	      }
	
	      commonAttributes = 'id="SVGID_' + this.id +
	                     '" gradientUnits="userSpaceOnUse"';
	      if (this.gradientTransform) {
	        commonAttributes += ' gradientTransform="matrix(' + this.gradientTransform.join(' ') + ')" ';
	      }
	      if (this.type === 'linear') {
	        markup = [
	          //jscs:disable validateIndentation
	          '<linearGradient ',
	            commonAttributes,
	            ' x1="', coords.x1,
	            '" y1="', coords.y1,
	            '" x2="', coords.x2,
	            '" y2="', coords.y2,
	          '">\n'
	          //jscs:enable validateIndentation
	        ];
	      }
	      else if (this.type === 'radial') {
	        markup = [
	          //jscs:disable validateIndentation
	          '<radialGradient ',
	            commonAttributes,
	            ' cx="', coords.x2,
	            '" cy="', coords.y2,
	            '" r="', coords.r2,
	            '" fx="', coords.x1,
	            '" fy="', coords.y1,
	          '">\n'
	          //jscs:enable validateIndentation
	        ];
	      }
	
	      for (var i = 0; i < this.colorStops.length; i++) {
	        markup.push(
	          //jscs:disable validateIndentation
	          '<stop ',
	            'offset="', (this.colorStops[i].offset * 100) + '%',
	            '" style="stop-color:', this.colorStops[i].color,
	            (this.colorStops[i].opacity != null ? ';stop-opacity: ' + this.colorStops[i].opacity : ';'),
	          '"/>\n'
	          //jscs:enable validateIndentation
	        );
	      }
	
	      markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));
	
	      return markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns an instance of CanvasGradient
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @return {CanvasGradient}
	     */
	    toLive: function(ctx, object) {
	      var gradient, prop, coords = fabric.util.object.clone(this.coords);
	
	      if (!this.type) {
	        return;
	      }
	
	      if (object.group && object.group.type === 'path-group') {
	        for (prop in coords) {
	          if (prop === 'x1' || prop === 'x2') {
	            coords[prop] += -this.offsetX + object.width / 2;
	          }
	          else if (prop === 'y1' || prop === 'y2') {
	            coords[prop] += -this.offsetY + object.height / 2;
	          }
	        }
	      }
	
	      if (this.type === 'linear') {
	        gradient = ctx.createLinearGradient(
	          coords.x1, coords.y1, coords.x2, coords.y2);
	      }
	      else if (this.type === 'radial') {
	        gradient = ctx.createRadialGradient(
	          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);
	      }
	
	      for (var i = 0, len = this.colorStops.length; i < len; i++) {
	        var color = this.colorStops[i].color,
	            opacity = this.colorStops[i].opacity,
	            offset = this.colorStops[i].offset;
	
	        if (typeof opacity !== 'undefined') {
	          color = new fabric.Color(color).setAlpha(opacity).toRgba();
	        }
	        gradient.addColorStop(parseFloat(offset), color);
	      }
	
	      return gradient;
	    }
	  });
	
	  fabric.util.object.extend(fabric.Gradient, {
	
	    /* _FROM_SVG_START_ */
	    /**
	     * Returns {@link fabric.Gradient} instance from an SVG element
	     * @static
	     * @memberOf fabric.Gradient
	     * @param {SVGGradientElement} el SVG gradient element
	     * @param {fabric.Object} instance
	     * @return {fabric.Gradient} Gradient instance
	     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
	     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
	     */
	    fromElement: function(el, instance) {
	
	      /**
	       *  @example:
	       *
	       *  <linearGradient id="linearGrad1">
	       *    <stop offset="0%" stop-color="white"/>
	       *    <stop offset="100%" stop-color="black"/>
	       *  </linearGradient>
	       *
	       *  OR
	       *
	       *  <linearGradient id="linearGrad2">
	       *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
	       *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
	       *  </linearGradient>
	       *
	       *  OR
	       *
	       *  <radialGradient id="radialGrad1">
	       *    <stop offset="0%" stop-color="white" stop-opacity="1" />
	       *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
	       *    <stop offset="100%" stop-color="white" stop-opacity="1" />
	       *  </radialGradient>
	       *
	       *  OR
	       *
	       *  <radialGradient id="radialGrad2">
	       *    <stop offset="0" stop-color="rgb(255,255,255)" />
	       *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
	       *    <stop offset="1" stop-color="rgb(255,255,255)" />
	       *  </radialGradient>
	       *
	       */
	
	      var colorStopEls = el.getElementsByTagName('stop'),
	          type = (el.nodeName === 'linearGradient' ? 'linear' : 'radial'),
	          gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',
	          gradientTransform = el.getAttribute('gradientTransform'),
	          colorStops = [],
	          coords = { }, ellipseMatrix;
	
	      if (type === 'linear') {
	        coords = getLinearCoords(el);
	      }
	      else if (type === 'radial') {
	        coords = getRadialCoords(el);
	      }
	
	      for (var i = colorStopEls.length; i--; ) {
	        colorStops.push(getColorStop(colorStopEls[i]));
	      }
	
	      ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);
	
	      var gradient = new fabric.Gradient({
	        type: type,
	        coords: coords,
	        colorStops: colorStops,
	        offsetX: -instance.left,
	        offsetY: -instance.top
	      });
	
	      if (gradientTransform || ellipseMatrix !== '') {
	        gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);
	      }
	      return gradient;
	    },
	    /* _FROM_SVG_END_ */
	
	    /**
	     * Returns {@link fabric.Gradient} instance from its object representation
	     * @static
	     * @memberOf fabric.Gradient
	     * @param {Object} obj
	     * @param {Object} [options] Options object
	     */
	    forObject: function(obj, options) {
	      options || (options = { });
	      _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');
	      return new fabric.Gradient(options);
	    }
	  });
	
	  /**
	   * @private
	   */
	  function _convertPercentUnitsToValues(object, options, gradientUnits) {
	    var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';
	    for (var prop in options) {
	      propValue = parseFloat(options[prop], 10);
	      if (typeof options[prop] === 'string' && /^\d+%$/.test(options[prop])) {
	        multFactor = 0.01;
	      }
	      else {
	        multFactor = 1;
	      }
	      if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
	        multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;
	        addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;
	      }
	      else if (prop === 'y1' || prop === 'y2') {
	        multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;
	        addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;
	      }
	      options[prop] = propValue * multFactor + addFactor;
	    }
	    if (object.type === 'ellipse' &&
	        options.r2 !== null &&
	        gradientUnits === 'objectBoundingBox' &&
	        object.rx !== object.ry) {
	
	      var scaleFactor = object.ry/object.rx;
	      ellipseMatrix = ' scale(1, ' + scaleFactor + ')';
	      if (options.y1) {
	        options.y1 /= scaleFactor;
	      }
	      if (options.y2) {
	        options.y2 /= scaleFactor;
	      }
	    }
	    return ellipseMatrix;
	  }
	})();
	
	
	/**
	 * Pattern class
	 * @class fabric.Pattern
	 * @see {@link http://fabricjs.com/patterns/|Pattern demo}
	 * @see {@link http://fabricjs.com/dynamic-patterns/|DynamicPattern demo}
	 * @see {@link fabric.Pattern#initialize} for constructor definition
	 */
	fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {
	
	  /**
	   * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
	   * @type String
	   * @default
	   */
	  repeat: 'repeat',
	
	  /**
	   * Pattern horizontal offset from object's left/top corner
	   * @type Number
	   * @default
	   */
	  offsetX: 0,
	
	  /**
	   * Pattern vertical offset from object's left/top corner
	   * @type Number
	   * @default
	   */
	  offsetY: 0,
	
	  /**
	   * Constructor
	   * @param {Object} [options] Options object
	   * @return {fabric.Pattern} thisArg
	   */
	  initialize: function(options) {
	    options || (options = { });
	
	    this.id = fabric.Object.__uid++;
	
	    if (options.source) {
	      if (typeof options.source === 'string') {
	        // function string
	        if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {
	          this.source = new Function(fabric.util.getFunctionBody(options.source));
	        }
	        else {
	          // img src string
	          var _this = this;
	          this.source = fabric.util.createImage();
	          fabric.util.loadImage(options.source, function(img) {
	            _this.source = img;
	          });
	        }
	      }
	      else {
	        // img element
	        this.source = options.source;
	      }
	    }
	    if (options.repeat) {
	      this.repeat = options.repeat;
	    }
	    if (options.offsetX) {
	      this.offsetX = options.offsetX;
	    }
	    if (options.offsetY) {
	      this.offsetY = options.offsetY;
	    }
	  },
	
	  /**
	   * Returns object representation of a pattern
	   * @return {Object} Object representation of a pattern instance
	   */
	  toObject: function() {
	
	    var source;
	
	    // callback
	    if (typeof this.source === 'function') {
	      source = String(this.source);
	    }
	    // <img> element
	    else if (typeof this.source.src === 'string') {
	      source = this.source.src;
	    }
	    // <canvas> element
	    else if (typeof this.source === 'object' && this.source.toDataURL) {
	      source = this.source.toDataURL();
	    }
	
	    return {
	      source: source,
	      repeat: this.repeat,
	      offsetX: this.offsetX,
	      offsetY: this.offsetY
	    };
	  },
	
	  /* _TO_SVG_START_ */
	  /**
	   * Returns SVG representation of a pattern
	   * @param {fabric.Object} object
	   * @return {String} SVG representation of a pattern
	   */
	  toSVG: function(object) {
	    var patternSource = typeof this.source === 'function' ? this.source() : this.source,
	        patternWidth = patternSource.width / object.getWidth(),
	        patternHeight = patternSource.height / object.getHeight(),
	        patternOffsetX = this.offsetX / object.getWidth(),
	        patternOffsetY = this.offsetY / object.getHeight(),
	        patternImgSrc = '';
	    if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
	      patternHeight = 1;
	    }
	    if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
	      patternWidth = 1;
	    }
	    if (patternSource.src) {
	      patternImgSrc = patternSource.src;
	    }
	    else if (patternSource.toDataURL) {
	      patternImgSrc = patternSource.toDataURL();
	    }
	
	    return '<pattern id="SVGID_' + this.id +
	                  '" x="' + patternOffsetX +
	                  '" y="' + patternOffsetY +
	                  '" width="' + patternWidth +
	                  '" height="' + patternHeight + '">\n' +
	             '<image x="0" y="0"' +
	                    ' width="' + patternSource.width +
	                    '" height="' + patternSource.height +
	                    '" xlink:href="' + patternImgSrc +
	             '"></image>\n' +
	           '</pattern>\n';
	  },
	  /* _TO_SVG_END_ */
	
	  /**
	   * Returns an instance of CanvasPattern
	   * @param {CanvasRenderingContext2D} ctx Context to create pattern
	   * @return {CanvasPattern}
	   */
	  toLive: function(ctx) {
	    var source = typeof this.source === 'function'
	      ? this.source()
	      : this.source;
	
	    // if the image failed to load, return, and allow rest to continue loading
	    if (!source) {
	      return '';
	    }
	
	    // if an image
	    if (typeof source.src !== 'undefined') {
	      if (!source.complete) {
	        return '';
	      }
	      if (source.naturalWidth === 0 || source.naturalHeight === 0) {
	        return '';
	      }
	    }
	    return ctx.createPattern(source, this.repeat);
	  }
	});
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      toFixed = fabric.util.toFixed;
	
	  if (fabric.Shadow) {
	    fabric.warn('fabric.Shadow is already defined.');
	    return;
	  }
	
	  /**
	   * Shadow class
	   * @class fabric.Shadow
	   * @see {@link http://fabricjs.com/shadows/|Shadow demo}
	   * @see {@link fabric.Shadow#initialize} for constructor definition
	   */
	  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {
	
	    /**
	     * Shadow color
	     * @type String
	     * @default
	     */
	    color: 'rgb(0,0,0)',
	
	    /**
	     * Shadow blur
	     * @type Number
	     */
	    blur: 0,
	
	    /**
	     * Shadow horizontal offset
	     * @type Number
	     * @default
	     */
	    offsetX: 0,
	
	    /**
	     * Shadow vertical offset
	     * @type Number
	     * @default
	     */
	    offsetY: 0,
	
	    /**
	     * Whether the shadow should affect stroke operations
	     * @type Boolean
	     * @default
	     */
	    affectStroke: false,
	
	    /**
	     * Indicates whether toObject should include default values
	     * @type Boolean
	     * @default
	     */
	    includeDefaultValues: true,
	
	    /**
	     * Constructor
	     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetX properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px, "2px 2px 10px rgba(0,0,0,0.2)")
	     * @return {fabric.Shadow} thisArg
	     */
	    initialize: function(options) {
	
	      if (typeof options === 'string') {
	        options = this._parseShadow(options);
	      }
	
	      for (var prop in options) {
	        this[prop] = options[prop];
	      }
	
	      this.id = fabric.Object.__uid++;
	    },
	
	    /**
	     * @private
	     * @param {String} shadow Shadow value to parse
	     * @return {Object} Shadow object with color, offsetX, offsetY and blur
	     */
	    _parseShadow: function(shadow) {
	      var shadowStr = shadow.trim(),
	          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [ ],
	          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';
	
	      return {
	        color: color.trim(),
	        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
	        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
	        blur: parseInt(offsetsAndBlur[3], 10) || 0
	      };
	    },
	
	    /**
	     * Returns a string representation of an instance
	     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
	     * @return {String} Returns CSS3 text-shadow declaration
	     */
	    toString: function() {
	      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of a shadow
	     * @param {fabric.Object} object
	     * @return {String} SVG representation of a shadow
	     */
	    toSVG: function(object) {
	      var fBoxX = 40, fBoxY = 40;
	
	      if (object.width && object.height) {
	        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
	        // we add some extra space to filter box to contain the blur ( 20 )
	        fBoxX = toFixed((Math.abs(this.offsetX) + this.blur) / object.width, 2) * 100 + 20;
	        fBoxY = toFixed((Math.abs(this.offsetY) + this.blur) / object.height, 2) * 100 + 20;
	      }
	
	      return (
	        '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
	          'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
	          '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
	            toFixed(this.blur ? this.blur / 2 : 0, 3) + '"></feGaussianBlur>\n' +
	          '\t<feOffset dx="' + this.offsetX + '" dy="' + this.offsetY + '" result="oBlur" ></feOffset>\n' +
	          '\t<feFlood flood-color="' + this.color + '"/>\n' +
	          '\t<feComposite in2="oBlur" operator="in" />\n' +
	          '\t<feMerge>\n' +
	            '\t\t<feMergeNode></feMergeNode>\n' +
	            '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
	          '\t</feMerge>\n' +
	        '</filter>\n');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns object representation of a shadow
	     * @return {Object} Object representation of a shadow instance
	     */
	    toObject: function() {
	      if (this.includeDefaultValues) {
	        return {
	          color: this.color,
	          blur: this.blur,
	          offsetX: this.offsetX,
	          offsetY: this.offsetY
	        };
	      }
	      var obj = { }, proto = fabric.Shadow.prototype;
	      if (this.color !== proto.color) {
	        obj.color = this.color;
	      }
	      if (this.blur !== proto.blur) {
	        obj.blur = this.blur;
	      }
	      if (this.offsetX !== proto.offsetX) {
	        obj.offsetX = this.offsetX;
	      }
	      if (this.offsetY !== proto.offsetY) {
	        obj.offsetY = this.offsetY;
	      }
	      return obj;
	    }
	  });
	
	  /**
	   * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
	   * @static
	   * @field
	   * @memberOf fabric.Shadow
	   */
	  fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;
	
	})( true ? exports : this);
	
	
	(function () {
	
	  'use strict';
	
	  if (fabric.StaticCanvas) {
	    fabric.warn('fabric.StaticCanvas is already defined.');
	    return;
	  }
	
	  // aliases for faster resolution
	  var extend = fabric.util.object.extend,
	      getElementOffset = fabric.util.getElementOffset,
	      removeFromArray = fabric.util.removeFromArray,
	
	      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');
	
	  /**
	   * Static canvas class
	   * @class fabric.StaticCanvas
	   * @mixes fabric.Collection
	   * @mixes fabric.Observable
	   * @see {@link http://fabricjs.com/static_canvas/|StaticCanvas demo}
	   * @see {@link fabric.StaticCanvas#initialize} for constructor definition
	   * @fires before:render
	   * @fires after:render
	   * @fires canvas:cleared
	   * @fires object:added
	   * @fires object:removed
	   */
	  fabric.StaticCanvas = fabric.util.createClass(/** @lends fabric.StaticCanvas.prototype */ {
	
	    /**
	     * Constructor
	     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(el, options) {
	      options || (options = { });
	
	      this._initStatic(el, options);
	      fabric.StaticCanvas.activeInstance = this;
	    },
	
	    /**
	     * Background color of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
	     * @type {(String|fabric.Pattern)}
	     * @default
	     */
	    backgroundColor: '',
	
	    /**
	     * Background image of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.
	     * <b>Backwards incompatibility note:</b> The "backgroundImageOpacity"
	     * and "backgroundImageStretch" properties are deprecated since 1.3.9.
	     * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.
	     * @type fabric.Image
	     * @default
	     */
	    backgroundImage: null,
	
	    /**
	     * Overlay color of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
	     * @since 1.3.9
	     * @type {(String|fabric.Pattern)}
	     * @default
	     */
	    overlayColor: '',
	
	    /**
	     * Overlay image of canvas instance.
	     * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.
	     * <b>Backwards incompatibility note:</b> The "overlayImageLeft"
	     * and "overlayImageTop" properties are deprecated since 1.3.9.
	     * Use {@link fabric.Image#left} and {@link fabric.Image#top}.
	     * @type fabric.Image
	     * @default
	     */
	    overlayImage: null,
	
	    /**
	     * Indicates whether toObject/toDatalessObject should include default values
	     * @type Boolean
	     * @default
	     */
	    includeDefaultValues: true,
	
	    /**
	     * Indicates whether objects' state should be saved
	     * @type Boolean
	     * @default
	     */
	    stateful: true,
	
	    /**
	     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove} should also re-render canvas.
	     * Disabling this option could give a great performance boost when adding/removing a lot of objects to/from canvas at once
	     * (followed by a manual rendering after addition/deletion)
	     * @type Boolean
	     * @default
	     */
	    renderOnAddRemove: true,
	
	    /**
	     * Function that determines clipping of entire canvas area
	     * Being passed context as first argument. See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}
	     * @type Function
	     * @default
	     */
	    clipTo: null,
	
	    /**
	     * Indicates whether object controls (borders/controls) are rendered above overlay image
	     * @type Boolean
	     * @default
	     */
	    controlsAboveOverlay: false,
	
	    /**
	     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
	     * @type Boolean
	     * @default
	     */
	    allowTouchScrolling: false,
	
	    /**
	     * Indicates whether this canvas will use image smoothing, this is on by default in browsers
	     * @type Boolean
	     * @default
	     */
	    imageSmoothingEnabled: true,
	
	    /**
	     * Indicates whether objects should remain in current stack position when selected. When false objects are brought to top and rendered as part of the selection group
	     * @type Boolean
	     * @default
	     */
	    preserveObjectStacking: false,
	
	    /**
	     * The transformation (in the format of Canvas transform) which focuses the viewport
	     * @type Array
	     * @default
	     */
	    viewportTransform: [1, 0, 0, 1, 0, 0],
	
	    /**
	     * Callback; invoked right before object is about to be scaled/rotated
	     */
	    onBeforeScaleRotate: function () {
	      /* NOOP */
	    },
	
	    /**
	     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
	     */
	    enableRetinaScaling: true,
	
	    /**
	     * @private
	     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
	     * @param {Object} [options] Options object
	     */
	    _initStatic: function(el, options) {
	      this._objects = [];
	
	      this._createLowerCanvas(el);
	      this._initOptions(options);
	      this._setImageSmoothing();
	
	      // only initialize retina scaling once
	      if (!this.interactive) {
	        this._initRetinaScaling();
	      }
	
	      if (options.overlayImage) {
	        this.setOverlayImage(options.overlayImage, this.renderAll.bind(this));
	      }
	      if (options.backgroundImage) {
	        this.setBackgroundImage(options.backgroundImage, this.renderAll.bind(this));
	      }
	      if (options.backgroundColor) {
	        this.setBackgroundColor(options.backgroundColor, this.renderAll.bind(this));
	      }
	      if (options.overlayColor) {
	        this.setOverlayColor(options.overlayColor, this.renderAll.bind(this));
	      }
	      this.calcOffset();
	    },
	
	    /**
	     * @private
	     */
	    _initRetinaScaling: function() {
	      if (fabric.devicePixelRatio === 1 || !this.enableRetinaScaling) {
	        return;
	      }
	
	      this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);
	      this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);
	
	      this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);
	    },
	
	    /**
	     * Calculates canvas element offset relative to the document
	     * This method is also attached as "resize" event handler of window
	     * @return {fabric.Canvas} instance
	     * @chainable
	     */
	    calcOffset: function () {
	      this._offset = getElementOffset(this.lowerCanvasEl);
	      return this;
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
	     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
	     * @param {Function} callback callback to invoke when image is loaded and set as an overlay
	     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
	     * @example <caption>Normal overlayImage with left/top = 0</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   // Needed to position overlayImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>overlayImage with different properties</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
	     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {
	     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
	     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
	     * });
	     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   width: canvas.width,
	     *   height: canvas.height,
	     *   // Needed to position overlayImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>overlayImage loaded from cross-origin</caption>
	     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top',
	     *   crossOrigin: 'anonymous'
	     * });
	     */
	    setOverlayImage: function (image, callback, options) {
	      return this.__setBgOverlayImage('overlayImage', image, callback, options);
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
	     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
	     * @param {Function} callback Callback to invoke when image is loaded and set as background
	     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/YH9yD/|jsFiddle demo}
	     * @example <caption>Normal backgroundImage with left/top = 0</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   // Needed to position backgroundImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>backgroundImage with different properties</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
	     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {
	     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
	     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
	     * });
	     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   width: canvas.width,
	     *   height: canvas.height,
	     *   // Needed to position backgroundImage at 0/0
	     *   originX: 'left',
	     *   originY: 'top'
	     * });
	     * @example <caption>backgroundImage loaded from cross-origin</caption>
	     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
	     *   opacity: 0.5,
	     *   angle: 45,
	     *   left: 400,
	     *   top: 400,
	     *   originX: 'left',
	     *   originY: 'top',
	     *   crossOrigin: 'anonymous'
	     * });
	     */
	    setBackgroundImage: function (image, callback, options) {
	      return this.__setBgOverlayImage('backgroundImage', image, callback, options);
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#overlayColor|background color} for this canvas
	     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set background color to
	     * @param {Function} callback Callback to invoke when background color is set
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
	     * @example <caption>Normal overlayColor - color value</caption>
	     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as overlayColor</caption>
	     * canvas.setOverlayColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
	     * }, canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
	     * canvas.setOverlayColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
	     *   repeat: 'repeat',
	     *   offsetX: 200,
	     *   offsetY: 100
	     * }, canvas.renderAll.bind(canvas));
	     */
	    setOverlayColor: function(overlayColor, callback) {
	      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
	    },
	
	    /**
	     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
	     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
	     * @param {Function} callback Callback to invoke when background color is set
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
	     * @example <caption>Normal backgroundColor - color value</caption>
	     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as backgroundColor</caption>
	     * canvas.setBackgroundColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
	     * }, canvas.renderAll.bind(canvas));
	     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
	     * canvas.setBackgroundColor({
	     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
	     *   repeat: 'repeat',
	     *   offsetX: 200,
	     *   offsetY: 100
	     * }, canvas.renderAll.bind(canvas));
	     */
	    setBackgroundColor: function(backgroundColor, callback) {
	      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
	    },
	
	    /**
	     * @private
	     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}
	     */
	    _setImageSmoothing: function() {
	      var ctx = this.getContext();
	
	      if (typeof ctx.imageSmoothingEnabled !== 'undefined') {
	        ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;
	        return;
	      }
	      ctx.webkitImageSmoothingEnabled = this.imageSmoothingEnabled;
	      ctx.mozImageSmoothingEnabled    = this.imageSmoothingEnabled;
	      ctx.msImageSmoothingEnabled     = this.imageSmoothingEnabled;
	      ctx.oImageSmoothingEnabled      = this.imageSmoothingEnabled;
	    },
	
	    /**
	     * @private
	     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
	     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
	     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
	     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay
	     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
	     */
	    __setBgOverlayImage: function(property, image, callback, options) {
	      if (typeof image === 'string') {
	        fabric.util.loadImage(image, function(img) {
	          this[property] = new fabric.Image(img, options);
	          callback && callback();
	        }, this, options && options.crossOrigin);
	      }
	      else {
	        options && image.setOptions(options);
	        this[property] = image;
	        callback && callback();
	      }
	
	      return this;
	    },
	
	    /**
	     * @private
	     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
	     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
	     * @param {(Object|String|null)} color Object with pattern information, color value or null
	     * @param {Function} [callback] Callback is invoked when color is set
	     */
	    __setBgOverlayColor: function(property, color, callback) {
	      if (color && color.source) {
	        var _this = this;
	        fabric.util.loadImage(color.source, function(img) {
	          _this[property] = new fabric.Pattern({
	            source: img,
	            repeat: color.repeat,
	            offsetX: color.offsetX,
	            offsetY: color.offsetY
	          });
	          callback && callback();
	        });
	      }
	      else {
	        this[property] = color;
	        callback && callback();
	      }
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _createCanvasElement: function() {
	      var element = fabric.document.createElement('canvas');
	      if (!element.style) {
	        element.style = { };
	      }
	      if (!element) {
	        throw CANVAS_INIT_ERROR;
	      }
	      this._initCanvasElement(element);
	      return element;
	    },
	
	    /**
	     * @private
	     * @param {HTMLElement} element
	     */
	    _initCanvasElement: function(element) {
	      fabric.util.createCanvasElement(element);
	
	      if (typeof element.getContext === 'undefined') {
	        throw CANVAS_INIT_ERROR;
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initOptions: function (options) {
	      for (var prop in options) {
	        this[prop] = options[prop];
	      }
	
	      this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;
	      this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;
	
	      if (!this.lowerCanvasEl.style) {
	        return;
	      }
	
	      this.lowerCanvasEl.width = this.width;
	      this.lowerCanvasEl.height = this.height;
	
	      this.lowerCanvasEl.style.width = this.width + 'px';
	      this.lowerCanvasEl.style.height = this.height + 'px';
	
	      this.viewportTransform = this.viewportTransform.slice();
	    },
	
	    /**
	     * Creates a bottom canvas
	     * @private
	     * @param {HTMLElement} [canvasEl]
	     */
	    _createLowerCanvas: function (canvasEl) {
	      this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
	      this._initCanvasElement(this.lowerCanvasEl);
	
	      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');
	
	      if (this.interactive) {
	        this._applyCanvasStyle(this.lowerCanvasEl);
	      }
	
	      this.contextContainer = this.lowerCanvasEl.getContext('2d');
	    },
	
	    /**
	     * Returns canvas width (in px)
	     * @return {Number}
	     */
	    getWidth: function () {
	      return this.width;
	    },
	
	    /**
	     * Returns canvas height (in px)
	     * @return {Number}
	     */
	    getHeight: function () {
	      return this.height;
	    },
	
	    /**
	     * Sets width of this canvas instance
	     * @param {Number|String} value                         Value to set width to
	     * @param {Object}        [options]                     Options object
	     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
	     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setWidth: function (value, options) {
	      return this.setDimensions({ width: value }, options);
	    },
	
	    /**
	     * Sets height of this canvas instance
	     * @param {Number|String} value                         Value to set height to
	     * @param {Object}        [options]                     Options object
	     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
	     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setHeight: function (value, options) {
	      return this.setDimensions({ height: value }, options);
	    },
	
	    /**
	     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
	     * @param {Object}        dimensions                    Object with width/height properties
	     * @param {Number|String} [dimensions.width]            Width of canvas element
	     * @param {Number|String} [dimensions.height]           Height of canvas element
	     * @param {Object}        [options]                     Options object
	     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
	     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    setDimensions: function (dimensions, options) {
	      var cssValue;
	
	      options = options || {};
	
	      for (var prop in dimensions) {
	        cssValue = dimensions[prop];
	
	        if (!options.cssOnly) {
	          this._setBackstoreDimension(prop, dimensions[prop]);
	          cssValue += 'px';
	        }
	
	        if (!options.backstoreOnly) {
	          this._setCssDimension(prop, cssValue);
	        }
	      }
	
	      this._setImageSmoothing();
	      this.calcOffset();
	
	      if (!options.cssOnly) {
	        this.renderAll();
	      }
	
	      return this;
	    },
	
	    /**
	     * Helper for setting width/height
	     * @private
	     * @param {String} prop property (width|height)
	     * @param {Number} value value to set property to
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    _setBackstoreDimension: function (prop, value) {
	      this.lowerCanvasEl[prop] = value;
	
	      if (this.upperCanvasEl) {
	        this.upperCanvasEl[prop] = value;
	      }
	
	      if (this.cacheCanvasEl) {
	        this.cacheCanvasEl[prop] = value;
	      }
	
	      this[prop] = value;
	
	      return this;
	    },
	
	    /**
	     * Helper for setting css width/height
	     * @private
	     * @param {String} prop property (width|height)
	     * @param {String} value value to set property to
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    _setCssDimension: function (prop, value) {
	      this.lowerCanvasEl.style[prop] = value;
	
	      if (this.upperCanvasEl) {
	        this.upperCanvasEl.style[prop] = value;
	      }
	
	      if (this.wrapperEl) {
	        this.wrapperEl.style[prop] = value;
	      }
	
	      return this;
	    },
	
	    /**
	     * Returns canvas zoom level
	     * @return {Number}
	     */
	    getZoom: function () {
	      return Math.sqrt(this.viewportTransform[0] * this.viewportTransform[3]);
	    },
	
	    /**
	     * Sets viewport transform of this canvas instance
	     * @param {Array} vpt the transform in the form of context.transform
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setViewportTransform: function (vpt) {
	      var activeGroup = this.getActiveGroup();
	      this.viewportTransform = vpt;
	      this.renderAll();
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        this._objects[i].setCoords();
	      }
	      if (activeGroup) {
	        activeGroup.setCoords();
	      }
	      return this;
	    },
	
	    /**
	     * Sets zoom level of this canvas instance, zoom centered around point
	     * @param {fabric.Point} point to zoom with respect to
	     * @param {Number} value to set zoom to, less than 1 zooms out
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    zoomToPoint: function (point, value) {
	      // TODO: just change the scale, preserve other transformations
	      var before = point;
	      point = fabric.util.transformPoint(point, fabric.util.invertTransform(this.viewportTransform));
	      this.viewportTransform[0] = value;
	      this.viewportTransform[3] = value;
	      var after = fabric.util.transformPoint(point, this.viewportTransform);
	      this.viewportTransform[4] += before.x - after.x;
	      this.viewportTransform[5] += before.y - after.y;
	      this.renderAll();
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        this._objects[i].setCoords();
	      }
	      return this;
	    },
	
	    /**
	     * Sets zoom level of this canvas instance
	     * @param {Number} value to set zoom to, less than 1 zooms out
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    setZoom: function (value) {
	      this.zoomToPoint(new fabric.Point(0, 0), value);
	      return this;
	    },
	
	    /**
	     * Pan viewport so as to place point at top left corner of canvas
	     * @param {fabric.Point} point to move to
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    absolutePan: function (point) {
	      this.viewportTransform[4] = -point.x;
	      this.viewportTransform[5] = -point.y;
	      this.renderAll();
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        this._objects[i].setCoords();
	      }
	      return this;
	    },
	
	    /**
	     * Pans viewpoint relatively
	     * @param {fabric.Point} point (position vector) to move by
	     * @return {fabric.Canvas} instance
	     * @chainable true
	     */
	    relativePan: function (point) {
	      return this.absolutePan(new fabric.Point(
	        -point.x - this.viewportTransform[4],
	        -point.y - this.viewportTransform[5]
	      ));
	    },
	
	    /**
	     * Returns &lt;canvas> element corresponding to this instance
	     * @return {HTMLCanvasElement}
	     */
	    getElement: function () {
	      return this.lowerCanvasEl;
	    },
	
	    /**
	     * Returns currently selected object, if any
	     * @return {fabric.Object}
	     */
	    getActiveObject: function() {
	      return null;
	    },
	
	    /**
	     * Returns currently selected group of object, if any
	     * @return {fabric.Group}
	     */
	    getActiveGroup: function() {
	      return null;
	    },
	
	    /**
	     * Given a context, renders an object on that context
	     * @param {CanvasRenderingContext2D} ctx Context to render object on
	     * @param {fabric.Object} object Object to render
	     * @private
	     */
	    _draw: function (ctx, object) {
	      if (!object) {
	        return;
	      }
	
	      ctx.save();
	      var v = this.viewportTransform;
	      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
	      if (this._shouldRenderObject(object)) {
	        object.render(ctx);
	      }
	      ctx.restore();
	      if (!this.controlsAboveOverlay) {
	        object._renderControls(ctx);
	      }
	    },
	
	    _shouldRenderObject: function(object) {
	      if (!object) {
	        return false;
	      }
	      return (object !== this.getActiveGroup() || !this.preserveObjectStacking);
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} obj Object that was added
	     */
	    _onObjectAdded: function(obj) {
	      this.stateful && obj.setupState();
	      obj._set('canvas', this);
	      obj.setCoords();
	      this.fire('object:added', { target: obj });
	      obj.fire('added');
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} obj Object that was removed
	     */
	    _onObjectRemoved: function(obj) {
	      // removing active object should fire "selection:cleared" events
	      if (this.getActiveObject() === obj) {
	        this.fire('before:selection:cleared', { target: obj });
	        this._discardActiveObject();
	        this.fire('selection:cleared');
	      }
	
	      this.fire('object:removed', { target: obj });
	      obj.fire('removed');
	    },
	
	    /**
	     * Clears specified context of canvas element
	     * @param {CanvasRenderingContext2D} ctx Context to clear
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    clearContext: function(ctx) {
	      ctx.clearRect(0, 0, this.width, this.height);
	      return this;
	    },
	
	    /**
	     * Returns context of canvas where objects are drawn
	     * @return {CanvasRenderingContext2D}
	     */
	    getContext: function () {
	      return this.contextContainer;
	    },
	
	    /**
	     * Clears all contexts (background, main, top) of an instance
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    clear: function () {
	      this._objects.length = 0;
	      if (this.discardActiveGroup) {
	        this.discardActiveGroup();
	      }
	      if (this.discardActiveObject) {
	        this.discardActiveObject();
	      }
	      this.clearContext(this.contextContainer);
	      if (this.contextTop) {
	        this.clearContext(this.contextTop);
	      }
	      this.fire('canvas:cleared');
	      this.renderAll();
	      return this;
	    },
	
	    /**
	     * Renders both the top canvas and the secondary container canvas.
	     * @param {Boolean} [allOnTop] Whether we want to force all images to be rendered on the top canvas
	     * @return {fabric.Canvas} instance
	     * @chainable
	     */
	    renderAll: function (allOnTop) {
	      var canvasToDrawOn = this[(allOnTop === true && this.interactive) ? 'contextTop' : 'contextContainer'],
	          activeGroup = this.getActiveGroup();
	
	      if (this.contextTop && this.selection && !this._groupSelector) {
	        this.clearContext(this.contextTop);
	      }
	
	      if (!allOnTop) {
	        this.clearContext(canvasToDrawOn);
	      }
	
	      this.fire('before:render');
	
	      if (this.clipTo) {
	        fabric.util.clipContext(this, canvasToDrawOn);
	      }
	
	      this._renderBackground(canvasToDrawOn);
	      this._renderObjects(canvasToDrawOn, activeGroup);
	      this._renderActiveGroup(canvasToDrawOn, activeGroup);
	
	      if (this.clipTo) {
	        canvasToDrawOn.restore();
	      }
	
	      this._renderOverlay(canvasToDrawOn);
	
	      if (this.controlsAboveOverlay && this.interactive) {
	        this.drawControls(canvasToDrawOn);
	      }
	
	      this.fire('after:render');
	
	      return this;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {fabric.Group} activeGroup
	     */
	    _renderObjects: function(ctx, activeGroup) {
	      var i, length;
	
	      // fast path
	      if (!activeGroup || this.preserveObjectStacking) {
	        for (i = 0, length = this._objects.length; i < length; ++i) {
	          this._draw(ctx, this._objects[i]);
	        }
	      }
	      else {
	        for (i = 0, length = this._objects.length; i < length; ++i) {
	          if (this._objects[i] && !activeGroup.contains(this._objects[i])) {
	            this._draw(ctx, this._objects[i]);
	          }
	        }
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {fabric.Group} activeGroup
	     */
	    _renderActiveGroup: function(ctx, activeGroup) {
	
	      // delegate rendering to group selection (if one exists)
	      if (activeGroup) {
	
	        //Store objects in group preserving order, then replace
	        var sortedObjects = [];
	        this.forEachObject(function (object) {
	          if (activeGroup.contains(object)) {
	            sortedObjects.push(object);
	          }
	        });
	        // forEachObject reverses the object, so we reverse again
	        activeGroup._set('_objects', sortedObjects.reverse());
	        this._draw(ctx, activeGroup);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderBackground: function(ctx) {
	      if (this.backgroundColor) {
	        ctx.fillStyle = this.backgroundColor.toLive
	          ? this.backgroundColor.toLive(ctx)
	          : this.backgroundColor;
	
	        ctx.fillRect(
	          this.backgroundColor.offsetX || 0,
	          this.backgroundColor.offsetY || 0,
	          this.width,
	          this.height);
	      }
	      if (this.backgroundImage) {
	        this._draw(ctx, this.backgroundImage);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderOverlay: function(ctx) {
	      if (this.overlayColor) {
	        ctx.fillStyle = this.overlayColor.toLive
	          ? this.overlayColor.toLive(ctx)
	          : this.overlayColor;
	
	        ctx.fillRect(
	          this.overlayColor.offsetX || 0,
	          this.overlayColor.offsetY || 0,
	          this.width,
	          this.height);
	      }
	      if (this.overlayImage) {
	        this._draw(ctx, this.overlayImage);
	      }
	    },
	
	    /**
	     * Method to render only the top canvas.
	     * Also used to render the group selection box.
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    renderTop: function () {
	      var ctx = this.contextTop || this.contextContainer;
	      this.clearContext(ctx);
	
	      // we render the top context - last object
	      if (this.selection && this._groupSelector) {
	        this._drawSelection();
	      }
	
	      // delegate rendering to group selection if one exists
	      // used for drawing selection borders/controls
	      var activeGroup = this.getActiveGroup();
	      if (activeGroup) {
	        activeGroup.render(ctx);
	      }
	
	      this._renderOverlay(ctx);
	
	      this.fire('after:render');
	
	      return this;
	    },
	
	    /**
	     * Returns coordinates of a center of canvas.
	     * Returned value is an object with top and left properties
	     * @return {Object} object with "top" and "left" number values
	     */
	    getCenter: function () {
	      return {
	        top: this.getHeight() / 2,
	        left: this.getWidth() / 2
	      };
	    },
	
	    /**
	     * Centers object horizontally.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center horizontally
	     * @return {fabric.Canvas} thisArg
	     */
	    centerObjectH: function (object) {
	      this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
	      this.renderAll();
	      return this;
	    },
	
	    /**
	     * Centers object vertically.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    centerObjectV: function (object) {
	      this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
	      this.renderAll();
	      return this;
	    },
	
	    /**
	     * Centers object vertically and horizontally.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @param {fabric.Object} object Object to center vertically and horizontally
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    centerObject: function(object) {
	      var center = this.getCenter();
	
	      this._centerObject(object, new fabric.Point(center.left, center.top));
	      this.renderAll();
	      return this;
	    },
	
	    /**
	     * @private
	     * @param {fabric.Object} object Object to center
	     * @param {fabric.Point} center Center point
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    _centerObject: function(object, center) {
	      object.setPositionByOrigin(center, 'center', 'center');
	      return this;
	    },
	
	    /**
	     * Returs dataless JSON representation of canvas
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {String} json string
	     */
	    toDatalessJSON: function (propertiesToInclude) {
	      return this.toDatalessObject(propertiesToInclude);
	    },
	
	    /**
	     * Returns object representation of canvas
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function (propertiesToInclude) {
	      return this._toObjectMethod('toObject', propertiesToInclude);
	    },
	
	    /**
	     * Returns dataless object representation of canvas
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toDatalessObject: function (propertiesToInclude) {
	      return this._toObjectMethod('toDatalessObject', propertiesToInclude);
	    },
	
	    /**
	     * @private
	     */
	    _toObjectMethod: function (methodName, propertiesToInclude) {
	
	      var data = {
	        objects: this._toObjects(methodName, propertiesToInclude)
	      };
	
	      extend(data, this.__serializeBgOverlay());
	
	      fabric.util.populateWithProperties(this, data, propertiesToInclude);
	
	      return data;
	    },
	
	    /**
	     * @private
	     */
	    _toObjects: function(methodName, propertiesToInclude) {
	      return this.getObjects().map(function(instance) {
	        return this._toObject(instance, methodName, propertiesToInclude);
	      }, this);
	    },
	
	    /**
	     * @private
	     */
	    _toObject: function(instance, methodName, propertiesToInclude) {
	      var originalValue;
	
	      if (!this.includeDefaultValues) {
	        originalValue = instance.includeDefaultValues;
	        instance.includeDefaultValues = false;
	      }
	
	      //If the object is part of the current selection group, it should
	      //be transformed appropriately
	      //i.e. it should be serialised as it would appear if the selection group
	      //were to be destroyed.
	      var originalProperties = this._realizeGroupTransformOnObject(instance),
	          object = instance[methodName](propertiesToInclude);
	      if (!this.includeDefaultValues) {
	        instance.includeDefaultValues = originalValue;
	      }
	
	      //Undo the damage we did by changing all of its properties
	      this._unwindGroupTransformOnObject(instance, originalProperties);
	
	      return object;
	    },
	
	    /**
	     * Realises an object's group transformation on it
	     * @private
	     * @param {fabric.Object} [instance] the object to transform (gets mutated)
	     * @returns the original values of instance which were changed
	     */
	    _realizeGroupTransformOnObject: function(instance) {
	      var layoutProps = ['angle', 'flipX', 'flipY', 'height', 'left', 'scaleX', 'scaleY', 'top', 'width'];
	      if (instance.group && instance.group === this.getActiveGroup()) {
	        //Copy all the positionally relevant properties across now
	        var originalValues = {};
	        layoutProps.forEach(function(prop) {
	          originalValues[prop] = instance[prop];
	        });
	        this.getActiveGroup().realizeTransform(instance);
	        return originalValues;
	      }
	      else {
	        return null;
	      }
	    },
	
	    /**
	     * Restores the changed properties of instance
	     * @private
	     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
	     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
	     */
	    _unwindGroupTransformOnObject: function(instance, originalValues) {
	      if (originalValues) {
	        instance.set(originalValues);
	      }
	    },
	
	    /**
	     * @private
	     */
	    __serializeBgOverlay: function() {
	      var data = {
	        background: (this.backgroundColor && this.backgroundColor.toObject)
	          ? this.backgroundColor.toObject()
	          : this.backgroundColor
	      };
	
	      if (this.overlayColor) {
	        data.overlay = this.overlayColor.toObject
	          ? this.overlayColor.toObject()
	          : this.overlayColor;
	      }
	      if (this.backgroundImage) {
	        data.backgroundImage = this.backgroundImage.toObject();
	      }
	      if (this.overlayImage) {
	        data.overlayImage = this.overlayImage.toObject();
	      }
	
	      return data;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
	     * a zoomed canvas will then produce zoomed SVG output.
	     * @type Boolean
	     * @default
	     */
	    svgViewportTransformation: true,
	
	    /**
	     * Returns SVG representation of canvas
	     * @function
	     * @param {Object} [options] Options object for SVG output
	     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
	     * @param {Object} [options.viewBox] SVG viewbox object
	     * @param {Number} [options.viewBox.x] x-cooridnate of viewbox
	     * @param {Number} [options.viewBox.y] y-coordinate of viewbox
	     * @param {Number} [options.viewBox.width] Width of viewbox
	     * @param {Number} [options.viewBox.height] Height of viewbox
	     * @param {String} [options.encoding=UTF-8] Encoding of SVG output
	     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
	     * @return {String} SVG string
	     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#serialization}
	     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
	     * @example <caption>Normal SVG output</caption>
	     * var svg = canvas.toSVG();
	     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
	     * var svg = canvas.toSVG({suppressPreamble: true});
	     * @example <caption>SVG output with viewBox attribute</caption>
	     * var svg = canvas.toSVG({
	     *   viewBox: {
	     *     x: 100,
	     *     y: 100,
	     *     width: 200,
	     *     height: 300
	     *   }
	     * });
	     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
	     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
	     * @example <caption>Modify SVG output with reviver function</caption>
	     * var svg = canvas.toSVG(null, function(svg) {
	     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
	     * });
	     */
	    toSVG: function(options, reviver) {
	      options || (options = { });
	
	      var markup = [];
	
	      this._setSVGPreamble(markup, options);
	      this._setSVGHeader(markup, options);
	
	      this._setSVGBgOverlayColor(markup, 'backgroundColor');
	      this._setSVGBgOverlayImage(markup, 'backgroundImage');
	
	      this._setSVGObjects(markup, reviver);
	
	      this._setSVGBgOverlayColor(markup, 'overlayColor');
	      this._setSVGBgOverlayImage(markup, 'overlayImage');
	
	      markup.push('</svg>');
	
	      return markup.join('');
	    },
	
	    /**
	     * @private
	     */
	    _setSVGPreamble: function(markup, options) {
	      if (!options.suppressPreamble) {
	        markup.push(
	          '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>',
	            '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
	              '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
	        );
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setSVGHeader: function(markup, options) {
	      var width, height, vpt;
	
	      if (options.viewBox) {
	        width = options.viewBox.width;
	        height = options.viewBox.height;
	      }
	      else {
	        width = this.width;
	        height = this.height;
	        if (!this.svgViewportTransformation) {
	          vpt = this.viewportTransform;
	          width /= vpt[0];
	          height /= vpt[3];
	        }
	      }
	
	      markup.push(
	        '<svg ',
	          'xmlns="http://www.w3.org/2000/svg" ',
	          'xmlns:xlink="http://www.w3.org/1999/xlink" ',
	          'version="1.1" ',
	          'width="', width, '" ',
	          'height="', height, '" ',
	          (this.backgroundColor && !this.backgroundColor.toLive
	            ? 'style="background-color: ' + this.backgroundColor + '" '
	            : null),
	          (options.viewBox
	              ? 'viewBox="' +
	                options.viewBox.x + ' ' +
	                options.viewBox.y + ' ' +
	                options.viewBox.width + ' ' +
	                options.viewBox.height + '" '
	              : null),
	          'xml:space="preserve">',
	        '<desc>Created with Fabric.js ', fabric.version, '</desc>',
	        '<defs>',
	          fabric.createSVGFontFacesMarkup(this.getObjects()),
	          fabric.createSVGRefElementsMarkup(this),
	        '</defs>'
	      );
	    },
	
	    /**
	     * @private
	     */
	    _setSVGObjects: function(markup, reviver) {
	      for (var i = 0, objects = this.getObjects(), len = objects.length; i < len; i++) {
	        var instance = objects[i],
	            //If the object is in a selection group, simulate what would happen to that
	            //object when the group is deselected
	            originalProperties = this._realizeGroupTransformOnObject(instance);
	        markup.push(instance.toSVG(reviver));
	        this._unwindGroupTransformOnObject(instance, originalProperties);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setSVGBgOverlayImage: function(markup, property) {
	      if (this[property] && this[property].toSVG) {
	        markup.push(this[property].toSVG());
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setSVGBgOverlayColor: function(markup, property) {
	      if (this[property] && this[property].source) {
	        markup.push(
	          '<rect x="', this[property].offsetX, '" y="', this[property].offsetY, '" ',
	            'width="',
	              (this[property].repeat === 'repeat-y' || this[property].repeat === 'no-repeat'
	                ? this[property].source.width
	                : this.width),
	            '" height="',
	              (this[property].repeat === 'repeat-x' || this[property].repeat === 'no-repeat'
	                ? this[property].source.height
	                : this.height),
	            '" fill="url(#' + property + 'Pattern)"',
	          '></rect>'
	        );
	      }
	      else if (this[property] && property === 'overlayColor') {
	        markup.push(
	          '<rect x="0" y="0" ',
	            'width="', this.width,
	            '" height="', this.height,
	            '" fill="', this[property], '"',
	          '></rect>'
	        );
	      }
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Moves an object to the bottom of the stack of drawn objects
	     * @param {fabric.Object} object Object to send to back
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    sendToBack: function (object) {
	      removeFromArray(this._objects, object);
	      this._objects.unshift(object);
	      return this.renderAll && this.renderAll();
	    },
	
	    /**
	     * Moves an object to the top of the stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    bringToFront: function (object) {
	      removeFromArray(this._objects, object);
	      this._objects.push(object);
	      return this.renderAll && this.renderAll();
	    },
	
	    /**
	     * Moves an object down in stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    sendBackwards: function (object, intersecting) {
	      var idx = this._objects.indexOf(object);
	
	      // if object is not on the bottom of stack
	      if (idx !== 0) {
	        var newIdx = this._findNewLowerIndex(object, idx, intersecting);
	
	        removeFromArray(this._objects, object);
	        this._objects.splice(newIdx, 0, object);
	        this.renderAll && this.renderAll();
	      }
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _findNewLowerIndex: function(object, idx, intersecting) {
	      var newIdx;
	
	      if (intersecting) {
	        newIdx = idx;
	
	        // traverse down the stack looking for the nearest intersecting object
	        for (var i = idx - 1; i >= 0; --i) {
	
	          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
	                               object.isContainedWithinObject(this._objects[i]) ||
	                               this._objects[i].isContainedWithinObject(object);
	
	          if (isIntersecting) {
	            newIdx = i;
	            break;
	          }
	        }
	      }
	      else {
	        newIdx = idx - 1;
	      }
	
	      return newIdx;
	    },
	
	    /**
	     * Moves an object up in stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    bringForward: function (object, intersecting) {
	      var idx = this._objects.indexOf(object);
	
	      // if object is not on top of stack (last item in an array)
	      if (idx !== this._objects.length - 1) {
	        var newIdx = this._findNewUpperIndex(object, idx, intersecting);
	
	        removeFromArray(this._objects, object);
	        this._objects.splice(newIdx, 0, object);
	        this.renderAll && this.renderAll();
	      }
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _findNewUpperIndex: function(object, idx, intersecting) {
	      var newIdx;
	
	      if (intersecting) {
	        newIdx = idx;
	
	        // traverse up the stack looking for the nearest intersecting object
	        for (var i = idx + 1; i < this._objects.length; ++i) {
	
	          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
	                               object.isContainedWithinObject(this._objects[i]) ||
	                               this._objects[i].isContainedWithinObject(object);
	
	          if (isIntersecting) {
	            newIdx = i;
	            break;
	          }
	        }
	      }
	      else {
	        newIdx = idx + 1;
	      }
	
	      return newIdx;
	    },
	
	    /**
	     * Moves an object to specified level in stack of drawn objects
	     * @param {fabric.Object} object Object to send
	     * @param {Number} index Position to move to
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    moveTo: function (object, index) {
	      removeFromArray(this._objects, object);
	      this._objects.splice(index, 0, object);
	      return this.renderAll && this.renderAll();
	    },
	
	    /**
	     * Clears a canvas element and removes all event listeners
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    dispose: function () {
	      this.clear();
	      this.interactive && this.removeListeners();
	      return this;
	    },
	
	    /**
	     * Returns a string representation of an instance
	     * @return {String} string representation of an instance
	     */
	    toString: function () {
	      return '#<fabric.Canvas (' + this.complexity() + '): ' +
	               '{ objects: ' + this.getObjects().length + ' }>';
	    }
	  });
	
	  extend(fabric.StaticCanvas.prototype, fabric.Observable);
	  extend(fabric.StaticCanvas.prototype, fabric.Collection);
	  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);
	
	  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {
	
	    /**
	     * @static
	     * @type String
	     * @default
	     */
	    EMPTY_JSON: '{"objects": [], "background": "white"}',
	
	    /**
	     * Provides a way to check support of some of the canvas methods
	     * (either those of HTMLCanvasElement itself, or rendering context)
	     *
	     * @param {String} methodName Method to check support for;
	     *                            Could be one of "getImageData", "toDataURL", "toDataURLWithQuality" or "setLineDash"
	     * @return {Boolean | null} `true` if method is supported (or at least exists),
	     *                          `null` if canvas element or context can not be initialized
	     */
	    supports: function (methodName) {
	      var el = fabric.util.createCanvasElement();
	
	      if (!el || !el.getContext) {
	        return null;
	      }
	
	      var ctx = el.getContext('2d');
	      if (!ctx) {
	        return null;
	      }
	
	      switch (methodName) {
	
	        case 'getImageData':
	          return typeof ctx.getImageData !== 'undefined';
	
	        case 'setLineDash':
	          return typeof ctx.setLineDash !== 'undefined';
	
	        case 'toDataURL':
	          return typeof el.toDataURL !== 'undefined';
	
	        case 'toDataURLWithQuality':
	          try {
	            el.toDataURL('image/jpeg', 0);
	            return true;
	          }
	          catch (e) { }
	          return false;
	
	        default:
	          return null;
	      }
	    }
	  });
	
	  /**
	   * Returns JSON representation of canvas
	   * @function
	   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	   * @return {String} JSON string
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#serialization}
	   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
	   * @example <caption>JSON without additional properties</caption>
	   * var json = canvas.toJSON();
	   * @example <caption>JSON with additional properties included</caption>
	   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);
	   * @example <caption>JSON without default values</caption>
	   * canvas.includeDefaultValues = false;
	   * var json = canvas.toJSON();
	   */
	  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;
	
	})();
	
	
	/**
	 * BaseBrush class
	 * @class fabric.BaseBrush
	 * @see {@link http://fabricjs.com/freedrawing/|Freedrawing demo}
	 */
	fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {
	
	  /**
	   * Color of a brush
	   * @type String
	   * @default
	   */
	  color:            'rgb(0, 0, 0)',
	
	  /**
	   * Width of a brush
	   * @type Number
	   * @default
	   */
	  width:            1,
	
	  /**
	   * Shadow object representing shadow of this shape.
	   * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
	   * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
	   * @type fabric.Shadow
	   * @default
	   */
	  shadow:           null,
	
	  /**
	   * Line endings style of a brush (one of "butt", "round", "square")
	   * @type String
	   * @default
	   */
	  strokeLineCap:    'round',
	
	  /**
	   * Corner style of a brush (one of "bevil", "round", "miter")
	   * @type String
	   * @default
	   */
	  strokeLineJoin:   'round',
	
	  /**
	   * Stroke Dash Array.
	   * @type Array
	   * @default
	   */
	  strokeDashArray:  null,
	
	  /**
	   * Sets shadow of an object
	   * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  setShadow: function(options) {
	    this.shadow = new fabric.Shadow(options);
	    return this;
	  },
	
	  /**
	   * Sets brush styles
	   * @private
	   */
	  _setBrushStyles: function() {
	    var ctx = this.canvas.contextTop;
	
	    ctx.strokeStyle = this.color;
	    ctx.lineWidth = this.width;
	    ctx.lineCap = this.strokeLineCap;
	    ctx.lineJoin = this.strokeLineJoin;
	    if (this.strokeDashArray && fabric.StaticCanvas.supports('setLineDash')) {
	      ctx.setLineDash(this.strokeDashArray);
	    }
	  },
	
	  /**
	   * Sets brush shadow styles
	   * @private
	   */
	  _setShadow: function() {
	    if (!this.shadow) {
	      return;
	    }
	
	    var ctx = this.canvas.contextTop;
	
	    ctx.shadowColor = this.shadow.color;
	    ctx.shadowBlur = this.shadow.blur;
	    ctx.shadowOffsetX = this.shadow.offsetX;
	    ctx.shadowOffsetY = this.shadow.offsetY;
	  },
	
	  /**
	   * Removes brush shadow styles
	   * @private
	   */
	  _resetShadow: function() {
	    var ctx = this.canvas.contextTop;
	
	    ctx.shadowColor = '';
	    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
	  }
	});
	
	
	(function() {
	
	  /**
	   * PencilBrush class
	   * @class fabric.PencilBrush
	   * @extends fabric.BaseBrush
	   */
	  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {
	
	    /**
	     * Constructor
	     * @param {fabric.Canvas} canvas
	     * @return {fabric.PencilBrush} Instance of a pencil brush
	     */
	    initialize: function(canvas) {
	      this.canvas = canvas;
	      this._points = [ ];
	    },
	
	    /**
	     * Inovoked on mouse down
	     * @param {Object} pointer
	     */
	    onMouseDown: function(pointer) {
	      this._prepareForDrawing(pointer);
	      // capture coordinates immediately
	      // this allows to draw dots (when movement never occurs)
	      this._captureDrawingPath(pointer);
	      this._render();
	    },
	
	    /**
	     * Inovoked on mouse move
	     * @param {Object} pointer
	     */
	    onMouseMove: function(pointer) {
	      this._captureDrawingPath(pointer);
	      // redraw curve
	      // clear top canvas
	      this.canvas.clearContext(this.canvas.contextTop);
	      this._render();
	    },
	
	    /**
	     * Invoked on mouse up
	     */
	    onMouseUp: function() {
	      this._finalizeAndAddPath();
	    },
	
	    /**
	     * @private
	     * @param {Object} pointer Actual mouse position related to the canvas.
	     */
	    _prepareForDrawing: function(pointer) {
	
	      var p = new fabric.Point(pointer.x, pointer.y);
	
	      this._reset();
	      this._addPoint(p);
	
	      this.canvas.contextTop.moveTo(p.x, p.y);
	    },
	
	    /**
	     * @private
	     * @param {fabric.Point} point Point to be added to points array
	     */
	    _addPoint: function(point) {
	      this._points.push(point);
	    },
	
	    /**
	     * Clear points array and set contextTop canvas style.
	     * @private
	     */
	    _reset: function() {
	      this._points.length = 0;
	
	      this._setBrushStyles();
	      this._setShadow();
	    },
	
	    /**
	     * @private
	     * @param {Object} pointer Actual mouse position related to the canvas.
	     */
	    _captureDrawingPath: function(pointer) {
	      var pointerPoint = new fabric.Point(pointer.x, pointer.y);
	      this._addPoint(pointerPoint);
	    },
	
	    /**
	     * Draw a smooth path on the topCanvas using quadraticCurveTo
	     * @private
	     */
	    _render: function() {
	      var ctx  = this.canvas.contextTop,
	          v = this.canvas.viewportTransform,
	          p1 = this._points[0],
	          p2 = this._points[1];
	
	      ctx.save();
	      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
	      ctx.beginPath();
	
	      //if we only have 2 points in the path and they are the same
	      //it means that the user only clicked the canvas without moving the mouse
	      //then we should be drawing a dot. A path isn't drawn between two identical dots
	      //that's why we set them apart a bit
	      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
	        p1.x -= 0.5;
	        p2.x += 0.5;
	      }
	      ctx.moveTo(p1.x, p1.y);
	
	      for (var i = 1, len = this._points.length; i < len; i++) {
	        // we pick the point between pi + 1 & pi + 2 as the
	        // end point and p1 as our control point.
	        var midPoint = p1.midPointFrom(p2);
	        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
	
	        p1 = this._points[i];
	        p2 = this._points[i + 1];
	      }
	      // Draw last line as a straight line while
	      // we wait for the next point to be able to calculate
	      // the bezier control point
	      ctx.lineTo(p1.x, p1.y);
	      ctx.stroke();
	      ctx.restore();
	    },
	
	    /**
	     * Converts points to SVG path
	     * @param {Array} points Array of points
	     * @param {Number} minX
	     * @param {Number} minY
	     * @return {String} SVG path
	     */
	    convertPointsToSVGPath: function(points) {
	      var path = [],
	          p1 = new fabric.Point(points[0].x, points[0].y),
	          p2 = new fabric.Point(points[1].x, points[1].y);
	
	      path.push('M ', points[0].x, ' ', points[0].y, ' ');
	      for (var i = 1, len = points.length; i < len; i++) {
	        var midPoint = p1.midPointFrom(p2);
	        // p1 is our bezier control point
	        // midpoint is our endpoint
	        // start point is p(i-1) value.
	        path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
	        p1 = new fabric.Point(points[i].x, points[i].y);
	        if ((i + 1) < points.length) {
	          p2 = new fabric.Point(points[i + 1].x, points[i + 1].y);
	        }
	      }
	      path.push('L ', p1.x, ' ', p1.y, ' ');
	      return path;
	    },
	
	    /**
	     * Creates fabric.Path object to add on canvas
	     * @param {String} pathData Path data
	     * @return {fabric.Path} Path to add on canvas
	     */
	    createPath: function(pathData) {
	      var path = new fabric.Path(pathData, {
	                   fill: null,
	                   stroke: this.color,
	                   strokeWidth: this.width,
	                   strokeLineCap: this.strokeLineCap,
	                   strokeLineJoin: this.strokeLineJoin,
	                   strokeDashArray: this.strokeDashArray,
	                   originX: 'center',
	                   originY: 'center'
	                 });
	
	      if (this.shadow) {
	        this.shadow.affectStroke = true;
	        path.setShadow(this.shadow);
	      }
	
	      return path;
	    },
	
	    /**
	     * On mouseup after drawing the path on contextTop canvas
	     * we use the points captured to create an new fabric path object
	     * and add it to the fabric canvas.
	     */
	    _finalizeAndAddPath: function() {
	      var ctx = this.canvas.contextTop;
	      ctx.closePath();
	
	      var pathData = this.convertPointsToSVGPath(this._points).join('');
	      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
	        // do not create 0 width/height paths, as they are
	        // rendered inconsistently across browsers
	        // Firefox 4, for example, renders a dot,
	        // whereas Chrome 10 renders nothing
	        this.canvas.renderAll();
	        return;
	      }
	
	      var path = this.createPath(pathData);
	
	      this.canvas.add(path);
	      path.setCoords();
	
	      this.canvas.clearContext(this.canvas.contextTop);
	      this._resetShadow();
	      this.canvas.renderAll();
	
	      // fire event 'path' created
	      this.canvas.fire('path:created', { path: path });
	    }
	  });
	})();
	
	
	/**
	 * CircleBrush class
	 * @class fabric.CircleBrush
	 */
	fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {
	
	  /**
	   * Width of a brush
	   * @type Number
	   * @default
	   */
	  width: 10,
	
	  /**
	   * Constructor
	   * @param {fabric.Canvas} canvas
	   * @return {fabric.CircleBrush} Instance of a circle brush
	   */
	  initialize: function(canvas) {
	    this.canvas = canvas;
	    this.points = [ ];
	  },
	
	  /**
	   * Invoked inside on mouse down and mouse move
	   * @param {Object} pointer
	   */
	  drawDot: function(pointer) {
	    var point = this.addPoint(pointer),
	        ctx = this.canvas.contextTop,
	        v = this.canvas.viewportTransform;
	    ctx.save();
	    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
	
	    ctx.fillStyle = point.fill;
	    ctx.beginPath();
	    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
	    ctx.closePath();
	    ctx.fill();
	
	    ctx.restore();
	  },
	
	  /**
	   * Invoked on mouse down
	   */
	  onMouseDown: function(pointer) {
	    this.points.length = 0;
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._setShadow();
	    this.drawDot(pointer);
	  },
	
	  /**
	   * Invoked on mouse move
	   * @param {Object} pointer
	   */
	  onMouseMove: function(pointer) {
	    this.drawDot(pointer);
	  },
	
	  /**
	   * Invoked on mouse up
	   */
	  onMouseUp: function() {
	    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
	    this.canvas.renderOnAddRemove = false;
	
	    var circles = [ ];
	
	    for (var i = 0, len = this.points.length; i < len; i++) {
	      var point = this.points[i],
	          circle = new fabric.Circle({
	            radius: point.radius,
	            left: point.x,
	            top: point.y,
	            originX: 'center',
	            originY: 'center',
	            fill: point.fill
	          });
	
	      this.shadow && circle.setShadow(this.shadow);
	
	      circles.push(circle);
	    }
	    var group = new fabric.Group(circles, { originX: 'center', originY: 'center' });
	    group.canvas = this.canvas;
	
	    this.canvas.add(group);
	    this.canvas.fire('path:created', { path: group });
	
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._resetShadow();
	    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
	    this.canvas.renderAll();
	  },
	
	  /**
	   * @param {Object} pointer
	   * @return {fabric.Point} Just added pointer point
	   */
	  addPoint: function(pointer) {
	    var pointerPoint = new fabric.Point(pointer.x, pointer.y),
	
	        circleRadius = fabric.util.getRandomInt(
	                        Math.max(0, this.width - 20), this.width + 20) / 2,
	
	        circleColor = new fabric.Color(this.color)
	                        .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
	                        .toRgba();
	
	    pointerPoint.radius = circleRadius;
	    pointerPoint.fill = circleColor;
	
	    this.points.push(pointerPoint);
	
	    return pointerPoint;
	  }
	});
	
	
	/**
	 * SprayBrush class
	 * @class fabric.SprayBrush
	 */
	fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {
	
	  /**
	   * Width of a spray
	   * @type Number
	   * @default
	   */
	  width:              10,
	
	  /**
	   * Density of a spray (number of dots per chunk)
	   * @type Number
	   * @default
	   */
	  density:            20,
	
	  /**
	   * Width of spray dots
	   * @type Number
	   * @default
	   */
	  dotWidth:           1,
	
	  /**
	   * Width variance of spray dots
	   * @type Number
	   * @default
	   */
	  dotWidthVariance:   1,
	
	  /**
	   * Whether opacity of a dot should be random
	   * @type Boolean
	   * @default
	   */
	  randomOpacity:        false,
	
	  /**
	   * Whether overlapping dots (rectangles) should be removed (for performance reasons)
	   * @type Boolean
	   * @default
	   */
	  optimizeOverlapping:  true,
	
	  /**
	   * Constructor
	   * @param {fabric.Canvas} canvas
	   * @return {fabric.SprayBrush} Instance of a spray brush
	   */
	  initialize: function(canvas) {
	    this.canvas = canvas;
	    this.sprayChunks = [ ];
	  },
	
	  /**
	   * Invoked on mouse down
	   * @param {Object} pointer
	   */
	  onMouseDown: function(pointer) {
	    this.sprayChunks.length = 0;
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._setShadow();
	
	    this.addSprayChunk(pointer);
	    this.render();
	  },
	
	  /**
	   * Invoked on mouse move
	   * @param {Object} pointer
	   */
	  onMouseMove: function(pointer) {
	    this.addSprayChunk(pointer);
	    this.render();
	  },
	
	  /**
	   * Invoked on mouse up
	   */
	  onMouseUp: function() {
	    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
	    this.canvas.renderOnAddRemove = false;
	
	    var rects = [ ];
	
	    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
	      var sprayChunk = this.sprayChunks[i];
	
	      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {
	
	        var rect = new fabric.Rect({
	          width: sprayChunk[j].width,
	          height: sprayChunk[j].width,
	          left: sprayChunk[j].x + 1,
	          top: sprayChunk[j].y + 1,
	          originX: 'center',
	          originY: 'center',
	          fill: this.color
	        });
	
	        this.shadow && rect.setShadow(this.shadow);
	        rects.push(rect);
	      }
	    }
	
	    if (this.optimizeOverlapping) {
	      rects = this._getOptimizedRects(rects);
	    }
	
	    var group = new fabric.Group(rects, { originX: 'center', originY: 'center' });
	    group.canvas = this.canvas;
	
	    this.canvas.add(group);
	    this.canvas.fire('path:created', { path: group });
	
	    this.canvas.clearContext(this.canvas.contextTop);
	    this._resetShadow();
	    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
	    this.canvas.renderAll();
	  },
	
	  /**
	   * @private
	   * @param {Array} rects
	   */
	  _getOptimizedRects: function(rects) {
	
	    // avoid creating duplicate rects at the same coordinates
	    var uniqueRects = { }, key;
	
	    for (var i = 0, len = rects.length; i < len; i++) {
	      key = rects[i].left + '' + rects[i].top;
	      if (!uniqueRects[key]) {
	        uniqueRects[key] = rects[i];
	      }
	    }
	    var uniqueRectsArray = [ ];
	    for (key in uniqueRects) {
	      uniqueRectsArray.push(uniqueRects[key]);
	    }
	
	    return uniqueRectsArray;
	  },
	
	  /**
	   * Renders brush
	   */
	  render: function() {
	    var ctx = this.canvas.contextTop;
	    ctx.fillStyle = this.color;
	
	    var v = this.canvas.viewportTransform;
	    ctx.save();
	    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
	
	    for (var i = 0, len = this.sprayChunkPoints.length; i < len; i++) {
	      var point = this.sprayChunkPoints[i];
	      if (typeof point.opacity !== 'undefined') {
	        ctx.globalAlpha = point.opacity;
	      }
	      ctx.fillRect(point.x, point.y, point.width, point.width);
	    }
	    ctx.restore();
	  },
	
	  /**
	   * @param {Object} pointer
	   */
	  addSprayChunk: function(pointer) {
	    this.sprayChunkPoints = [ ];
	
	    var x, y, width, radius = this.width / 2;
	
	    for (var i = 0; i < this.density; i++) {
	
	      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
	      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);
	
	      if (this.dotWidthVariance) {
	        width = fabric.util.getRandomInt(
	          // bottom clamp width to 1
	          Math.max(1, this.dotWidth - this.dotWidthVariance),
	          this.dotWidth + this.dotWidthVariance);
	      }
	      else {
	        width = this.dotWidth;
	      }
	
	      var point = new fabric.Point(x, y);
	      point.width = width;
	
	      if (this.randomOpacity) {
	        point.opacity = fabric.util.getRandomInt(0, 100) / 100;
	      }
	
	      this.sprayChunkPoints.push(point);
	    }
	
	    this.sprayChunks.push(this.sprayChunkPoints);
	  }
	});
	
	
	/**
	 * PatternBrush class
	 * @class fabric.PatternBrush
	 * @extends fabric.BaseBrush
	 */
	fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {
	
	  getPatternSrc: function() {
	
	    var dotWidth = 20,
	        dotDistance = 5,
	        patternCanvas = fabric.document.createElement('canvas'),
	        patternCtx = patternCanvas.getContext('2d');
	
	    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;
	
	    patternCtx.fillStyle = this.color;
	    patternCtx.beginPath();
	    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
	    patternCtx.closePath();
	    patternCtx.fill();
	
	    return patternCanvas;
	  },
	
	  getPatternSrcFunction: function() {
	    return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
	  },
	
	  /**
	   * Creates "pattern" instance property
	   */
	  getPattern: function() {
	    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
	  },
	
	  /**
	   * Sets brush styles
	   */
	  _setBrushStyles: function() {
	    this.callSuper('_setBrushStyles');
	    this.canvas.contextTop.strokeStyle = this.getPattern();
	  },
	
	  /**
	   * Creates path
	   */
	  createPath: function(pathData) {
	    var path = this.callSuper('createPath', pathData);
	    path.stroke = new fabric.Pattern({
	      source: this.source || this.getPatternSrcFunction()
	    });
	    return path;
	  }
	});
	
	
	(function() {
	
	  var getPointer = fabric.util.getPointer,
	      degreesToRadians = fabric.util.degreesToRadians,
	      radiansToDegrees = fabric.util.radiansToDegrees,
	      atan2 = Math.atan2,
	      abs = Math.abs,
	
	      STROKE_OFFSET = 0.5;
	
	  /**
	   * Canvas class
	   * @class fabric.Canvas
	   * @extends fabric.StaticCanvas
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#canvas}
	   * @see {@link fabric.Canvas#initialize} for constructor definition
	   *
	   * @fires object:modified
	   * @fires object:rotating
	   * @fires object:scaling
	   * @fires object:moving
	   * @fires object:selected
	   *
	   * @fires before:selection:cleared
	   * @fires selection:cleared
	   * @fires selection:created
	   *
	   * @fires path:created
	   * @fires mouse:down
	   * @fires mouse:move
	   * @fires mouse:up
	   * @fires mouse:over
	   * @fires mouse:out
	   *
	   */
	  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {
	
	    /**
	     * Constructor
	     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(el, options) {
	      options || (options = { });
	
	      this._initStatic(el, options);
	      this._initInteractive();
	      this._createCacheCanvas();
	
	      fabric.Canvas.activeInstance = this;
	    },
	
	    /**
	     * When true, objects can be transformed by one side (unproportionally)
	     * @type Boolean
	     * @default
	     */
	    uniScaleTransform:      false,
	
	    /**
	     * When true, objects use center point as the origin of scale transformation.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredScaling:        false,
	
	    /**
	     * When true, objects use center point as the origin of rotate transformation.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredRotation:       false,
	
	    /**
	     * Indicates that canvas is interactive. This property should not be changed.
	     * @type Boolean
	     * @default
	     */
	    interactive:            true,
	
	    /**
	     * Indicates whether group selection should be enabled
	     * @type Boolean
	     * @default
	     */
	    selection:              true,
	
	    /**
	     * Color of selection
	     * @type String
	     * @default
	     */
	    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue
	
	    /**
	     * Default dash array pattern
	     * If not empty the selection border is dashed
	     * @type Array
	     */
	    selectionDashArray:     [ ],
	
	    /**
	     * Color of the border of selection (usually slightly darker than color of selection itself)
	     * @type String
	     * @default
	     */
	    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',
	
	    /**
	     * Width of a line used in object/group selection
	     * @type Number
	     * @default
	     */
	    selectionLineWidth:     1,
	
	    /**
	     * Default cursor value used when hovering over an object on canvas
	     * @type String
	     * @default
	     */
	    hoverCursor:            'move',
	
	    /**
	     * Default cursor value used when moving an object on canvas
	     * @type String
	     * @default
	     */
	    moveCursor:             'move',
	
	    /**
	     * Default cursor value used for the entire canvas
	     * @type String
	     * @default
	     */
	    defaultCursor:          'default',
	
	    /**
	     * Cursor value used during free drawing
	     * @type String
	     * @default
	     */
	    freeDrawingCursor:      'crosshair',
	
	    /**
	     * Cursor value used for rotation point
	     * @type String
	     * @default
	     */
	    rotationCursor:         'crosshair',
	
	    /**
	     * Default element class that's given to wrapper (div) element of canvas
	     * @type String
	     * @default
	     */
	    containerClass:         'canvas-container',
	
	    /**
	     * When true, object detection happens on per-pixel basis rather than on per-bounding-box
	     * @type Boolean
	     * @default
	     */
	    perPixelTargetFind:     false,
	
	    /**
	     * Number of pixels around target pixel to tolerate (consider active) during object detection
	     * @type Number
	     * @default
	     */
	    targetFindTolerance:    0,
	
	    /**
	     * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.
	     * @type Boolean
	     * @default
	     */
	    skipTargetFind:         false,
	
	    /**
	     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
	     * After mousedown, mousemove creates a shape,
	     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
	     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4/#free_drawing}
	     * @type Boolean
	     * @default
	     */
	    isDrawingMode:          false,
	
	    /**
	     * @private
	     */
	    _initInteractive: function() {
	      this._currentTransform = null;
	      this._groupSelector = null;
	      this._initWrapperElement();
	      this._createUpperCanvas();
	      this._initEventListeners();
	
	      this._initRetinaScaling();
	
	      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);
	
	      this.calcOffset();
	    },
	
	    /**
	     * Resets the current transform to its original values and chooses the type of resizing based on the event
	     * @private
	     * @param {Event} e Event object fired on mousemove
	     */
	    _resetCurrentTransform: function(e) {
	      var t = this._currentTransform;
	
	      t.target.set({
	        scaleX: t.original.scaleX,
	        scaleY: t.original.scaleY,
	        left: t.original.left,
	        top: t.original.top
	      });
	
	      if (this._shouldCenterTransform(e, t.target)) {
	        if (t.action === 'rotate') {
	          this._setOriginToCenter(t.target);
	        }
	        else {
	          if (t.originX !== 'center') {
	            if (t.originX === 'right') {
	              t.mouseXSign = -1;
	            }
	            else {
	              t.mouseXSign = 1;
	            }
	          }
	          if (t.originY !== 'center') {
	            if (t.originY === 'bottom') {
	              t.mouseYSign = -1;
	            }
	            else {
	              t.mouseYSign = 1;
	            }
	          }
	
	          t.originX = 'center';
	          t.originY = 'center';
	        }
	      }
	      else {
	        t.originX = t.original.originX;
	        t.originY = t.original.originY;
	      }
	    },
	
	    /**
	     * Checks if point is contained within an area of given object
	     * @param {Event} e Event object
	     * @param {fabric.Object} target Object to test against
	     * @return {Boolean} true if point is contained within an area of given object
	     */
	    containsPoint: function (e, target) {
	      var pointer = this.getPointer(e, true),
	          xy = this._normalizePointer(target, pointer);
	
	      // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
	      // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
	      return (target.containsPoint(xy) || target._findTargetCorner(pointer));
	    },
	
	    /**
	     * @private
	     */
	    _normalizePointer: function (object, pointer) {
	      var activeGroup = this.getActiveGroup(),
	          x = pointer.x,
	          y = pointer.y,
	          isObjectInGroup = (
	            activeGroup &&
	            object.type !== 'group' &&
	            activeGroup.contains(object)),
	          lt;
	
	      if (isObjectInGroup) {
	        lt = fabric.util.transformPoint(activeGroup.getCenterPoint(), this.viewportTransform, true);
	        x -= lt.x;
	        y -= lt.y;
	        x /= activeGroup.scaleX;
	        y /= activeGroup.scaleY;
	      }
	      return { x: x, y: y };
	    },
	
	    /**
	     * Returns true if object is transparent at a certain location
	     * @param {fabric.Object} target Object to check
	     * @param {Number} x Left coordinate
	     * @param {Number} y Top coordinate
	     * @return {Boolean}
	     */
	    isTargetTransparent: function (target, x, y) {
	      var hasBorders = target.hasBorders,
	          transparentCorners = target.transparentCorners;
	
	      target.hasBorders = target.transparentCorners = false;
	
	      this._draw(this.contextCache, target);
	
	      target.hasBorders = hasBorders;
	      target.transparentCorners = transparentCorners;
	
	      var isTransparent = fabric.util.isTransparent(
	        this.contextCache, x, y, this.targetFindTolerance);
	
	      this.clearContext(this.contextCache);
	
	      return isTransparent;
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     */
	    _shouldClearSelection: function (e, target) {
	      var activeGroup = this.getActiveGroup(),
	          activeObject = this.getActiveObject();
	
	      return (
	        !target
	        ||
	        (target &&
	          activeGroup &&
	          !activeGroup.contains(target) &&
	          activeGroup !== target &&
	          !e.shiftKey)
	        ||
	        (target && !target.evented)
	        ||
	        (target &&
	          !target.selectable &&
	          activeObject &&
	          activeObject !== target)
	      );
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     */
	    _shouldCenterTransform: function (e, target) {
	      if (!target) {
	        return;
	      }
	
	      var t = this._currentTransform,
	          centerTransform;
	
	      if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {
	        centerTransform = this.centeredScaling || target.centeredScaling;
	      }
	      else if (t.action === 'rotate') {
	        centerTransform = this.centeredRotation || target.centeredRotation;
	      }
	
	      return centerTransform ? !e.altKey : e.altKey;
	    },
	
	    /**
	     * @private
	     */
	    _getOriginFromCorner: function(target, corner) {
	      var origin = {
	        x: target.originX,
	        y: target.originY
	      };
	
	      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
	        origin.x = 'right';
	      }
	      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
	        origin.x = 'left';
	      }
	
	      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
	        origin.y = 'bottom';
	      }
	      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
	        origin.y = 'top';
	      }
	
	      return origin;
	    },
	
	    /**
	     * @private
	     */
	    _getActionFromCorner: function(target, corner) {
	      var action = 'drag';
	      if (corner) {
	        action = (corner === 'ml' || corner === 'mr')
	          ? 'scaleX'
	          : (corner === 'mt' || corner === 'mb')
	            ? 'scaleY'
	            : corner === 'mtr'
	              ? 'rotate'
	              : 'scale';
	      }
	      return action;
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     */
	    _setupCurrentTransform: function (e, target) {
	      if (!target) {
	        return;
	      }
	
	      var pointer = this.getPointer(e),
	          corner = target._findTargetCorner(this.getPointer(e, true)),
	          action = this._getActionFromCorner(target, corner),
	          origin = this._getOriginFromCorner(target, corner);
	
	      this._currentTransform = {
	        target: target,
	        action: action,
	        scaleX: target.scaleX,
	        scaleY: target.scaleY,
	        offsetX: pointer.x - target.left,
	        offsetY: pointer.y - target.top,
	        originX: origin.x,
	        originY: origin.y,
	        ex: pointer.x,
	        ey: pointer.y,
	        left: target.left,
	        top: target.top,
	        theta: degreesToRadians(target.angle),
	        width: target.width * target.scaleX,
	        mouseXSign: 1,
	        mouseYSign: 1
	      };
	
	      this._currentTransform.original = {
	        left: target.left,
	        top: target.top,
	        scaleX: target.scaleX,
	        scaleY: target.scaleY,
	        originX: origin.x,
	        originY: origin.y
	      };
	
	      this._resetCurrentTransform(e);
	    },
	
	    /**
	     * Translates object by "setting" its left/top
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     */
	    _translateObject: function (x, y) {
	      var target = this._currentTransform.target;
	
	      if (!target.get('lockMovementX')) {
	        target.set('left', x - this._currentTransform.offsetX);
	      }
	      if (!target.get('lockMovementY')) {
	        target.set('top', y - this._currentTransform.offsetY);
	      }
	    },
	
	    /**
	     * Scales object by invoking its scaleX/scaleY methods
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.
	     *                    When not provided, an object is scaled by both dimensions equally
	     */
	    _scaleObject: function (x, y, by) {
	      var t = this._currentTransform,
	          target = t.target,
	          lockScalingX = target.get('lockScalingX'),
	          lockScalingY = target.get('lockScalingY'),
	          lockScalingFlip = target.get('lockScalingFlip');
	
	      if (lockScalingX && lockScalingY) {
	        return;
	      }
	
	      // Get the constraint point
	      var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),
	          localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY);
	
	      this._setLocalMouse(localMouse, t);
	
	      // Actually scale the object
	      this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip);
	
	      // Make sure the constraints apply
	      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
	    },
	
	    /**
	     * @private
	     */
	    _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip) {
	      var target = transform.target, forbidScalingX = false, forbidScalingY = false,
	          dim = target._getNonTransformedDimensions();
	
	      transform.newScaleX = localMouse.x / dim.x;
	      transform.newScaleY = localMouse.y / dim.y;
	
	      if (lockScalingFlip && transform.newScaleX <= 0 && transform.newScaleX < target.scaleX) {
	        forbidScalingX = true;
	      }
	
	      if (lockScalingFlip && transform.newScaleY <= 0 && transform.newScaleY < target.scaleY) {
	        forbidScalingY = true;
	      }
	
	      if (by === 'equally' && !lockScalingX && !lockScalingY) {
	        forbidScalingX || forbidScalingY || this._scaleObjectEqually(localMouse, target, transform);
	      }
	      else if (!by) {
	        forbidScalingX || lockScalingX || target.set('scaleX', transform.newScaleX);
	        forbidScalingY || lockScalingY || target.set('scaleY', transform.newScaleY);
	      }
	      else if (by === 'x' && !target.get('lockUniScaling')) {
	        forbidScalingX || lockScalingX || target.set('scaleX', transform.newScaleX);
	      }
	      else if (by === 'y' && !target.get('lockUniScaling')) {
	        forbidScalingY || lockScalingY || target.set('scaleY', transform.newScaleY);
	      }
	
	      forbidScalingX || forbidScalingY || this._flipObject(transform, by);
	
	    },
	
	    /**
	     * @private
	     */
	    _scaleObjectEqually: function(localMouse, target, transform) {
	
	      var public = localMouse.y + localMouse.x,
	          dim = target._getNonTransformedDimensions(),
	          lastDist = dim.y * transform.original.scaleY +
	                     dim.x * transform.original.scaleX;
	
	      // We use transform.scaleX/Y instead of target.scaleX/Y
	      // because the object may have a min scale and we'll loose the proportions
	      transform.newScaleX = transform.original.scaleX * public / lastDist;
	      transform.newScaleY = transform.original.scaleY * public / lastDist;
	
	      target.set('scaleX', transform.newScaleX);
	      target.set('scaleY', transform.newScaleY);
	    },
	
	    /**
	     * @private
	     */
	    _flipObject: function(transform, by) {
	      if (transform.newScaleX < 0 && by !== 'y') {
	        if (transform.originX === 'left') {
	          transform.originX = 'right';
	        }
	        else if (transform.originX === 'right') {
	          transform.originX = 'left';
	        }
	      }
	
	      if (transform.newScaleY < 0 && by !== 'x') {
	        if (transform.originY === 'top') {
	          transform.originY = 'bottom';
	        }
	        else if (transform.originY === 'bottom') {
	          transform.originY = 'top';
	        }
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setLocalMouse: function(localMouse, t) {
	      var target = t.target;
	
	      if (t.originX === 'right') {
	        localMouse.x *= -1;
	      }
	      else if (t.originX === 'center') {
	        localMouse.x *= t.mouseXSign * 2;
	
	        if (localMouse.x < 0) {
	          t.mouseXSign = -t.mouseXSign;
	        }
	      }
	
	      if (t.originY === 'bottom') {
	        localMouse.y *= -1;
	      }
	      else if (t.originY === 'center') {
	        localMouse.y *= t.mouseYSign * 2;
	
	        if (localMouse.y < 0) {
	          t.mouseYSign = -t.mouseYSign;
	        }
	      }
	
	      // adjust the mouse coordinates when dealing with padding
	      if (abs(localMouse.x) > target.padding) {
	        if (localMouse.x < 0) {
	          localMouse.x += target.padding;
	        }
	        else {
	          localMouse.x -= target.padding;
	        }
	      }
	      else { // mouse is within the padding, set to 0
	        localMouse.x = 0;
	      }
	
	      if (abs(localMouse.y) > target.padding) {
	        if (localMouse.y < 0) {
	          localMouse.y += target.padding;
	        }
	        else {
	          localMouse.y -= target.padding;
	        }
	      }
	      else {
	        localMouse.y = 0;
	      }
	    },
	
	    /**
	     * Rotates object by invoking its rotate method
	     * @private
	     * @param {Number} x pointer's x coordinate
	     * @param {Number} y pointer's y coordinate
	     */
	    _rotateObject: function (x, y) {
	
	      var t = this._currentTransform;
	
	      if (t.target.get('lockRotation')) {
	        return;
	      }
	
	      var lastAngle = atan2(t.ey - t.top, t.ex - t.left),
	          curAngle = atan2(y - t.top, x - t.left),
	          angle = radiansToDegrees(curAngle - lastAngle + t.theta);
	
	      // normalize angle to positive value
	      if (angle < 0) {
	        angle = 360 + angle;
	      }
	
	      t.target.angle = angle % 360;
	    },
	
	    /**
	     * Set the cursor type of the canvas element
	     * @param {String} value Cursor type of the canvas element.
	     * @see http://www.w3.org/TR/css3-ui/#cursor
	     */
	    setCursor: function (value) {
	      this.upperCanvasEl.style.cursor = value;
	    },
	
	    /**
	     * @private
	     */
	    _resetObjectTransform: function (target) {
	      target.scaleX = 1;
	      target.scaleY = 1;
	      target.setAngle(0);
	    },
	
	    /**
	     * @private
	     */
	    _drawSelection: function () {
	      var ctx = this.contextTop,
	          groupSelector = this._groupSelector,
	          left = groupSelector.left,
	          top = groupSelector.top,
	          aleft = abs(left),
	          atop = abs(top);
	
	      ctx.fillStyle = this.selectionColor;
	
	      ctx.fillRect(
	        groupSelector.ex - ((left > 0) ? 0 : -left),
	        groupSelector.ey - ((top > 0) ? 0 : -top),
	        aleft,
	        atop
	      );
	
	      ctx.lineWidth = this.selectionLineWidth;
	      ctx.strokeStyle = this.selectionBorderColor;
	
	      // selection border
	      if (this.selectionDashArray.length > 1) {
	
	        var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0: aleft),
	            py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0: atop);
	
	        ctx.beginPath();
	
	        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);
	        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);
	        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);
	        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);
	
	        ctx.closePath();
	        ctx.stroke();
	      }
	      else {
	        ctx.strokeRect(
	          groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
	          groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),
	          aleft,
	          atop
	        );
	      }
	    },
	
	    /**
	     * @private
	     */
	    _isLastRenderedObject: function(e) {
	      return (
	        this.controlsAboveOverlay &&
	        this.lastRenderedObjectWithControlsAboveOverlay &&
	        this.lastRenderedObjectWithControlsAboveOverlay.visible &&
	        this.containsPoint(e, this.lastRenderedObjectWithControlsAboveOverlay) &&
	        this.lastRenderedObjectWithControlsAboveOverlay._findTargetCorner(this.getPointer(e, true)));
	    },
	
	    /**
	     * Method that determines what object we are clicking on
	     * @param {Event} e mouse event
	     * @param {Boolean} skipGroup when true, group is skipped and only objects are traversed through
	     */
	    findTarget: function (e, skipGroup) {
	      if (this.skipTargetFind) {
	        return;
	      }
	
	      if (this._isLastRenderedObject(e)) {
	        return this.lastRenderedObjectWithControlsAboveOverlay;
	      }
	
	      // first check current group (if one exists)
	      var activeGroup = this.getActiveGroup();
	      if (activeGroup && !skipGroup && this.containsPoint(e, activeGroup)) {
	        return activeGroup;
	      }
	
	      var target = this._searchPossibleTargets(e, skipGroup);
	      this._fireOverOutEvents(target, e);
	
	      return target;
	    },
	
	    /**
	     * @private
	     */
	    _fireOverOutEvents: function(target, e) {
	      if (target) {
	        if (this._hoveredTarget !== target) {
	          if (this._hoveredTarget) {
	            this.fire('mouse:out', { target: this._hoveredTarget, e: e });
	            this._hoveredTarget.fire('mouseout');
	          }
	          this.fire('mouse:over', { target: target, e: e });
	          target.fire('mouseover');
	          this._hoveredTarget = target;
	        }
	      }
	      else if (this._hoveredTarget) {
	        this.fire('mouse:out', { target: this._hoveredTarget, e: e });
	        this._hoveredTarget.fire('mouseout');
	        this._hoveredTarget = null;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _checkTarget: function(e, obj, pointer) {
	      if (obj &&
	          obj.visible &&
	          obj.evented &&
	          this.containsPoint(e, obj)){
	        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
	          var isTransparent = this.isTargetTransparent(obj, pointer.x, pointer.y);
	          if (!isTransparent) {
	            return true;
	          }
	        }
	        else {
	          return true;
	        }
	      }
	    },
	
	    /**
	     * @private
	     */
	    _searchPossibleTargets: function(e, skipGroup) {
	
	      // Cache all targets where their bounding box contains point.
	      var target,
	          pointer = this.getPointer(e, true),
	          i = this._objects.length;
	      // Do not check for currently grouped objects, since we check the parent group itself.
	      // untill we call this function specifically to search inside the activeGroup
	      while (i--) {
	        if ((!this._objects[i].group || skipGroup) && this._checkTarget(e, this._objects[i], pointer)){
	          this.relatedTarget = this._objects[i];
	          target = this._objects[i];
	          break;
	        }
	      }
	
	      return target;
	    },
	
	    /**
	     * Returns pointer coordinates relative to canvas.
	     * @param {Event} e
	     * @return {Object} object with "x" and "y" number values
	     */
	    getPointer: function (e, ignoreZoom, upperCanvasEl) {
	      if (!upperCanvasEl) {
	        upperCanvasEl = this.upperCanvasEl;
	      }
	      var pointer = getPointer(e),
	          bounds = upperCanvasEl.getBoundingClientRect(),
	          boundsWidth = bounds.width || 0,
	          boundsHeight = bounds.height || 0,
	          cssScale;
	
	      if (!boundsWidth || !boundsHeight ) {
	        if ('top' in bounds && 'bottom' in bounds) {
	          boundsHeight = Math.abs( bounds.top - bounds.bottom );
	        }
	        if ('right' in bounds && 'left' in bounds) {
	          boundsWidth = Math.abs( bounds.right - bounds.left );
	        }
	      }
	
	      this.calcOffset();
	
	      pointer.x = pointer.x - this._offset.left;
	      pointer.y = pointer.y - this._offset.top;
	      if (!ignoreZoom) {
	        pointer = fabric.util.transformPoint(
	          pointer,
	          fabric.util.invertTransform(this.viewportTransform)
	        );
	      }
	
	      if (boundsWidth === 0 || boundsHeight === 0) {
	        // If bounds are not available (i.e. not visible), do not apply scale.
	        cssScale = { width: 1, height: 1 };
	      }
	      else {
	        cssScale = {
	          width: upperCanvasEl.width / boundsWidth,
	          height: upperCanvasEl.height / boundsHeight
	        };
	      }
	
	      return {
	        x: pointer.x * cssScale.width,
	        y: pointer.y * cssScale.height
	      };
	    },
	
	    /**
	     * @private
	     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
	     */
	    _createUpperCanvas: function () {
	      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, '');
	
	      this.upperCanvasEl = this._createCanvasElement();
	      fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);
	
	      this.wrapperEl.appendChild(this.upperCanvasEl);
	
	      this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);
	      this._applyCanvasStyle(this.upperCanvasEl);
	      this.contextTop = this.upperCanvasEl.getContext('2d');
	    },
	
	    /**
	     * @private
	     */
	    _createCacheCanvas: function () {
	      this.cacheCanvasEl = this._createCanvasElement();
	      this.cacheCanvasEl.setAttribute('width', this.width);
	      this.cacheCanvasEl.setAttribute('height', this.height);
	      this.contextCache = this.cacheCanvasEl.getContext('2d');
	    },
	
	    /**
	     * @private
	     */
	    _initWrapperElement: function () {
	      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
	        'class': this.containerClass
	      });
	      fabric.util.setStyle(this.wrapperEl, {
	        width: this.getWidth() + 'px',
	        height: this.getHeight() + 'px',
	        position: 'relative'
	      });
	      fabric.util.makeElementUnselectable(this.wrapperEl);
	    },
	
	    /**
	     * @private
	     * @param {HTMLElement} element canvas element to apply styles on
	     */
	    _applyCanvasStyle: function (element) {
	      var width = this.getWidth() || element.width,
	          height = this.getHeight() || element.height;
	
	      fabric.util.setStyle(element, {
	        position: 'absolute',
	        width: width + 'px',
	        height: height + 'px',
	        left: 0,
	        top: 0
	      });
	      element.width = width;
	      element.height = height;
	      fabric.util.makeElementUnselectable(element);
	    },
	
	    /**
	     * Copys the the entire inline style from one element (fromEl) to another (toEl)
	     * @private
	     * @param {Element} fromEl Element style is copied from
	     * @param {Element} toEl Element copied style is applied to
	     */
	    _copyCanvasStyle: function (fromEl, toEl) {
	      toEl.style.cssText = fromEl.style.cssText;
	    },
	
	    /**
	     * Returns context of canvas where object selection is drawn
	     * @return {CanvasRenderingContext2D}
	     */
	    getSelectionContext: function() {
	      return this.contextTop;
	    },
	
	    /**
	     * Returns &lt;canvas> element on which object selection is drawn
	     * @return {HTMLCanvasElement}
	     */
	    getSelectionElement: function () {
	      return this.upperCanvasEl;
	    },
	
	    /**
	     * @private
	     * @param {Object} object
	     */
	    _setActiveObject: function(object) {
	      if (this._activeObject) {
	        this._activeObject.set('active', false);
	      }
	      this._activeObject = object;
	      object.set('active', true);
	    },
	
	    /**
	     * Sets given object as the only active object on canvas
	     * @param {fabric.Object} object Object to set as an active one
	     * @param {Event} [e] Event (passed along when firing "object:selected")
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    setActiveObject: function (object, e) {
	      this._setActiveObject(object);
	      this.renderAll();
	      this.fire('object:selected', { target: object, e: e });
	      object.fire('selected', { e: e });
	      return this;
	    },
	
	    /**
	     * Returns currently active object
	     * @return {fabric.Object} active object
	     */
	    getActiveObject: function () {
	      return this._activeObject;
	    },
	
	    /**
	     * @private
	     */
	    _discardActiveObject: function() {
	      if (this._activeObject) {
	        this._activeObject.set('active', false);
	      }
	      this._activeObject = null;
	    },
	
	    /**
	     * Discards currently active object
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    discardActiveObject: function (e) {
	      this._discardActiveObject();
	      this.renderAll();
	      this.fire('selection:cleared', { e: e });
	      return this;
	    },
	
	    /**
	     * @private
	     * @param {fabric.Group} group
	     */
	    _setActiveGroup: function(group) {
	      this._activeGroup = group;
	      if (group) {
	        group.set('active', true);
	      }
	    },
	
	    /**
	     * Sets active group to a speicified one
	     * @param {fabric.Group} group Group to set as a current one
	     * @return {fabric.Canvas} thisArg
	     * @chainable
	     */
	    setActiveGroup: function (group, e) {
	      this._setActiveGroup(group);
	      if (group) {
	        this.fire('object:selected', { target: group, e: e });
	        group.fire('selected', { e: e });
	      }
	      return this;
	    },
	
	    /**
	     * Returns currently active group
	     * @return {fabric.Group} Current group
	     */
	    getActiveGroup: function () {
	      return this._activeGroup;
	    },
	
	    /**
	     * @private
	     */
	    _discardActiveGroup: function() {
	      var g = this.getActiveGroup();
	      if (g) {
	        g.destroy();
	      }
	      this.setActiveGroup(null);
	    },
	
	    /**
	     * Discards currently active group
	     * @return {fabric.Canvas} thisArg
	     */
	    discardActiveGroup: function (e) {
	      this._discardActiveGroup();
	      this.fire('selection:cleared', { e: e });
	      return this;
	    },
	
	    /**
	     * Deactivates all objects on canvas, removing any active group or object
	     * @return {fabric.Canvas} thisArg
	     */
	    deactivateAll: function () {
	      var allObjects = this.getObjects(),
	          i = 0,
	          len = allObjects.length;
	      for ( ; i < len; i++) {
	        allObjects[i].set('active', false);
	      }
	      this._discardActiveGroup();
	      this._discardActiveObject();
	      return this;
	    },
	
	    /**
	     * Deactivates all objects and dispatches appropriate events
	     * @return {fabric.Canvas} thisArg
	     */
	    deactivateAllWithDispatch: function (e) {
	      var activeObject = this.getActiveGroup() || this.getActiveObject();
	      if (activeObject) {
	        this.fire('before:selection:cleared', { target: activeObject, e: e });
	      }
	      this.deactivateAll();
	      if (activeObject) {
	        this.fire('selection:cleared', { e: e });
	      }
	      return this;
	    },
	
	    /**
	     * Draws objects' controls (borders/controls)
	     * @param {CanvasRenderingContext2D} ctx Context to render controls on
	     */
	    drawControls: function(ctx) {
	      var activeGroup = this.getActiveGroup();
	      if (activeGroup) {
	        this._drawGroupControls(ctx, activeGroup);
	      }
	      else {
	        this._drawObjectsControls(ctx);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _drawGroupControls: function(ctx, activeGroup) {
	      activeGroup._renderControls(ctx);
	    },
	
	    /**
	     * @private
	     */
	    _drawObjectsControls: function(ctx) {
	      for (var i = 0, len = this._objects.length; i < len; ++i) {
	        if (!this._objects[i] || !this._objects[i].active) {
	          continue;
	        }
	        this._objects[i]._renderControls(ctx);
	        this.lastRenderedObjectWithControlsAboveOverlay = this._objects[i];
	      }
	    }
	  });
	
	  // copying static properties manually to work around Opera's bug,
	  // where "prototype" property is enumerable and overrides existing prototype
	  for (var prop in fabric.StaticCanvas) {
	    if (prop !== 'prototype') {
	      fabric.Canvas[prop] = fabric.StaticCanvas[prop];
	    }
	  }
	
	  if (fabric.isTouchSupported) {
	    /** @ignore */
	    fabric.Canvas.prototype._setCursorFromEvent = function() { };
	  }
	
	  /**
	   * @class fabric.Element
	   * @alias fabric.Canvas
	   * @deprecated Use {@link fabric.Canvas} instead.
	   * @constructor
	   */
	  fabric.Element = fabric.Canvas;
	})();
	
	
	(function() {
	
	  var cursorOffset = {
	    mt: 0, // n
	    tr: 1, // ne
	    mr: 2, // e
	    br: 3, // se
	    mb: 4, // s
	    bl: 5, // sw
	    ml: 6, // w
	    tl: 7 // nw
	  },
	  addListener = fabric.util.addListener,
	  removeListener = fabric.util.removeListener;
	
	  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {
	
	    /**
	     * Map of cursor style values for each of the object controls
	     * @private
	     */
	    cursorMap: [
	      'n-resize',
	      'ne-resize',
	      'e-resize',
	      'se-resize',
	      's-resize',
	      'sw-resize',
	      'w-resize',
	      'nw-resize'
	    ],
	
	    /**
	     * Adds mouse listeners to canvas
	     * @private
	     */
	    _initEventListeners: function () {
	
	      this._bindEvents();
	
	      addListener(fabric.window, 'resize', this._onResize);
	
	      // mouse events
	      addListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
	      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      addListener(this.upperCanvasEl, 'mousewheel', this._onMouseWheel);
	
	      // touch events
	      addListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);
	      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (typeof eventjs !== 'undefined' && 'add' in eventjs) {
	        eventjs.add(this.upperCanvasEl, 'gesture', this._onGesture);
	        eventjs.add(this.upperCanvasEl, 'drag', this._onDrag);
	        eventjs.add(this.upperCanvasEl, 'orientation', this._onOrientationChange);
	        eventjs.add(this.upperCanvasEl, 'shake', this._onShake);
	        eventjs.add(this.upperCanvasEl, 'longpress', this._onLongPress);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _bindEvents: function() {
	      this._onMouseDown = this._onMouseDown.bind(this);
	      this._onMouseMove = this._onMouseMove.bind(this);
	      this._onMouseUp = this._onMouseUp.bind(this);
	      this._onResize = this._onResize.bind(this);
	      this._onGesture = this._onGesture.bind(this);
	      this._onDrag = this._onDrag.bind(this);
	      this._onShake = this._onShake.bind(this);
	      this._onLongPress = this._onLongPress.bind(this);
	      this._onOrientationChange = this._onOrientationChange.bind(this);
	      this._onMouseWheel = this._onMouseWheel.bind(this);
	    },
	
	    /**
	     * Removes all event listeners
	     */
	    removeListeners: function() {
	      removeListener(fabric.window, 'resize', this._onResize);
	
	      removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
	      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      removeListener(this.upperCanvasEl, 'mousewheel', this._onMouseWheel);
	
	      removeListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);
	      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (typeof eventjs !== 'undefined' && 'remove' in eventjs) {
	        eventjs.remove(this.upperCanvasEl, 'gesture', this._onGesture);
	        eventjs.remove(this.upperCanvasEl, 'drag', this._onDrag);
	        eventjs.remove(this.upperCanvasEl, 'orientation', this._onOrientationChange);
	        eventjs.remove(this.upperCanvasEl, 'shake', this._onShake);
	        eventjs.remove(this.upperCanvasEl, 'longpress', this._onLongPress);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js gesture
	     * @param {Event} [self] Inner Event object
	     */
	    _onGesture: function(e, self) {
	      this.__onTransformGesture && this.__onTransformGesture(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js drag
	     * @param {Event} [self] Inner Event object
	     */
	    _onDrag: function(e, self) {
	      this.__onDrag && this.__onDrag(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js wheel event
	     * @param {Event} [self] Inner Event object
	     */
	    _onMouseWheel: function(e, self) {
	      this.__onMouseWheel && this.__onMouseWheel(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js orientation change
	     * @param {Event} [self] Inner Event object
	     */
	    _onOrientationChange: function(e, self) {
	      this.__onOrientationChange && this.__onOrientationChange(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js shake
	     * @param {Event} [self] Inner Event object
	     */
	    _onShake: function(e, self) {
	      this.__onShake && this.__onShake(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} [e] Event object fired on Event.js shake
	     * @param {Event} [self] Inner Event object
	     */
	    _onLongPress: function(e, self) {
	      this.__onLongPress && this.__onLongPress(e, self);
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    _onMouseDown: function (e) {
	      this.__onMouseDown(e);
	
	      addListener(fabric.document, 'touchend', this._onMouseUp);
	      addListener(fabric.document, 'touchmove', this._onMouseMove);
	
	      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (e.type === 'touchstart') {
	        // Unbind mousedown to prevent double triggers from touch devices
	        removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
	      }
	      else {
	        addListener(fabric.document, 'mouseup', this._onMouseUp);
	        addListener(fabric.document, 'mousemove', this._onMouseMove);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mouseup
	     */
	    _onMouseUp: function (e) {
	      this.__onMouseUp(e);
	
	      removeListener(fabric.document, 'mouseup', this._onMouseUp);
	      removeListener(fabric.document, 'touchend', this._onMouseUp);
	
	      removeListener(fabric.document, 'mousemove', this._onMouseMove);
	      removeListener(fabric.document, 'touchmove', this._onMouseMove);
	
	      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
	      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);
	
	      if (e.type === 'touchend') {
	        // Wait 400ms before rebinding mousedown to prevent double triggers
	        // from touch devices
	        var _this = this;
	        setTimeout(function() {
	          addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);
	        }, 400);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousemove
	     */
	    _onMouseMove: function (e) {
	      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
	      this.__onMouseMove(e);
	    },
	
	    /**
	     * @private
	     */
	    _onResize: function () {
	      this.calcOffset();
	    },
	
	    /**
	     * Decides whether the canvas should be redrawn in mouseup and mousedown events.
	     * @private
	     * @param {Object} target
	     * @param {Object} pointer
	     */
	    _shouldRender: function(target, pointer) {
	      var activeObject = this.getActiveGroup() || this.getActiveObject();
	
	      return !!(
	        (target && (
	          target.isMoving ||
	          target !== activeObject))
	        ||
	        (!target && !!activeObject)
	        ||
	        (!target && !activeObject && !this._groupSelector)
	        ||
	        (pointer &&
	          this._previousPointer &&
	          this.selection && (
	          pointer.x !== this._previousPointer.x ||
	          pointer.y !== this._previousPointer.y))
	      );
	    },
	
	    /**
	     * Method that defines the actions when mouse is released on canvas.
	     * The method resets the currentTransform parameters, store the image corner
	     * position in the image object and render the canvas on top.
	     * @private
	     * @param {Event} e Event object fired on mouseup
	     */
	    __onMouseUp: function (e) {
	      var target;
	
	      if (this.isDrawingMode && this._isCurrentlyDrawing) {
	        this._onMouseUpInDrawingMode(e);
	        return;
	      }
	
	      if (this._currentTransform) {
	        this._finalizeCurrentTransform();
	        target = this._currentTransform.target;
	      }
	      else {
	        target = this.findTarget(e, true);
	      }
	
	      var shouldRender = this._shouldRender(target, this.getPointer(e));
	
	      this._maybeGroupObjects(e);
	
	      if (target) {
	        target.isMoving = false;
	      }
	
	      shouldRender && this.renderAll();
	
	      this._handleCursorAndEvent(e, target);
	    },
	
	    _handleCursorAndEvent: function(e, target) {
	      this._setCursorFromEvent(e, target);
	
	      // TODO: why are we doing this?
	      var _this = this;
	      setTimeout(function () {
	        _this._setCursorFromEvent(e, target);
	      }, 50);
	
	      this.fire('mouse:up', { target: target, e: e });
	      target && target.fire('mouseup', { e: e });
	    },
	
	    /**
	     * @private
	     */
	    _finalizeCurrentTransform: function() {
	
	      var transform = this._currentTransform,
	          target = transform.target;
	
	      if (target._scaling) {
	        target._scaling = false;
	      }
	
	      target.setCoords();
	
	      // only fire :modified event if target coordinates were changed during mousedown-mouseup
	      if (this.stateful && target.hasStateChanged()) {
	        this.fire('object:modified', { target: target });
	        target.fire('modified');
	      }
	
	      this._restoreOriginXY(target);
	    },
	
	    /**
	     * @private
	     * @param {Object} target Object to restore
	     */
	    _restoreOriginXY: function(target) {
	      if (this._previousOriginX && this._previousOriginY) {
	
	        var originPoint = target.translateToOriginPoint(
	          target.getCenterPoint(),
	          this._previousOriginX,
	          this._previousOriginY);
	
	        target.originX = this._previousOriginX;
	        target.originY = this._previousOriginY;
	
	        target.left = originPoint.x;
	        target.top = originPoint.y;
	
	        this._previousOriginX = null;
	        this._previousOriginY = null;
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    _onMouseDownInDrawingMode: function(e) {
	      this._isCurrentlyDrawing = true;
	      this.discardActiveObject(e).renderAll();
	      if (this.clipTo) {
	        fabric.util.clipContext(this, this.contextTop);
	      }
	      var ivt = fabric.util.invertTransform(this.viewportTransform),
	          pointer = fabric.util.transformPoint(this.getPointer(e, true), ivt);
	      this.freeDrawingBrush.onMouseDown(pointer);
	      this.fire('mouse:down', { e: e });
	
	      var target = this.findTarget(e);
	      if (typeof target !== 'undefined') {
	        target.fire('mousedown', { e: e, target: target });
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mousemove
	     */
	    _onMouseMoveInDrawingMode: function(e) {
	      if (this._isCurrentlyDrawing) {
	        var ivt = fabric.util.invertTransform(this.viewportTransform),
	            pointer = fabric.util.transformPoint(this.getPointer(e, true), ivt);
	        this.freeDrawingBrush.onMouseMove(pointer);
	      }
	      this.setCursor(this.freeDrawingCursor);
	      this.fire('mouse:move', { e: e });
	
	      var target = this.findTarget(e);
	      if (typeof target !== 'undefined') {
	        target.fire('mousemove', { e: e, target: target });
	      }
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object fired on mouseup
	     */
	    _onMouseUpInDrawingMode: function(e) {
	      this._isCurrentlyDrawing = false;
	      if (this.clipTo) {
	        this.contextTop.restore();
	      }
	      this.freeDrawingBrush.onMouseUp();
	      this.fire('mouse:up', { e: e });
	
	      var target = this.findTarget(e);
	      if (typeof target !== 'undefined') {
	        target.fire('mouseup', { e: e, target: target });
	      }
	    },
	
	    /**
	     * Method that defines the actions when mouse is clic ked on canvas.
	     * The method inits the currentTransform parameters and renders all the
	     * canvas so the current image can be placed on the top canvas and the rest
	     * in on the container one.
	     * @private
	     * @param {Event} e Event object fired on mousedown
	     */
	    __onMouseDown: function (e) {
	
	      // accept only left clicks
	      var isLeftClick  = 'which' in e ? e.which === 1 : e.button === 1;
	      if (!isLeftClick && !fabric.isTouchSupported) {
	        return;
	      }
	
	      if (this.isDrawingMode) {
	        this._onMouseDownInDrawingMode(e);
	        return;
	      }
	
	      // ignore if some object is being transformed at this moment
	      if (this._currentTransform) {
	        return;
	      }
	
	      var target = this.findTarget(e),
	          pointer = this.getPointer(e, true);
	
	      // save pointer for check in __onMouseUp event
	      this._previousPointer = pointer;
	
	      var shouldRender = this._shouldRender(target, pointer),
	          shouldGroup = this._shouldGroup(e, target);
	
	      if (this._shouldClearSelection(e, target)) {
	        this._clearSelection(e, target, pointer);
	      }
	      else if (shouldGroup) {
	        this._handleGrouping(e, target);
	        target = this.getActiveGroup();
	      }
	
	      if (target && target.selectable && !shouldGroup) {
	        this._beforeTransform(e, target);
	        this._setupCurrentTransform(e, target);
	      }
	      // we must renderAll so that active image is placed on the top canvas
	      shouldRender && this.renderAll();
	
	      this.fire('mouse:down', { target: target, e: e });
	      target && target.fire('mousedown', { e: e });
	    },
	
	    /**
	     * @private
	     */
	    _beforeTransform: function(e, target) {
	      this.stateful && target.saveState();
	
	      // determine if it's a drag or rotate case
	      if (target._findTargetCorner(this.getPointer(e))) {
	        this.onBeforeScaleRotate(target);
	      }
	
	      if (target !== this.getActiveGroup() && target !== this.getActiveObject()) {
	        this.deactivateAll();
	        this.setActiveObject(target, e);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _clearSelection: function(e, target, pointer) {
	      this.deactivateAllWithDispatch(e);
	
	      if (target && target.selectable) {
	        this.setActiveObject(target, e);
	      }
	      else if (this.selection) {
	        this._groupSelector = {
	          ex: pointer.x,
	          ey: pointer.y,
	          top: 0,
	          left: 0
	        };
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} target Object for that origin is set to center
	     */
	    _setOriginToCenter: function(target) {
	      this._previousOriginX = this._currentTransform.target.originX;
	      this._previousOriginY = this._currentTransform.target.originY;
	
	      var center = target.getCenterPoint();
	
	      target.originX = 'center';
	      target.originY = 'center';
	
	      target.left = center.x;
	      target.top = center.y;
	
	      this._currentTransform.left = target.left;
	      this._currentTransform.top = target.top;
	    },
	
	    /**
	     * @private
	     * @param {Object} target Object for that center is set to origin
	     */
	    _setCenterToOrigin: function(target) {
	      var originPoint = target.translateToOriginPoint(
	        target.getCenterPoint(),
	        this._previousOriginX,
	        this._previousOriginY);
	
	      target.originX = this._previousOriginX;
	      target.originY = this._previousOriginY;
	
	      target.left = originPoint.x;
	      target.top = originPoint.y;
	
	      this._previousOriginX = null;
	      this._previousOriginY = null;
	    },
	
	    /**
	     * Method that defines the actions when mouse is hovering the canvas.
	     * The currentTransform parameter will definde whether the user is rotating/scaling/translating
	     * an image or neither of them (only hovering). A group selection is also possible and would cancel
	     * all any other type of action.
	     * In case of an image transformation only the top canvas will be rendered.
	     * @private
	     * @param {Event} e Event object fired on mousemove
	     */
	    __onMouseMove: function (e) {
	
	      var target, pointer;
	
	      if (this.isDrawingMode) {
	        this._onMouseMoveInDrawingMode(e);
	        return;
	      }
	      if (typeof e.touches !== 'undefined' && e.touches.length > 1) {
	        return;
	      }
	
	      var groupSelector = this._groupSelector;
	
	      // We initially clicked in an empty area, so we draw a box for multiple selection
	      if (groupSelector) {
	        pointer = this.getPointer(e, true);
	
	        groupSelector.left = pointer.x - groupSelector.ex;
	        groupSelector.top = pointer.y - groupSelector.ey;
	
	        this.renderTop();
	      }
	      else if (!this._currentTransform) {
	
	        target = this.findTarget(e);
	
	        if (!target || target && !target.selectable) {
	          this.setCursor(this.defaultCursor);
	        }
	        else {
	          this._setCursorFromEvent(e, target);
	        }
	      }
	      else {
	        this._transformObject(e);
	      }
	
	      this.fire('mouse:move', { target: target, e: e });
	      target && target.fire('mousemove', { e: e });
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event fired on mousemove
	     */
	    _transformObject: function(e) {
	      var pointer = this.getPointer(e),
	          transform = this._currentTransform;
	
	      transform.reset = false,
	      transform.target.isMoving = true;
	
	      this._beforeScaleTransform(e, transform);
	      this._performTransformAction(e, transform, pointer);
	
	      this.renderAll();
	    },
	
	    /**
	     * @private
	     */
	    _performTransformAction: function(e, transform, pointer) {
	      var x = pointer.x,
	          y = pointer.y,
	          target = transform.target,
	          action = transform.action;
	
	      if (action === 'rotate') {
	        this._rotateObject(x, y);
	        this._fire('rotating', target, e);
	      }
	      else if (action === 'scale') {
	        this._onScale(e, transform, x, y);
	        this._fire('scaling', target, e);
	      }
	      else if (action === 'scaleX') {
	        this._scaleObject(x, y, 'x');
	        this._fire('scaling', target, e);
	      }
	      else if (action === 'scaleY') {
	        this._scaleObject(x, y, 'y');
	        this._fire('scaling', target, e);
	      }
	      else {
	        this._translateObject(x, y);
	        this._fire('moving', target, e);
	        this.setCursor(this.moveCursor);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _fire: function(eventName, target, e) {
	      this.fire('object:' + eventName, { target: target, e: e });
	      target.fire(eventName, { e: e });
	    },
	
	    /**
	     * @private
	     */
	    _beforeScaleTransform: function(e, transform) {
	      if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {
	        var centerTransform = this._shouldCenterTransform(e, transform.target);
	
	        // Switch from a normal resize to center-based
	        if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||
	           // Switch from center-based resize to normal one
	           (!centerTransform && transform.originX === 'center' && transform.originY === 'center')
	        ) {
	          this._resetCurrentTransform(e);
	          transform.reset = true;
	        }
	      }
	    },
	
	    /**
	     * @private
	     */
	    _onScale: function(e, transform, x, y) {
	      // rotate object only if shift key is not pressed
	      // and if it is not a group we are transforming
	      if ((e.shiftKey || this.uniScaleTransform) && !transform.target.get('lockUniScaling')) {
	        transform.currentAction = 'scale';
	        this._scaleObject(x, y);
	      }
	      else {
	        // Switch from a normal resize to proportional
	        if (!transform.reset && transform.currentAction === 'scale') {
	          this._resetCurrentTransform(e, transform.target);
	        }
	
	        transform.currentAction = 'scaleEqually';
	        this._scaleObject(x, y, 'equally');
	      }
	    },
	
	    /**
	     * Sets the cursor depending on where the canvas is being hovered.
	     * Note: very buggy in Opera
	     * @param {Event} e Event object
	     * @param {Object} target Object that the mouse is hovering, if so.
	     */
	    _setCursorFromEvent: function (e, target) {
	      if (!target || !target.selectable) {
	        this.setCursor(this.defaultCursor);
	        return false;
	      }
	      else {
	        var activeGroup = this.getActiveGroup(),
	            // only show proper corner when group selection is not active
	            corner = target._findTargetCorner
	                      && (!activeGroup || !activeGroup.contains(target))
	                      && target._findTargetCorner(this.getPointer(e, true));
	
	        if (!corner) {
	          this.setCursor(target.hoverCursor || this.hoverCursor);
	        }
	        else {
	          this._setCornerCursor(corner, target);
	        }
	      }
	      return true;
	    },
	
	    /**
	     * @private
	     */
	    _setCornerCursor: function(corner, target) {
	      if (corner in cursorOffset) {
	        this.setCursor(this._getRotatedCornerCursor(corner, target));
	      }
	      else if (corner === 'mtr' && target.hasRotatingPoint) {
	        this.setCursor(this.rotationCursor);
	      }
	      else {
	        this.setCursor(this.defaultCursor);
	        return false;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _getRotatedCornerCursor: function(corner, target) {
	      var n = Math.round((target.getAngle() % 360) / 45);
	
	      if (n < 0) {
	        n += 8; // full circle ahead
	      }
	      n += cursorOffset[corner];
	      // normalize n to be from 0 to 7
	      n %= 8;
	
	      return this.cursorMap[n];
	    }
	  });
	})();
	
	
	(function() {
	
	  var min = Math.min,
	      max = Math.max;
	
	  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     * @return {Boolean}
	     */
	    _shouldGroup: function(e, target) {
	      var activeObject = this.getActiveObject();
	      return e.shiftKey &&
	            (this.getActiveGroup() || (activeObject && activeObject !== target))
	            && this.selection;
	    },
	
	    /**
	     * @private
	     * @param {Event} e Event object
	     * @param {fabric.Object} target
	     */
	    _handleGrouping: function (e, target) {
	
	      if (target === this.getActiveGroup()) {
	
	        // if it's a group, find target again, this time skipping group
	        target = this.findTarget(e, true);
	
	        // if even object is not found, bail out
	        if (!target || target.isType('group')) {
	          return;
	        }
	      }
	      if (this.getActiveGroup()) {
	        this._updateActiveGroup(target, e);
	      }
	      else {
	        this._createActiveGroup(target, e);
	      }
	
	      if (this._activeGroup) {
	        this._activeGroup.saveCoords();
	      }
	    },
	
	    /**
	     * @private
	     */
	    _updateActiveGroup: function(target, e) {
	      var activeGroup = this.getActiveGroup();
	
	      if (activeGroup.contains(target)) {
	
	        activeGroup.removeWithUpdate(target);
	        this._resetObjectTransform(activeGroup);
	        target.set('active', false);
	
	        if (activeGroup.size() === 1) {
	          // remove group alltogether if after removal it only contains 1 object
	          this.discardActiveGroup(e);
	          // activate last remaining object
	          this.setActiveObject(activeGroup.item(0));
	          return;
	        }
	      }
	      else {
	        activeGroup.addWithUpdate(target);
	        this._resetObjectTransform(activeGroup);
	      }
	      this.fire('selection:created', { target: activeGroup, e: e });
	      activeGroup.set('active', true);
	    },
	
	    /**
	     * @private
	     */
	    _createActiveGroup: function(target, e) {
	
	      if (this._activeObject && target !== this._activeObject) {
	
	        var group = this._createGroup(target);
	        group.addWithUpdate();
	
	        this.setActiveGroup(group);
	        this._activeObject = null;
	
	        this.fire('selection:created', { target: group, e: e });
	      }
	
	      target.set('active', true);
	    },
	
	    /**
	     * @private
	     * @param {Object} target
	     */
	    _createGroup: function(target) {
	
	      var objects = this.getObjects(),
	          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
	          groupObjects = isActiveLower
	            ? [ this._activeObject, target ]
	            : [ target, this._activeObject ];
	
	      return new fabric.Group(groupObjects, {
	        canvas: this
	      });
	    },
	
	    /**
	     * @private
	     * @param {Event} e mouse event
	     */
	    _groupSelectedObjects: function (e) {
	
	      var group = this._collectObjects();
	
	      // do not create group for 1 element only
	      if (group.length === 1) {
	        this.setActiveObject(group[0], e);
	      }
	      else if (group.length > 1) {
	        group = new fabric.Group(group.reverse(), {
	          canvas: this
	        });
	        group.addWithUpdate();
	        this.setActiveGroup(group, e);
	        group.saveCoords();
	        this.fire('selection:created', { target: group });
	        this.renderAll();
	      }
	    },
	
	    /**
	     * @private
	     */
	    _collectObjects: function() {
	      var group = [ ],
	          currentObject,
	          x1 = this._groupSelector.ex,
	          y1 = this._groupSelector.ey,
	          x2 = x1 + this._groupSelector.left,
	          y2 = y1 + this._groupSelector.top,
	          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
	          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
	          isClick = x1 === x2 && y1 === y2;
	
	      for (var i = this._objects.length; i--; ) {
	        currentObject = this._objects[i];
	
	        if (!currentObject || !currentObject.selectable || !currentObject.visible) {
	          continue;
	        }
	
	        if (currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2) ||
	            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||
	            currentObject.containsPoint(selectionX1Y1) ||
	            currentObject.containsPoint(selectionX2Y2)
	        ) {
	          currentObject.set('active', true);
	          group.push(currentObject);
	
	          // only add one object if it's a click
	          if (isClick) {
	            break;
	          }
	        }
	      }
	
	      return group;
	    },
	
	    /**
	     * @private
	     */
	    _maybeGroupObjects: function(e) {
	      if (this.selection && this._groupSelector) {
	        this._groupSelectedObjects(e);
	      }
	
	      var activeGroup = this.getActiveGroup();
	      if (activeGroup) {
	        activeGroup.setObjectsCoords().setCoords();
	        activeGroup.isMoving = false;
	        this.setCursor(this.defaultCursor);
	      }
	
	      // clear selection and current transformation
	      this._groupSelector = null;
	      this._currentTransform = null;
	    }
	  });
	
	})();
	
	
	fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	  /**
	   * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
	   * @param {Object} [options] Options object
	   * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
	   * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
	   * @param {Number} [options.multiplier=1] Multiplier to scale by
	   * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
	   * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
	   * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
	   * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
	   * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
	   * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
	   * @example <caption>Generate jpeg dataURL with lower quality</caption>
	   * var dataURL = canvas.toDataURL({
	   *   format: 'jpeg',
	   *   quality: 0.8
	   * });
	   * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
	   * var dataURL = canvas.toDataURL({
	   *   format: 'png',
	   *   left: 100,
	   *   top: 100,
	   *   width: 200,
	   *   height: 200
	   * });
	   * @example <caption>Generate double scaled png dataURL</caption>
	   * var dataURL = canvas.toDataURL({
	   *   format: 'png',
	   *   multiplier: 2
	   * });
	   */
	  toDataURL: function (options) {
	    options || (options = { });
	
	    var format = options.format || 'png',
	        quality = options.quality || 1,
	        multiplier = options.multiplier || 1,
	        cropping = {
	          left: options.left,
	          top: options.top,
	          width: options.width,
	          height: options.height
	        };
	
	    if (multiplier !== 1) {
	      return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);
	    }
	    else {
	      return this.__toDataURL(format, quality, cropping);
	    }
	  },
	
	  /**
	   * @private
	   */
	  __toDataURL: function(format, quality, cropping) {
	
	    this.renderAll(true);
	
	    var canvasEl = this.upperCanvasEl || this.lowerCanvasEl,
	        croppedCanvasEl = this.__getCroppedCanvas(canvasEl, cropping);
	
	    // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
	    if (format === 'jpg') {
	      format = 'jpeg';
	    }
	
	    var data = (fabric.StaticCanvas.supports('toDataURLWithQuality'))
	              ? (croppedCanvasEl || canvasEl).toDataURL('image/' + format, quality)
	              : (croppedCanvasEl || canvasEl).toDataURL('image/' + format);
	
	    this.contextTop && this.clearContext(this.contextTop);
	    this.renderAll();
	
	    if (croppedCanvasEl) {
	      croppedCanvasEl = null;
	    }
	
	    return data;
	  },
	
	  /**
	   * @private
	   */
	  __getCroppedCanvas: function(canvasEl, cropping) {
	
	    var croppedCanvasEl,
	        croppedCtx,
	        shouldCrop = 'left' in cropping ||
	                     'top' in cropping ||
	                     'width' in cropping ||
	                     'height' in cropping;
	
	    if (shouldCrop) {
	
	      croppedCanvasEl = fabric.util.createCanvasElement();
	      croppedCtx = croppedCanvasEl.getContext('2d');
	
	      croppedCanvasEl.width = cropping.width || this.width;
	      croppedCanvasEl.height = cropping.height || this.height;
	
	      croppedCtx.drawImage(canvasEl, -cropping.left || 0, -cropping.top || 0);
	    }
	
	    return croppedCanvasEl;
	  },
	
	  /**
	   * @private
	   */
	  __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {
	
	    var origWidth = this.getWidth(),
	        origHeight = this.getHeight(),
	        scaledWidth = origWidth * multiplier,
	        scaledHeight = origHeight * multiplier,
	        activeObject = this.getActiveObject(),
	        activeGroup = this.getActiveGroup(),
	
	        ctx = this.contextTop || this.contextContainer;
	
	    if (multiplier > 1) {
	      this.setWidth(scaledWidth).setHeight(scaledHeight);
	    }
	    ctx.scale(multiplier, multiplier);
	
	    if (cropping.left) {
	      cropping.left *= multiplier;
	    }
	    if (cropping.top) {
	      cropping.top *= multiplier;
	    }
	    if (cropping.width) {
	      cropping.width *= multiplier;
	    }
	    else if (multiplier < 1) {
	      cropping.width = scaledWidth;
	    }
	    if (cropping.height) {
	      cropping.height *= multiplier;
	    }
	    else if (multiplier < 1) {
	      cropping.height = scaledHeight;
	    }
	
	    if (activeGroup) {
	      // not removing group due to complications with restoring it with correct state afterwords
	      this._tempRemoveBordersControlsFromGroup(activeGroup);
	    }
	    else if (activeObject && this.deactivateAll) {
	      this.deactivateAll();
	    }
	
	    this.renderAll(true);
	
	    var data = this.__toDataURL(format, quality, cropping);
	
	    // restoring width, height for `renderAll` to draw
	    // background properly (while context is scaled)
	    this.width = origWidth;
	    this.height = origHeight;
	
	    ctx.scale(1 / multiplier,  1 / multiplier);
	    this.setWidth(origWidth).setHeight(origHeight);
	
	    if (activeGroup) {
	      this._restoreBordersControlsOnGroup(activeGroup);
	    }
	    else if (activeObject && this.setActiveObject) {
	      this.setActiveObject(activeObject);
	    }
	
	    this.contextTop && this.clearContext(this.contextTop);
	    this.renderAll();
	
	    return data;
	  },
	
	  /**
	   * Exports canvas element to a dataurl image (allowing to change image size via multiplier).
	   * @deprecated since 1.0.13
	   * @param {String} format (png|jpeg)
	   * @param {Number} multiplier
	   * @param {Number} quality (0..1)
	   * @return {String}
	   */
	  toDataURLWithMultiplier: function (format, multiplier, quality) {
	    return this.toDataURL({
	      format: format,
	      multiplier: multiplier,
	      quality: quality
	    });
	  },
	
	  /**
	   * @private
	   */
	  _tempRemoveBordersControlsFromGroup: function(group) {
	    group.origHasControls = group.hasControls;
	    group.origBorderColor = group.borderColor;
	
	    group.hasControls = true;
	    group.borderColor = 'rgba(0,0,0,0)';
	
	    group.forEachObject(function(o) {
	      o.origBorderColor = o.borderColor;
	      o.borderColor = 'rgba(0,0,0,0)';
	    });
	  },
	
	  /**
	   * @private
	   */
	  _restoreBordersControlsOnGroup: function(group) {
	    group.hideControls = group.origHideControls;
	    group.borderColor = group.origBorderColor;
	
	    group.forEachObject(function(o) {
	      o.borderColor = o.origBorderColor;
	      delete o.origBorderColor;
	    });
	  }
	});
	
	
	fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	  /**
	   * Populates canvas with data from the specified dataless JSON.
	   * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}
	   * @deprecated since 1.2.2
	   * @param {String|Object} json JSON string or object
	   * @param {Function} callback Callback, invoked when json is parsed
	   *                            and corresponding objects (e.g: {@link fabric.Image})
	   *                            are initialized
	   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
	   * @return {fabric.Canvas} instance
	   * @chainable
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#deserialization}
	   */
	  loadFromDatalessJSON: function (json, callback, reviver) {
	    return this.loadFromJSON(json, callback, reviver);
	  },
	
	  /**
	   * Populates canvas with data from the specified JSON.
	   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
	   * @param {String|Object} json JSON string or object
	   * @param {Function} callback Callback, invoked when json is parsed
	   *                            and corresponding objects (e.g: {@link fabric.Image})
	   *                            are initialized
	   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
	   * @return {fabric.Canvas} instance
	   * @chainable
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#deserialization}
	   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
	   * @example <caption>loadFromJSON</caption>
	   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
	   * @example <caption>loadFromJSON with reviver</caption>
	   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
	   *   // `o` = json object
	   *   // `object` = fabric.Object instance
	   *   // ... do some stuff ...
	   * });
	   */
	  loadFromJSON: function (json, callback, reviver) {
	    if (!json) {
	      return;
	    }
	
	    // serialize if it wasn't already
	    var serialized = (typeof json === 'string')
	      ? JSON.parse(json)
	      : json;
	
	    this.clear();
	
	    var _this = this;
	    this._enlivenObjects(serialized.objects, function () {
	      _this._setBgOverlay(serialized, callback);
	    }, reviver);
	
	    return this;
	  },
	
	  /**
	   * @private
	   * @param {Object} serialized Object with background and overlay information
	   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
	   */
	  _setBgOverlay: function(serialized, callback) {
	    var _this = this,
	        loaded = {
	          backgroundColor: false,
	          overlayColor: false,
	          backgroundImage: false,
	          overlayImage: false
	        };
	
	    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
	      callback && callback();
	      return;
	    }
	
	    var cbIfLoaded = function () {
	      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
	        _this.renderAll();
	        callback && callback();
	      }
	    };
	
	    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
	    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
	    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
	    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
	
	    cbIfLoaded();
	  },
	
	  /**
	   * @private
	   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
	   * @param {(Object|String)} value Value to set
	   * @param {Object} loaded Set loaded property to true if property is set
	   * @param {Object} callback Callback function to invoke after property is set
	   */
	  __setBgOverlay: function(property, value, loaded, callback) {
	    var _this = this;
	
	    if (!value) {
	      loaded[property] = true;
	      return;
	    }
	
	    if (property === 'backgroundImage' || property === 'overlayImage') {
	      fabric.Image.fromObject(value, function(img) {
	        _this[property] = img;
	        loaded[property] = true;
	        callback && callback();
	      });
	    }
	    else {
	      this['set' + fabric.util.string.capitalize(property, true)](value, function() {
	        loaded[property] = true;
	        callback && callback();
	      });
	    }
	  },
	
	  /**
	   * @private
	   * @param {Array} objects
	   * @param {Function} callback
	   * @param {Function} [reviver]
	   */
	  _enlivenObjects: function (objects, callback, reviver) {
	    var _this = this;
	
	    if (!objects || objects.length === 0) {
	      callback && callback();
	      return;
	    }
	
	    var renderOnAddRemove = this.renderOnAddRemove;
	    this.renderOnAddRemove = false;
	
	    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
	      enlivenedObjects.forEach(function(obj, index) {
	        _this.insertAt(obj, index, true);
	      });
	
	      _this.renderOnAddRemove = renderOnAddRemove;
	      callback && callback();
	    }, null, reviver);
	  },
	
	  /**
	   * @private
	   * @param {String} format
	   * @param {Function} callback
	   */
	  _toDataURL: function (format, callback) {
	    this.clone(function (clone) {
	      callback(clone.toDataURL(format));
	    });
	  },
	
	  /**
	   * @private
	   * @param {String} format
	   * @param {Number} multiplier
	   * @param {Function} callback
	   */
	  _toDataURLWithMultiplier: function (format, multiplier, callback) {
	    this.clone(function (clone) {
	      callback(clone.toDataURLWithMultiplier(format, multiplier));
	    });
	  },
	
	  /**
	   * Clones canvas instance
	   * @param {Object} [callback] Receives cloned instance as a first argument
	   * @param {Array} [properties] Array of properties to include in the cloned canvas and children
	   */
	  clone: function (callback, properties) {
	    var data = JSON.stringify(this.toJSON(properties));
	    this.cloneWithoutData(function(clone) {
	      clone.loadFromJSON(data, function() {
	        callback && callback(clone);
	      });
	    });
	  },
	
	  /**
	   * Clones canvas instance without cloning existing data.
	   * This essentially copies canvas dimensions, clipping properties, etc.
	   * but leaves data empty (so that you can populate it with your own)
	   * @param {Object} [callback] Receives cloned instance as a first argument
	   */
	  cloneWithoutData: function(callback) {
	    var el = fabric.document.createElement('canvas');
	
	    el.width = this.getWidth();
	    el.height = this.getHeight();
	
	    var clone = new fabric.Canvas(el);
	    clone.clipTo = this.clipTo;
	    if (this.backgroundImage) {
	      clone.setBackgroundImage(this.backgroundImage.src, function() {
	        clone.renderAll();
	        callback && callback(clone);
	      });
	      clone.backgroundImageOpacity = this.backgroundImageOpacity;
	      clone.backgroundImageStretch = this.backgroundImageStretch;
	    }
	    else {
	      callback && callback(clone);
	    }
	  }
	});
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      toFixed = fabric.util.toFixed,
	      capitalize = fabric.util.string.capitalize,
	      degreesToRadians = fabric.util.degreesToRadians,
	      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');
	
	  if (fabric.Object) {
	    return;
	  }
	
	  /**
	   * Root object class from which all 2d shape classes inherit from
	   * @class fabric.Object
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#objects}
	   * @see {@link fabric.Object#initialize} for constructor definition
	   *
	   * @fires added
	   * @fires removed
	   *
	   * @fires selected
	   * @fires modified
	   * @fires rotating
	   * @fires scaling
	   * @fires moving
	   *
	   * @fires mousedown
	   * @fires mouseup
	   */
	  fabric.Object = fabric.util.createClass(/** @lends fabric.Object.prototype */ {
	
	    /**
	     * Retrieves object's {@link fabric.Object#clipTo|clipping function}
	     * @method getClipTo
	     * @memberOf fabric.Object.prototype
	     * @return {Function}
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#clipTo|clipping function}
	     * @method setClipTo
	     * @memberOf fabric.Object.prototype
	     * @param {Function} clipTo Clipping function
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#transformMatrix|transformMatrix}
	     * @method getTransformMatrix
	     * @memberOf fabric.Object.prototype
	     * @return {Array} transformMatrix
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#transformMatrix|transformMatrix}
	     * @method setTransformMatrix
	     * @memberOf fabric.Object.prototype
	     * @param {Array} transformMatrix
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#visible|visible} state
	     * @method getVisible
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} True if visible
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#visible|visible} state
	     * @method setVisible
	     * @memberOf fabric.Object.prototype
	     * @param {Boolean} value visible value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#shadow|shadow}
	     * @method getShadow
	     * @memberOf fabric.Object.prototype
	     * @return {Object} Shadow instance
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#stroke|stroke}
	     * @method getStroke
	     * @memberOf fabric.Object.prototype
	     * @return {String} stroke value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#stroke|stroke}
	     * @method setStroke
	     * @memberOf fabric.Object.prototype
	     * @param {String} value stroke value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#strokeWidth|strokeWidth}
	     * @method getStrokeWidth
	     * @memberOf fabric.Object.prototype
	     * @return {Number} strokeWidth value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#strokeWidth|strokeWidth}
	     * @method setStrokeWidth
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value strokeWidth value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#originX|originX}
	     * @method getOriginX
	     * @memberOf fabric.Object.prototype
	     * @return {String} originX value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#originX|originX}
	     * @method setOriginX
	     * @memberOf fabric.Object.prototype
	     * @param {String} value originX value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#originY|originY}
	     * @method getOriginY
	     * @memberOf fabric.Object.prototype
	     * @return {String} originY value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#originY|originY}
	     * @method setOriginY
	     * @memberOf fabric.Object.prototype
	     * @param {String} value originY value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#fill|fill}
	     * @method getFill
	     * @memberOf fabric.Object.prototype
	     * @return {String} Fill value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#fill|fill}
	     * @method setFill
	     * @memberOf fabric.Object.prototype
	     * @param {String} value Fill value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#opacity|opacity}
	     * @method getOpacity
	     * @memberOf fabric.Object.prototype
	     * @return {Number} Opacity value (0-1)
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#opacity|opacity}
	     * @method setOpacity
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value Opacity value (0-1)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#angle|angle} (in degrees)
	     * @method getAngle
	     * @memberOf fabric.Object.prototype
	     * @return {Number}
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#top|top position}
	     * @method getTop
	     * @memberOf fabric.Object.prototype
	     * @return {Number} Top value (in pixels)
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#top|top position}
	     * @method setTop
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value Top value (in pixels)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#left|left position}
	     * @method getLeft
	     * @memberOf fabric.Object.prototype
	     * @return {Number} Left value (in pixels)
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#left|left position}
	     * @method setLeft
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value Left value (in pixels)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#scaleX|scaleX} value
	     * @method getScaleX
	     * @memberOf fabric.Object.prototype
	     * @return {Number} scaleX value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#scaleX|scaleX} value
	     * @method setScaleX
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value scaleX value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#scaleY|scaleY} value
	     * @method getScaleY
	     * @memberOf fabric.Object.prototype
	     * @return {Number} scaleY value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#scaleY|scaleY} value
	     * @method setScaleY
	     * @memberOf fabric.Object.prototype
	     * @param {Number} value scaleY value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#flipX|flipX} value
	     * @method getFlipX
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} flipX value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#flipX|flipX} value
	     * @method setFlipX
	     * @memberOf fabric.Object.prototype
	     * @param {Boolean} value flipX value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's {@link fabric.Object#flipY|flipY} value
	     * @method getFlipY
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} flipY value
	     */
	
	    /**
	     * Sets object's {@link fabric.Object#flipY|flipY} value
	     * @method setFlipY
	     * @memberOf fabric.Object.prototype
	     * @param {Boolean} value flipY value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	
	    /**
	     * Type of an object (rect, circle, path, etc.).
	     * Note that this property is meant to be read-only and not meant to be modified.
	     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
	     * @type String
	     * @default
	     */
	    type:                     'object',
	
	    /**
	     * Horizontal origin of transformation of an object (one of "left", "right", "center")
	     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups
	     * @type String
	     * @default
	     */
	    originX:                  'left',
	
	    /**
	     * Vertical origin of transformation of an object (one of "top", "bottom", "center")
	     * See http://jsfiddle.net/1ow02gea/40/ on how originX/originY affect objects in groups
	     * @type String
	     * @default
	     */
	    originY:                  'top',
	
	    /**
	     * Top position of an object. Note that by default it's relative to object center. You can change this by setting originY={top/center/bottom}
	     * @type Number
	     * @default
	     */
	    top:                      0,
	
	    /**
	     * Left position of an object. Note that by default it's relative to object center. You can change this by setting originX={left/center/right}
	     * @type Number
	     * @default
	     */
	    left:                     0,
	
	    /**
	     * Object width
	     * @type Number
	     * @default
	     */
	    width:                    0,
	
	    /**
	     * Object height
	     * @type Number
	     * @default
	     */
	    height:                   0,
	
	    /**
	     * Object scale factor (horizontal)
	     * @type Number
	     * @default
	     */
	    scaleX:                   1,
	
	    /**
	     * Object scale factor (vertical)
	     * @type Number
	     * @default
	     */
	    scaleY:                   1,
	
	    /**
	     * When true, an object is rendered as flipped horizontally
	     * @type Boolean
	     * @default
	     */
	    flipX:                    false,
	
	    /**
	     * When true, an object is rendered as flipped vertically
	     * @type Boolean
	     * @default
	     */
	    flipY:                    false,
	
	    /**
	     * Opacity of an object
	     * @type Number
	     * @default
	     */
	    opacity:                  1,
	
	    /**
	     * Angle of rotation of an object (in degrees)
	     * @type Number
	     * @default
	     */
	    angle:                    0,
	
	    /**
	     * Size of object's controlling corners (in pixels)
	     * @type Number
	     * @default
	     */
	    cornerSize:               12,
	
	    /**
	     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
	     * @type Boolean
	     * @default
	     */
	    transparentCorners:       true,
	
	    /**
	     * Default cursor value used when hovering over this object on canvas
	     * @type String
	     * @default
	     */
	    hoverCursor:              null,
	
	    /**
	     * Padding between object and its controlling borders (in pixels)
	     * @type Number
	     * @default
	     */
	    padding:                  0,
	
	    /**
	     * Color of controlling borders of an object (when it's active)
	     * @type String
	     * @default
	     */
	    borderColor:              'rgba(102,153,255,0.75)',
	
	    /**
	     * Color of controlling corners of an object (when it's active)
	     * @type String
	     * @default
	     */
	    cornerColor:              'rgba(102,153,255,0.5)',
	
	    /**
	     * When true, this object will use center point as the origin of transformation
	     * when being scaled via the controls.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredScaling:          false,
	
	    /**
	     * When true, this object will use center point as the origin of transformation
	     * when being rotated via the controls.
	     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
	     * @since 1.3.4
	     * @type Boolean
	     * @default
	     */
	    centeredRotation:         true,
	
	    /**
	     * Color of object's fill
	     * @type String
	     * @default
	     */
	    fill:                     'rgb(0,0,0)',
	
	    /**
	     * Fill rule used to fill an object
	     * accepted values are nonzero, evenodd
	     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
	     * @type String
	     * @default
	     */
	    fillRule:                 'nonzero',
	
	    /**
	     * Composite rule used for canvas globalCompositeOperation
	     * @type String
	     * @default
	     */
	    globalCompositeOperation: 'source-over',
	
	    /**
	     * Background color of an object. Only works with text objects at the moment.
	     * @type String
	     * @default
	     */
	    backgroundColor:          '',
	
	    /**
	     * When defined, an object is rendered via stroke and this property specifies its color
	     * @type String
	     * @default
	     */
	    stroke:                   null,
	
	    /**
	     * Width of a stroke used to render this object
	     * @type Number
	     * @default
	     */
	    strokeWidth:              1,
	
	    /**
	     * Array specifying dash pattern of an object's stroke (stroke must be defined)
	     * @type Array
	     */
	    strokeDashArray:          null,
	
	    /**
	     * Line endings style of an object's stroke (one of "butt", "round", "square")
	     * @type String
	     * @default
	     */
	    strokeLineCap:            'butt',
	
	    /**
	     * Corner style of an object's stroke (one of "bevil", "round", "miter")
	     * @type String
	     * @default
	     */
	    strokeLineJoin:           'miter',
	
	    /**
	     * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
	     * @type Number
	     * @default
	     */
	    strokeMiterLimit:         10,
	
	    /**
	     * Shadow object representing shadow of this shape
	     * @type fabric.Shadow
	     * @default
	     */
	    shadow:                   null,
	
	    /**
	     * Opacity of object's controlling borders when object is active and moving
	     * @type Number
	     * @default
	     */
	    borderOpacityWhenMoving:  0.4,
	
	    /**
	     * Scale factor of object's controlling borders
	     * @type Number
	     * @default
	     */
	    borderScaleFactor:        1,
	
	    /**
	     * Transform matrix (similar to SVG's transform matrix)
	     * @type Array
	     */
	    transformMatrix:          null,
	
	    /**
	     * Minimum allowed scale value of an object
	     * @type Number
	     * @default
	     */
	    minScaleLimit:            0.01,
	
	    /**
	     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
	     * But events still fire on it.
	     * @type Boolean
	     * @default
	     */
	    selectable:               true,
	
	    /**
	     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
	     * @type Boolean
	     * @default
	     */
	    evented:                  true,
	
	    /**
	     * When set to `false`, an object is not rendered on canvas
	     * @type Boolean
	     * @default
	     */
	    visible:                  true,
	
	    /**
	     * When set to `false`, object's controls are not displayed and can not be used to manipulate object
	     * @type Boolean
	     * @default
	     */
	    hasControls:              true,
	
	    /**
	     * When set to `false`, object's controlling borders are not rendered
	     * @type Boolean
	     * @default
	     */
	    hasBorders:               true,
	
	    /**
	     * When set to `false`, object's controlling rotating point will not be visible or selectable
	     * @type Boolean
	     * @default
	     */
	    hasRotatingPoint:         true,
	
	    /**
	     * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)
	     * @type Number
	     * @default
	     */
	    rotatingPointOffset:      40,
	
	    /**
	     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
	     * @type Boolean
	     * @default
	     */
	    perPixelTargetFind:       false,
	
	    /**
	     * When `false`, default object's values are not included in its serialization
	     * @type Boolean
	     * @default
	     */
	    includeDefaultValues:     true,
	
	    /**
	     * Function that determines clipping of an object (context is passed as a first argument)
	     * Note that context origin is at the object's center point (not left/top corner)
	     * @type Function
	     */
	    clipTo:                   null,
	
	    /**
	     * When `true`, object horizontal movement is locked
	     * @type Boolean
	     * @default
	     */
	    lockMovementX:            false,
	
	    /**
	     * When `true`, object vertical movement is locked
	     * @type Boolean
	     * @default
	     */
	    lockMovementY:            false,
	
	    /**
	     * When `true`, object rotation is locked
	     * @type Boolean
	     * @default
	     */
	    lockRotation:             false,
	
	    /**
	     * When `true`, object horizontal scaling is locked
	     * @type Boolean
	     * @default
	     */
	    lockScalingX:             false,
	
	    /**
	     * When `true`, object vertical scaling is locked
	     * @type Boolean
	     * @default
	     */
	    lockScalingY:             false,
	
	    /**
	     * When `true`, object non-uniform scaling is locked
	     * @type Boolean
	     * @default
	     */
	    lockUniScaling:           false,
	
	    /**
	     * When `true`, object cannot be flipped by scaling into negative values
	     * @type Boolean
	     * @default
	     */
	
	    lockScalingFlip:          false,
	    /**
	     * List of properties to consider when checking if state
	     * of an object is changed (fabric.Object#hasStateChanged)
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties:  (
	      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
	      'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' +
	      'angle opacity fill fillRule globalCompositeOperation shadow clipTo visible backgroundColor ' +
	      'alignX alignY meetOrSlice'
	    ).split(' '),
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     */
	    initialize: function(options) {
	      if (options) {
	        this.setOptions(options);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initGradient: function(options) {
	      if (options.fill && options.fill.colorStops && !(options.fill instanceof fabric.Gradient)) {
	        this.set('fill', new fabric.Gradient(options.fill));
	      }
	      if (options.stroke && options.stroke.colorStops && !(options.stroke instanceof fabric.Gradient)) {
	        this.set('stroke', new fabric.Gradient(options.stroke));
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initPattern: function(options) {
	      if (options.fill && options.fill.source && !(options.fill instanceof fabric.Pattern)) {
	        this.set('fill', new fabric.Pattern(options.fill));
	      }
	      if (options.stroke && options.stroke.source && !(options.stroke instanceof fabric.Pattern)) {
	        this.set('stroke', new fabric.Pattern(options.stroke));
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initClipping: function(options) {
	      if (!options.clipTo || typeof options.clipTo !== 'string') {
	        return;
	      }
	
	      var functionBody = fabric.util.getFunctionBody(options.clipTo);
	      if (typeof functionBody !== 'undefined') {
	        this.clipTo = new Function('ctx', functionBody);
	      }
	    },
	
	    /**
	     * Sets object's properties from options
	     * @param {Object} [options] Options object
	     */
	    setOptions: function(options) {
	      for (var prop in options) {
	        this.set(prop, options[prop]);
	      }
	      this._initGradient(options);
	      this._initPattern(options);
	      this._initClipping(options);
	    },
	
	    /**
	     * Transforms context when rendering an object
	     * @param {CanvasRenderingContext2D} ctx Context
	     * @param {Boolean} fromLeft When true, context is transformed to object's top/left corner. This is used when rendering text on Node
	     */
	    transform: function(ctx, fromLeft) {
	      if (this.group && this.canvas.preserveObjectStacking && this.group === this.canvas._activeGroup) {
	        this.group.transform(ctx);
	      }
	      var center = fromLeft ? this._getLeftTopCoords() : this.getCenterPoint();
	      ctx.translate(center.x, center.y);
	      ctx.rotate(degreesToRadians(this.angle));
	      ctx.scale(
	        this.scaleX * (this.flipX ? -1 : 1),
	        this.scaleY * (this.flipY ? -1 : 1)
	      );
	    },
	
	    /**
	     * Returns an object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	
	          object = {
	            type:                     this.type,
	            originX:                  this.originX,
	            originY:                  this.originY,
	            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
	            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
	            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
	            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
	            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
	            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
	            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
	            strokeDashArray:          this.strokeDashArray,
	            strokeLineCap:            this.strokeLineCap,
	            strokeLineJoin:           this.strokeLineJoin,
	            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
	            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
	            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
	            angle:                    toFixed(this.getAngle(), NUM_FRACTION_DIGITS),
	            flipX:                    this.flipX,
	            flipY:                    this.flipY,
	            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
	            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
	            visible:                  this.visible,
	            clipTo:                   this.clipTo && String(this.clipTo),
	            backgroundColor:          this.backgroundColor,
	            fillRule:                 this.fillRule,
	            globalCompositeOperation: this.globalCompositeOperation,
	            transformMatrix:          this.transformMatrix
	          };
	
	      if (!this.includeDefaultValues) {
	        object = this._removeDefaultValues(object);
	      }
	
	      fabric.util.populateWithProperties(this, object, propertiesToInclude);
	
	      return object;
	    },
	
	    /**
	     * Returns (dataless) object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toDatalessObject: function(propertiesToInclude) {
	      // will be overwritten by subclasses
	      return this.toObject(propertiesToInclude);
	    },
	
	    /**
	     * @private
	     * @param {Object} object
	     */
	    _removeDefaultValues: function(object) {
	      var prototype = fabric.util.getKlass(object.type).prototype,
	          stateProperties = prototype.stateProperties;
	
	      stateProperties.forEach(function(prop) {
	        if (object[prop] === prototype[prop]) {
	          delete object[prop];
	        }
	        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
	                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';
	
	        // basically a check for [] === []
	        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
	          delete object[prop];
	        }
	      });
	
	      return object;
	    },
	
	    /**
	     * Returns a string representation of an instance
	     * @return {String}
	     */
	    toString: function() {
	      return '#<fabric.' + capitalize(this.type) + '>';
	    },
	
	    /**
	     * Basic getter
	     * @param {String} property Property name
	     * @return {Any} value of a property
	     */
	    get: function(property) {
	      return this[property];
	    },
	
	    /**
	     * @private
	     */
	    _setObject: function(obj) {
	      for (var prop in obj) {
	        this._set(prop, obj[prop]);
	      }
	    },
	
	    /**
	     * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
	     * @param {String|Object} key Property name or object (if object, iterate over the object properties)
	     * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    set: function(key, value) {
	      if (typeof key === 'object') {
	        this._setObject(key);
	      }
	      else {
	        if (typeof value === 'function' && key !== 'clipTo') {
	          this._set(key, value(this.get(key)));
	        }
	        else {
	          this._set(key, value);
	        }
	      }
	      return this;
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {Any} value
	     * @return {fabric.Object} thisArg
	     */
	    _set: function(key, value) {
	      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY');
	
	      if (shouldConstrainValue) {
	        value = this._constrainScale(value);
	      }
	      if (key === 'scaleX' && value < 0) {
	        this.flipX = !this.flipX;
	        value *= -1;
	      }
	      else if (key === 'scaleY' && value < 0) {
	        this.flipY = !this.flipY;
	        value *= -1;
	      }
	      else if (key === 'width' || key === 'height') {
	        this.minScaleLimit = toFixed(Math.min(0.1, 1/Math.max(this.width, this.height)), 2);
	      }
	      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
	        value = new fabric.Shadow(value);
	      }
	
	      this[key] = value;
	
	      return this;
	    },
	
	    /**
	     * This callback function is called by the parent group of an object every
	     * time a non-delegated property changes on the group. It is passed the key
	     * and value as parameters. Not adding in this function's signature to avoid
	     * Travis build error about unused variables.
	     */
	    setOnGroup: function() {
	      // implemented by sub-classes, as needed.
	    },
	
	    /**
	     * Toggles specified property from `true` to `false` or from `false` to `true`
	     * @param {String} property Property to toggle
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    toggle: function(property) {
	      var value = this.get(property);
	      if (typeof value === 'boolean') {
	        this.set(property, !value);
	      }
	      return this;
	    },
	
	    /**
	     * Sets sourcePath of an object
	     * @param {String} value Value to set sourcePath to
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setSourcePath: function(value) {
	      this.sourcePath = value;
	      return this;
	    },
	
	    /**
	     * Retrieves viewportTransform from Object's canvas if possible
	     * @method getViewportTransform
	     * @memberOf fabric.Object.prototype
	     * @return {Boolean} flipY value // TODO
	     */
	    getViewportTransform: function() {
	      if (this.canvas && this.canvas.viewportTransform) {
	        return this.canvas.viewportTransform;
	      }
	      return [1, 0, 0, 1, 0, 0];
	    },
	
	    /**
	     * Renders an object on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    render: function(ctx, noTransform) {
	      // do not render if width/height are zeros or object is not visible
	      if ((this.width === 0 && this.height === 0) || !this.visible) {
	        return;
	      }
	
	      ctx.save();
	
	      //setup fill rule for current object
	      this._setupCompositeOperation(ctx);
	      if (!noTransform) {
	        this.transform(ctx);
	      }
	      this._setStrokeStyles(ctx);
	      this._setFillStyles(ctx);
	      if (this.transformMatrix) {
	        ctx.transform.apply(ctx, this.transformMatrix);
	      }
	      this._setOpacity(ctx);
	      this._setShadow(ctx);
	      this.clipTo && fabric.util.clipContext(this, ctx);
	      this._render(ctx, noTransform);
	      this.clipTo && ctx.restore();
	
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _setOpacity: function(ctx) {
	      if (this.group) {
	        this.group._setOpacity(ctx);
	      }
	      ctx.globalAlpha *= this.opacity;
	    },
	
	    _setStrokeStyles: function(ctx) {
	      if (this.stroke) {
	        ctx.lineWidth = this.strokeWidth;
	        ctx.lineCap = this.strokeLineCap;
	        ctx.lineJoin = this.strokeLineJoin;
	        ctx.miterLimit = this.strokeMiterLimit;
	        ctx.strokeStyle = this.stroke.toLive
	          ? this.stroke.toLive(ctx, this)
	          : this.stroke;
	      }
	    },
	
	    _setFillStyles: function(ctx) {
	      if (this.fill) {
	        ctx.fillStyle = this.fill.toLive
	          ? this.fill.toLive(ctx, this)
	          : this.fill;
	      }
	    },
	
	    /**
	     * Renders controls and borders for the object
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _renderControls: function(ctx, noTransform) {
	      if (!this.active || noTransform) {
	        return;
	      }
	      var vpt = this.getViewportTransform();
	      ctx.save();
	      var center;
	      if (this.group) {
	        center = fabric.util.transformPoint(this.group.getCenterPoint(), vpt);
	        ctx.translate(center.x, center.y);
	        ctx.rotate(degreesToRadians(this.group.angle));
	      }
	      center = fabric.util.transformPoint(this.getCenterPoint(), vpt, null != this.group);
	      if (this.group) {
	        center.x *= this.group.scaleX;
	        center.y *= this.group.scaleY;
	      }
	      ctx.translate(center.x, center.y);
	      ctx.rotate(degreesToRadians(this.angle));
	      this.drawBorders(ctx);
	      this.drawControls(ctx);
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _setShadow: function(ctx) {
	      if (!this.shadow) {
	        return;
	      }
	
	      var multX = (this.canvas && this.canvas.viewportTransform[0]) || 1,
	          multY = (this.canvas && this.canvas.viewportTransform[3]) || 1;
	
	      ctx.shadowColor = this.shadow.color;
	      ctx.shadowBlur = this.shadow.blur * (multX + multY) * (this.scaleX + this.scaleY) / 4;
	      ctx.shadowOffsetX = this.shadow.offsetX * multX * this.scaleX;
	      ctx.shadowOffsetY = this.shadow.offsetY * multY * this.scaleY;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _removeShadow: function(ctx) {
	      if (!this.shadow) {
	        return;
	      }
	
	      ctx.shadowColor = '';
	      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderFill: function(ctx) {
	      if (!this.fill) {
	        return;
	      }
	
	      ctx.save();
	      if (this.fill.gradientTransform) {
	        var g = this.fill.gradientTransform;
	        ctx.transform.apply(ctx, g);
	      }
	      if (this.fill.toLive) {
	        ctx.translate(
	          -this.width / 2 + this.fill.offsetX || 0,
	          -this.height / 2 + this.fill.offsetY || 0);
	      }
	      if (this.fillRule === 'evenodd') {
	        ctx.fill('evenodd');
	      }
	      else {
	        ctx.fill();
	      }
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderStroke: function(ctx) {
	      if (!this.stroke || this.strokeWidth === 0) {
	        return;
	      }
	
	      if (this.shadow && !this.shadow.affectStroke) {
	        this._removeShadow(ctx);
	      }
	
	      ctx.save();
	
	      if (this.strokeDashArray) {
	        // Spec requires the concatenation of two copies the dash list when the number of elements is odd
	        if (1 & this.strokeDashArray.length) {
	          this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);
	        }
	        if (supportsLineDash) {
	          ctx.setLineDash(this.strokeDashArray);
	          this._stroke && this._stroke(ctx);
	        }
	        else {
	          this._renderDashedStroke && this._renderDashedStroke(ctx);
	        }
	        ctx.stroke();
	      }
	      else {
	        if (this.stroke.gradientTransform) {
	          var g = this.stroke.gradientTransform;
	          ctx.transform.apply(ctx, g);
	        }
	        this._stroke ? this._stroke(ctx) : ctx.stroke();
	      }
	      ctx.restore();
	    },
	
	    /**
	     * Clones an instance
	     * @param {Function} callback Callback is invoked with a clone as a first argument
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {fabric.Object} clone of an instance
	     */
	    clone: function(callback, propertiesToInclude) {
	      if (this.constructor.fromObject) {
	        return this.constructor.fromObject(this.toObject(propertiesToInclude), callback);
	      }
	      return new fabric.Object(this.toObject(propertiesToInclude));
	    },
	
	    /**
	     * Creates an instance of fabric.Image out of an object
	     * @param {Function} callback callback, invoked with an instance as a first argument
	     * @return {fabric.Object} thisArg
	     */
	    cloneAsImage: function(callback) {
	      var dataUrl = this.toDataURL();
	      fabric.util.loadImage(dataUrl, function(img) {
	        if (callback) {
	          callback(new fabric.Image(img));
	        }
	      });
	      return this;
	    },
	
	    /**
	     * Converts an object into a data-url-like string
	     * @param {Object} options Options object
	     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
	     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
	     * @param {Number} [options.multiplier=1] Multiplier to scale by
	     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
	     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
	     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
	     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
	     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
	     */
	    toDataURL: function(options) {
	      options || (options = { });
	
	      var el = fabric.util.createCanvasElement(),
	          boundingRect = this.getBoundingRect();
	
	      el.width = boundingRect.width;
	      el.height = boundingRect.height;
	
	      fabric.util.wrapElement(el, 'div');
	      var canvas = new fabric.StaticCanvas(el);
	
	      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
	      if (options.format === 'jpg') {
	        options.format = 'jpeg';
	      }
	
	      if (options.format === 'jpeg') {
	        canvas.backgroundColor = '#fff';
	      }
	
	      var origParams = {
	        active: this.get('active'),
	        left: this.getLeft(),
	        top: this.getTop()
	      };
	
	      this.set('active', false);
	      this.setPositionByOrigin(new fabric.Point(el.width / 2, el.height / 2), 'center', 'center');
	
	      var originalCanvas = this.canvas;
	      canvas.add(this);
	      var data = canvas.toDataURL(options);
	
	      this.set(origParams).setCoords();
	      this.canvas = originalCanvas;
	
	      canvas.dispose();
	      canvas = null;
	
	      return data;
	    },
	
	    /**
	     * Returns true if specified type is identical to the type of an instance
	     * @param {String} type Type to check against
	     * @return {Boolean}
	     */
	    isType: function(type) {
	      return this.type === type;
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 0;
	    },
	
	    /**
	     * Returns a JSON representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} JSON
	     */
	    toJSON: function(propertiesToInclude) {
	      // delegate, not alias
	      return this.toObject(propertiesToInclude);
	    },
	
	    /**
	     * Sets gradient (fill or stroke) of an object
	     * <b>Backwards incompatibility note:</b> This method was named "setGradientFill" until v1.1.0
	     * @param {String} property Property name 'stroke' or 'fill'
	     * @param {Object} [options] Options object
	     * @param {String} [options.type] Type of gradient 'radial' or 'linear'
	     * @param {Number} [options.x1=0] x-coordinate of start point
	     * @param {Number} [options.y1=0] y-coordinate of start point
	     * @param {Number} [options.x2=0] x-coordinate of end point
	     * @param {Number} [options.y2=0] y-coordinate of end point
	     * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)
	     * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)
	     * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}
	     * @return {fabric.Object} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}
	     * @example <caption>Set linear gradient</caption>
	     * object.setGradient('fill', {
	     *   type: 'linear',
	     *   x1: -object.width / 2,
	     *   y1: 0,
	     *   x2: object.width / 2,
	     *   y2: 0,
	     *   colorStops: {
	     *     0: 'red',
	     *     0.5: '#005555',
	     *     1: 'rgba(0,0,255,0.5)'
	     *   }
	     * });
	     * canvas.renderAll();
	     * @example <caption>Set radial gradient</caption>
	     * object.setGradient('fill', {
	     *   type: 'radial',
	     *   x1: 0,
	     *   y1: 0,
	     *   x2: 0,
	     *   y2: 0,
	     *   r1: object.width / 2,
	     *   r2: 10,
	     *   colorStops: {
	     *     0: 'red',
	     *     0.5: '#005555',
	     *     1: 'rgba(0,0,255,0.5)'
	     *   }
	     * });
	     * canvas.renderAll();
	     */
	    setGradient: function(property, options) {
	      options || (options = { });
	
	      var gradient = { colorStops: [] };
	
	      gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');
	      gradient.coords = {
	        x1: options.x1,
	        y1: options.y1,
	        x2: options.x2,
	        y2: options.y2
	      };
	
	      if (options.r1 || options.r2) {
	        gradient.coords.r1 = options.r1;
	        gradient.coords.r2 = options.r2;
	      }
	
	      for (var position in options.colorStops) {
	        var color = new fabric.Color(options.colorStops[position]);
	        gradient.colorStops.push({
	          offset: position,
	          color: color.toRgb(),
	          opacity: color.getAlpha()
	        });
	      }
	
	      return this.set(property, fabric.Gradient.forObject(this, gradient));
	    },
	
	    /**
	     * Sets pattern fill of an object
	     * @param {Object} options Options object
	     * @param {(String|HTMLImageElement)} options.source Pattern source
	     * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
	     * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner
	     * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner
	     * @return {fabric.Object} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}
	     * @example <caption>Set pattern</caption>
	     * fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function(img) {
	     *   object.setPatternFill({
	     *     source: img,
	     *     repeat: 'repeat'
	     *   });
	     *   canvas.renderAll();
	     * });
	     */
	    setPatternFill: function(options) {
	      return this.set('fill', new fabric.Pattern(options));
	    },
	
	    /**
	     * Sets {@link fabric.Object#shadow|shadow} of an object
	     * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
	     * @param {String} [options.color=rgb(0,0,0)] Shadow color
	     * @param {Number} [options.blur=0] Shadow blur
	     * @param {Number} [options.offsetX=0] Shadow horizontal offset
	     * @param {Number} [options.offsetY=0] Shadow vertical offset
	     * @return {fabric.Object} thisArg
	     * @chainable
	     * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}
	     * @example <caption>Set shadow with string notation</caption>
	     * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');
	     * canvas.renderAll();
	     * @example <caption>Set shadow with object notation</caption>
	     * object.setShadow({
	     *   color: 'red',
	     *   blur: 10,
	     *   offsetX: 20,
	     *   offsetY: 20
	     * });
	     * canvas.renderAll();
	     */
	    setShadow: function(options) {
	      return this.set('shadow', options ? new fabric.Shadow(options) : null);
	    },
	
	    /**
	     * Sets "color" of an instance (alias of `set('fill', &hellip;)`)
	     * @param {String} color Color value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setColor: function(color) {
	      this.set('fill', color);
	      return this;
	    },
	
	    /**
	     * Sets "angle" of an instance
	     * @param {Number} angle Angle value (in degrees)
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setAngle: function(angle) {
	      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;
	
	      if (shouldCenterOrigin) {
	        this._setOriginToCenter();
	      }
	
	      this.set('angle', angle);
	
	      if (shouldCenterOrigin) {
	        this._resetOrigin();
	      }
	
	      return this;
	    },
	
	    /**
	     * Centers object horizontally on canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    centerH: function () {
	      this.canvas.centerObjectH(this);
	      return this;
	    },
	
	    /**
	     * Centers object vertically on canvas to which it was added last.
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    centerV: function () {
	      this.canvas.centerObjectV(this);
	      return this;
	    },
	
	    /**
	     * Centers object vertically and horizontally on canvas to which is was added last
	     * You might need to call `setCoords` on an object after centering, to update controls area.
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    center: function () {
	      this.canvas.centerObject(this);
	      return this;
	    },
	
	    /**
	     * Removes object from canvas to which it was added last
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    remove: function() {
	      this.canvas.remove(this);
	      return this;
	    },
	
	    /**
	     * Returns coordinates of a pointer relative to an object
	     * @param {Event} e Event to operate upon
	     * @param {Object} [pointer] Pointer to operate upon (instead of event)
	     * @return {Object} Coordinates of a pointer (x, y)
	     */
	    getLocalPointer: function(e, pointer) {
	      pointer = pointer || this.canvas.getPointer(e);
	      var pClicked = new fabric.Point(pointer.x, pointer.y),
	          objectLeftTop = this._getLeftTopCoords();
	      if (this.angle) {
	        pClicked = fabric.util.rotatePoint(
	          pClicked, objectLeftTop, fabric.util.degreesToRadians(-this.angle));
	      }
	      return {
	        x: pClicked.x - objectLeftTop.x,
	        y: pClicked.y - objectLeftTop.y
	      };
	    },
	
	    /**
	     * Sets canvas globalCompositeOperation for specific object
	     * custom composition operation for the particular object can be specifed using globalCompositeOperation property
	     * @param {CanvasRenderingContext2D} ctx Rendering canvas context
	     */
	    _setupCompositeOperation: function (ctx) {
	      if (this.globalCompositeOperation) {
	        ctx.globalCompositeOperation = this.globalCompositeOperation;
	      }
	    }
	  });
	
	  fabric.util.createAccessors(fabric.Object);
	
	  /**
	   * Alias for {@link fabric.Object.prototype.setAngle}
	   * @alias rotate -> setAngle
	   * @memberOf fabric.Object
	   */
	  fabric.Object.prototype.rotate = fabric.Object.prototype.setAngle;
	
	  extend(fabric.Object.prototype, fabric.Observable);
	
	  /**
	   * Defines the number of fraction digits to use when serializing object values.
	   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
	   * @static
	   * @memberOf fabric.Object
	   * @constant
	   * @type Number
	   */
	  fabric.Object.NUM_FRACTION_DIGITS = 2;
	
	  /**
	   * Unique id used internally when creating SVG elements
	   * @static
	   * @memberOf fabric.Object
	   * @type Number
	   */
	  fabric.Object.__uid = 0;
	
	})( true ? exports : this);
	
	
	(function() {
	
	  var degreesToRadians = fabric.util.degreesToRadians,
	      originXOffset = {
	        left: -0.5,
	        center: 0,
	        right: 0.5
	      },
	      originYOffset = {
	        top: -0.5,
	        center: 0,
	        bottom: 0.5
	      };
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
	     * @param {fabric.Point} point The point which corresponds to the originX and originY params
	     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
	     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
	      var x = point.x,
	          y = point.y,
	          offsetX = originXOffset[toOriginX] - originXOffset[fromOriginX],
	          offsetY = originYOffset[toOriginY] - originYOffset[fromOriginY],
	          dim;
	      if (offsetX || offsetY) {
	        dim = this._getTransformedDimensions();
	        x = point.x + offsetX * dim.x;
	        y = point.y + offsetY * dim.y;
	      }
	      return new fabric.Point(x, y);
	    },
	
	    /**
	     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
	     * @param {fabric.Point} point The point which corresponds to the originX and originY params
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    translateToCenterPoint: function(point, originX, originY) {
	      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
	      if (this.angle) {
	        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
	      }
	      return p;
	    },
	
	    /**
	     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
	     * @param {fabric.Point} center The point which corresponds to center of the object
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    translateToOriginPoint: function(center, originX, originY) {
	      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
	      if (this.angle) {
	        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
	      }
	      return p;
	    },
	
	    /**
	     * Returns the real center coordinates of the object
	     * @return {fabric.Point}
	     */
	    getCenterPoint: function() {
	      var leftTop = new fabric.Point(this.left, this.top);
	      return this.translateToCenterPoint(leftTop, this.originX, this.originY);
	    },
	
	    /**
	     * Returns the coordinates of the object based on center coordinates
	     * @param {fabric.Point} point The point which corresponds to the originX and originY params
	     * @return {fabric.Point}
	     */
	    // getOriginPoint: function(center) {
	    //   return this.translateToOriginPoint(center, this.originX, this.originY);
	    // },
	
	    /**
	     * Returns the coordinates of the object as if it has a different origin
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    getPointByOrigin: function(originX, originY) {
	      var center = this.getCenterPoint();
	      return this.translateToOriginPoint(center, originX, originY);
	    },
	
	    /**
	     * Returns the point in local coordinates
	     * @param {fabric.Point} point The point relative to the global coordinate system
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {fabric.Point}
	     */
	    toLocalPoint: function(point, originX, originY) {
	      var center = this.getCenterPoint(),
	          p, p2;
	
	      if (originX && originY) {
	        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
	      }
	      else {
	        p = new fabric.Point(this.left, this.top);
	      }
	
	      p2 = new fabric.Point(point.x, point.y);
	      if (this.angle) {
	        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
	      }
	      return p2.subtractEquals(p);
	    },
	
	    /**
	     * Returns the point in global coordinates
	     * @param {fabric.Point} The point relative to the local coordinate system
	     * @return {fabric.Point}
	     */
	    // toGlobalPoint: function(point) {
	    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
	    // },
	
	    /**
	     * Sets the position of the object taking into consideration the object's origin
	     * @param {fabric.Point} pos The new position of the object
	     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
	     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
	     * @return {void}
	     */
	    setPositionByOrigin: function(pos, originX, originY) {
	      var center = this.translateToCenterPoint(pos, originX, originY),
	          position = this.translateToOriginPoint(center, this.originX, this.originY);
	
	      this.set('left', position.x);
	      this.set('top', position.y);
	    },
	
	    /**
	     * @param {String} to One of 'left', 'center', 'right'
	     */
	    adjustPosition: function(to) {
	      var angle = degreesToRadians(this.angle),
	          hypotFull = this.getWidth(),
	          xFull = Math.cos(angle) * hypotFull,
	          yFull = Math.sin(angle) * hypotFull;
	
	      //TODO: this function does not consider mixed situation like top, center.
	      this.left += xFull * (originXOffset[to] - originXOffset[this.originX]);
	      this.top += yFull * (originXOffset[to] - originXOffset[this.originX]);
	
	      this.setCoords();
	      this.originX = to;
	    },
	
	    /**
	     * Sets the origin/position of the object to it's center point
	     * @private
	     * @return {void}
	     */
	    _setOriginToCenter: function() {
	      this._originalOriginX = this.originX;
	      this._originalOriginY = this.originY;
	
	      var center = this.getCenterPoint();
	
	      this.originX = 'center';
	      this.originY = 'center';
	
	      this.left = center.x;
	      this.top = center.y;
	    },
	
	    /**
	     * Resets the origin/position of the object to it's original origin
	     * @private
	     * @return {void}
	     */
	    _resetOrigin: function() {
	      var originPoint = this.translateToOriginPoint(
	        this.getCenterPoint(),
	        this._originalOriginX,
	        this._originalOriginY);
	
	      this.originX = this._originalOriginX;
	      this.originY = this._originalOriginY;
	
	      this.left = originPoint.x;
	      this.top = originPoint.y;
	
	      this._originalOriginX = null;
	      this._originalOriginY = null;
	    },
	
	    /**
	     * @private
	     */
	    _getLeftTopCoords: function() {
	      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
	    }
	  });
	
	})();
	
	
	(function() {
	
	  var degreesToRadians = fabric.util.degreesToRadians;
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * Object containing coordinates of object's controls
	     * @type Object
	     * @default
	     */
	    oCoords: null,
	
	    /**
	     * Checks if object intersects with an area formed by 2 points
	     * @param {Object} pointTL top-left point of area
	     * @param {Object} pointBR bottom-right point of area
	     * @return {Boolean} true if object intersects with an area formed by 2 points
	     */
	    intersectsWithRect: function(pointTL, pointBR) {
	      var oCoords = this.oCoords,
	          tl = new fabric.Point(oCoords.tl.x, oCoords.tl.y),
	          tr = new fabric.Point(oCoords.tr.x, oCoords.tr.y),
	          bl = new fabric.Point(oCoords.bl.x, oCoords.bl.y),
	          br = new fabric.Point(oCoords.br.x, oCoords.br.y),
	          intersection = fabric.Intersection.intersectPolygonRectangle(
	            [tl, tr, br, bl],
	            pointTL,
	            pointBR
	          );
	      return intersection.status === 'Intersection';
	    },
	
	    /**
	     * Checks if object intersects with another object
	     * @param {Object} other Object to test
	     * @return {Boolean} true if object intersects with another object
	     */
	    intersectsWithObject: function(other) {
	      // extracts coords
	      function getCoords(oCoords) {
	        return {
	          tl: new fabric.Point(oCoords.tl.x, oCoords.tl.y),
	          tr: new fabric.Point(oCoords.tr.x, oCoords.tr.y),
	          bl: new fabric.Point(oCoords.bl.x, oCoords.bl.y),
	          br: new fabric.Point(oCoords.br.x, oCoords.br.y)
	        };
	      }
	      var thisCoords = getCoords(this.oCoords),
	          otherCoords = getCoords(other.oCoords),
	          intersection = fabric.Intersection.intersectPolygonPolygon(
	            [thisCoords.tl, thisCoords.tr, thisCoords.br, thisCoords.bl],
	            [otherCoords.tl, otherCoords.tr, otherCoords.br, otherCoords.bl]
	          );
	
	      return intersection.status === 'Intersection';
	    },
	
	    /**
	     * Checks if object is fully contained within area of another object
	     * @param {Object} other Object to test
	     * @return {Boolean} true if object is fully contained within area of another object
	     */
	    isContainedWithinObject: function(other) {
	      var boundingRect = other.getBoundingRect(),
	          point1 = new fabric.Point(boundingRect.left, boundingRect.top),
	          point2 = new fabric.Point(boundingRect.left + boundingRect.width, boundingRect.top + boundingRect.height);
	
	      return this.isContainedWithinRect(point1, point2);
	    },
	
	    /**
	     * Checks if object is fully contained within area formed by 2 points
	     * @param {Object} pointTL top-left point of area
	     * @param {Object} pointBR bottom-right point of area
	     * @return {Boolean} true if object is fully contained within area formed by 2 points
	     */
	    isContainedWithinRect: function(pointTL, pointBR) {
	      var boundingRect = this.getBoundingRect();
	
	      return (
	        boundingRect.left >= pointTL.x &&
	        boundingRect.left + boundingRect.width <= pointBR.x &&
	        boundingRect.top >= pointTL.y &&
	        boundingRect.top + boundingRect.height <= pointBR.y
	      );
	    },
	
	    /**
	     * Checks if point is inside the object
	     * @param {fabric.Point} point Point to check against
	     * @return {Boolean} true if point is inside the object
	     */
	    containsPoint: function(point) {
	      var lines = this._getImageLines(this.oCoords),
	          xPoints = this._findCrossPoints(point, lines);
	
	      // if xPoints is odd then point is inside the object
	      return (xPoints !== 0 && xPoints % 2 === 1);
	    },
	
	    /**
	     * Method that returns an object with the object edges in it, given the coordinates of the corners
	     * @private
	     * @param {Object} oCoords Coordinates of the object corners
	     */
	    _getImageLines: function(oCoords) {
	      return {
	        topline: {
	          o: oCoords.tl,
	          d: oCoords.tr
	        },
	        rightline: {
	          o: oCoords.tr,
	          d: oCoords.br
	        },
	        bottomline: {
	          o: oCoords.br,
	          d: oCoords.bl
	        },
	        leftline: {
	          o: oCoords.bl,
	          d: oCoords.tl
	        }
	      };
	    },
	
	    /**
	     * Helper method to determine how many cross points are between the 4 object edges
	     * and the horizontal line determined by a point on canvas
	     * @private
	     * @param {fabric.Point} point Point to check
	     * @param {Object} oCoords Coordinates of the object being evaluated
	     */
	    _findCrossPoints: function(point, oCoords) {
	      var b1, b2, a1, a2, xi, yi,
	          xcount = 0,
	          iLine;
	
	      for (var lineKey in oCoords) {
	        iLine = oCoords[lineKey];
	        // optimisation 1: line below point. no cross
	        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
	          continue;
	        }
	        // optimisation 2: line above point. no cross
	        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
	          continue;
	        }
	        // optimisation 3: vertical line case
	        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
	          xi = iLine.o.x;
	          yi = point.y;
	        }
	        // calculate the intersection point
	        else {
	          b1 = 0;
	          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
	          a1 = point.y - b1 * point.x;
	          a2 = iLine.o.y - b2 * iLine.o.x;
	
	          xi = - (a1 - a2) / (b1 - b2);
	          yi = a1 + b1 * xi;
	        }
	        // dont count xi < point.x cases
	        if (xi >= point.x) {
	          xcount += 1;
	        }
	        // optimisation 4: specific for square images
	        if (xcount === 2) {
	          break;
	        }
	      }
	      return xcount;
	    },
	
	    /**
	     * Returns width of an object's bounding rectangle
	     * @deprecated since 1.0.4
	     * @return {Number} width value
	     */
	    getBoundingRectWidth: function() {
	      return this.getBoundingRect().width;
	    },
	
	    /**
	     * Returns height of an object's bounding rectangle
	     * @deprecated since 1.0.4
	     * @return {Number} height value
	     */
	    getBoundingRectHeight: function() {
	      return this.getBoundingRect().height;
	    },
	
	    /**
	     * Returns coordinates of object's bounding rectangle (left, top, width, height)
	     * @return {Object} Object with left, top, width, height properties
	     */
	    getBoundingRect: function() {
	      this.oCoords || this.setCoords();
	
	      var xCoords = [this.oCoords.tl.x, this.oCoords.tr.x, this.oCoords.br.x, this.oCoords.bl.x],
	          minX = fabric.util.array.min(xCoords),
	          maxX = fabric.util.array.max(xCoords),
	          width = Math.abs(minX - maxX),
	
	          yCoords = [this.oCoords.tl.y, this.oCoords.tr.y, this.oCoords.br.y, this.oCoords.bl.y],
	          minY = fabric.util.array.min(yCoords),
	          maxY = fabric.util.array.max(yCoords),
	          height = Math.abs(minY - maxY);
	
	      return {
	        left: minX,
	        top: minY,
	        width: width,
	        height: height
	      };
	    },
	
	    /**
	     * Returns width of an object
	     * @return {Number} width value
	     */
	    getWidth: function() {
	      return this.width * this.scaleX;
	    },
	
	    /**
	     * Returns height of an object
	     * @return {Number} height value
	     */
	    getHeight: function() {
	      return this.height * this.scaleY;
	    },
	
	    /**
	     * Makes sure the scale is valid and modifies it if necessary
	     * @private
	     * @param {Number} value
	     * @return {Number}
	     */
	    _constrainScale: function(value) {
	      if (Math.abs(value) < this.minScaleLimit) {
	        if (value < 0) {
	          return -this.minScaleLimit;
	        }
	        else {
	          return this.minScaleLimit;
	        }
	      }
	      return value;
	    },
	
	    /**
	     * Scales an object (equally by x and y)
	     * @param {Number} value Scale factor
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    scale: function(value) {
	      value = this._constrainScale(value);
	
	      if (value < 0) {
	        this.flipX = !this.flipX;
	        this.flipY = !this.flipY;
	        value *= -1;
	      }
	
	      this.scaleX = value;
	      this.scaleY = value;
	      this.setCoords();
	      return this;
	    },
	
	    /**
	     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
	     * @param {Number} value New width value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    scaleToWidth: function(value) {
	      // adjust to bounding rect factor so that rotated shapes would fit as well
	      var boundingRectFactor = this.getBoundingRectWidth() / this.getWidth();
	      return this.scale(value / this.width / boundingRectFactor);
	    },
	
	    /**
	     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
	     * @param {Number} value New height value
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    scaleToHeight: function(value) {
	      // adjust to bounding rect factor so that rotated shapes would fit as well
	      var boundingRectFactor = this.getBoundingRectHeight() / this.getHeight();
	      return this.scale(value / this.height / boundingRectFactor);
	    },
	
	    /**
	     * Sets corner position coordinates based on current angle, width and height
	     * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setCoords: function() {
	      var theta = degreesToRadians(this.angle),
	          vpt = this.getViewportTransform(),
	          dim = this._calculateCurrentDimensions(true),
	          currentWidth = dim.x, currentHeight = dim.y;
	
	      // If width is negative, make postive. Fixes path selection issue
	      if (currentWidth < 0) {
	        currentWidth = Math.abs(currentWidth);
	      }
	
	      var sinTh = Math.sin(theta),
	          cosTh = Math.cos(theta),
	          _angle = currentWidth > 0 ? Math.atan(currentHeight / currentWidth) : 0,
	          _hypotenuse = (currentWidth / Math.cos(_angle)) / 2,
	          offsetX = Math.cos(_angle + theta) * _hypotenuse,
	          offsetY = Math.sin(_angle + theta) * _hypotenuse,
	
	          // offset added for rotate and scale actions
	          coords = fabric.util.transformPoint(this.getCenterPoint(), vpt),
	          tl  = new fabric.Point(coords.x - offsetX, coords.y - offsetY),
	          tr  = new fabric.Point(tl.x + (currentWidth * cosTh), tl.y + (currentWidth * sinTh)),
	          bl  = new fabric.Point(tl.x - (currentHeight * sinTh), tl.y + (currentHeight * cosTh)),
	          br  = new fabric.Point(coords.x + offsetX, coords.y + offsetY),
	          ml  = new fabric.Point((tl.x + bl.x)/2, (tl.y + bl.y)/2),
	          mt  = new fabric.Point((tr.x + tl.x)/2, (tr.y + tl.y)/2),
	          mr  = new fabric.Point((br.x + tr.x)/2, (br.y + tr.y)/2),
	          mb  = new fabric.Point((br.x + bl.x)/2, (br.y + bl.y)/2),
	          mtr = new fabric.Point(mt.x + sinTh * this.rotatingPointOffset, mt.y - cosTh * this.rotatingPointOffset);
	      // debugging
	
	      /* setTimeout(function() {
	         canvas.contextTop.fillStyle = 'green';
	         canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);
	         canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);
	         canvas.contextTop.fillRect(br.x, br.y, 3, 3);
	         canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);
	         canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);
	         canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);
	         canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);
	         canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);
	         canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);
	       }, 50); */
	
	      this.oCoords = {
	        // corners
	        tl: tl, tr: tr, br: br, bl: bl,
	        // middle
	        ml: ml, mt: mt, mr: mr, mb: mb,
	        // rotating point
	        mtr: mtr
	      };
	
	      // set coordinates of the draggable boxes in the corners used to scale/rotate the image
	      this._setCornerCoords && this._setCornerCoords();
	
	      return this;
	    },
	
	    _calcDimensionsTransformMatrix: function() {
	      // introduce skew matrix here later
	      return [this.scaleX, 0, 0, this.scaleY, 0, 0];
	    }
	  });
	})();
	
	
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	  /**
	   * Moves an object to the bottom of the stack of drawn objects
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  sendToBack: function() {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
	    }
	    else {
	      this.canvas.sendToBack(this);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object to the top of the stack of drawn objects
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  bringToFront: function() {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
	    }
	    else {
	      this.canvas.bringToFront(this);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object down in stack of drawn objects
	   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  sendBackwards: function(intersecting) {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
	    }
	    else {
	      this.canvas.sendBackwards(this, intersecting);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object up in stack of drawn objects
	   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  bringForward: function(intersecting) {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
	    }
	    else {
	      this.canvas.bringForward(this, intersecting);
	    }
	    return this;
	  },
	
	  /**
	   * Moves an object to specified level in stack of drawn objects
	   * @param {Number} index New position of object
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  moveTo: function(index) {
	    if (this.group) {
	      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
	    }
	    else {
	      this.canvas.moveTo(this, index);
	    }
	    return this;
	  }
	});
	
	
	/* _TO_SVG_START_ */
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	  /**
	   * Returns styles-string for svg-export
	   * @return {String}
	   */
	  getSvgStyles: function() {
	
	    var fill = this.fill
	          ? (this.fill.toLive ? 'url(#SVGID_' + this.fill.id + ')' : this.fill)
	          : 'none',
	        fillRule = this.fillRule,
	        stroke = this.stroke
	          ? (this.stroke.toLive ? 'url(#SVGID_' + this.stroke.id + ')' : this.stroke)
	          : 'none',
	
	        strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
	        strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
	        strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
	        strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
	        strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
	        opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
	
	        visibility = this.visible ? '' : ' visibility: hidden;',
	        filter = this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
	
	    return [
	      'stroke: ', stroke, '; ',
	      'stroke-width: ', strokeWidth, '; ',
	      'stroke-dasharray: ', strokeDashArray, '; ',
	      'stroke-linecap: ', strokeLineCap, '; ',
	      'stroke-linejoin: ', strokeLineJoin, '; ',
	      'stroke-miterlimit: ', strokeMiterLimit, '; ',
	      'fill: ', fill, '; ',
	      'fill-rule: ', fillRule, '; ',
	      'opacity: ', opacity, ';',
	      filter,
	      visibility
	    ].join('');
	  },
	
	  /**
	   * Returns transform-string for svg-export
	   * @return {String}
	   */
	  getSvgTransform: function() {
	    if (this.group && this.group.type === 'path-group') {
	      return '';
	    }
	    var toFixed = fabric.util.toFixed,
	        angle = this.getAngle(),
	        vpt = !this.canvas || this.canvas.svgViewportTransformation ? this.getViewportTransform() : [1, 0, 0, 1, 0, 0],
	        center = fabric.util.transformPoint(this.getCenterPoint(), vpt),
	
	        NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
	
	        translatePart = this.type === 'path-group' ? '' : 'translate(' +
	                          toFixed(center.x, NUM_FRACTION_DIGITS) +
	                          ' ' +
	                          toFixed(center.y, NUM_FRACTION_DIGITS) +
	                        ')',
	
	        anglePart = angle !== 0
	          ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')')
	          : '',
	
	        scalePart = (this.scaleX === 1 && this.scaleY === 1 && vpt[0] === 1 && vpt[3] === 1)
	          ? '' :
	          (' scale(' +
	            toFixed(this.scaleX * vpt[0], NUM_FRACTION_DIGITS) +
	            ' ' +
	            toFixed(this.scaleY * vpt[3], NUM_FRACTION_DIGITS) +
	          ')'),
	
	        addTranslateX = this.type === 'path-group' ? this.width * vpt[0] : 0,
	
	        flipXPart = this.flipX ? ' matrix(-1 0 0 1 ' + addTranslateX + ' 0) ' : '',
	
	        addTranslateY = this.type === 'path-group' ? this.height * vpt[3] : 0,
	
	        flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 ' + addTranslateY + ')' : '';
	
	    return [
	      translatePart, anglePart, scalePart, flipXPart, flipYPart
	    ].join('');
	  },
	
	  /**
	   * Returns transform-string for svg-export from the transform matrix of single elements
	   * @return {String}
	   */
	  getSvgTransformMatrix: function() {
	    return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ') ' : '';
	  },
	
	  /**
	   * @private
	   */
	  _createBaseSVGMarkup: function() {
	    var markup = [ ];
	
	    if (this.fill && this.fill.toLive) {
	      markup.push(this.fill.toSVG(this, false));
	    }
	    if (this.stroke && this.stroke.toLive) {
	      markup.push(this.stroke.toSVG(this, false));
	    }
	    if (this.shadow) {
	      markup.push(this.shadow.toSVG(this));
	    }
	    return markup;
	  }
	});
	/* _TO_SVG_END_ */
	
	
	/*
	  Depends on `stateProperties`
	*/
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	  /**
	   * Returns true if object state (one of its state properties) was changed
	   * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
	   */
	  hasStateChanged: function() {
	    return this.stateProperties.some(function(prop) {
	      return this.get(prop) !== this.originalState[prop];
	    }, this);
	  },
	
	  /**
	   * Saves state of an object
	   * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
	   * @return {fabric.Object} thisArg
	   */
	  saveState: function(options) {
	    this.stateProperties.forEach(function(prop) {
	      this.originalState[prop] = this.get(prop);
	    }, this);
	
	    if (options && options.stateProperties) {
	      options.stateProperties.forEach(function(prop) {
	        this.originalState[prop] = this.get(prop);
	      }, this);
	    }
	
	    return this;
	  },
	
	  /**
	   * Setups state of an object
	   * @return {fabric.Object} thisArg
	   */
	  setupState: function() {
	    this.originalState = { };
	    this.saveState();
	
	    return this;
	  }
	});
	
	
	(function() {
	
	  var degreesToRadians = fabric.util.degreesToRadians,
	      //jscs:disable requireCamelCaseOrUpperCaseIdentifiers
	      isVML = function() { return typeof G_vmlCanvasManager !== 'undefined'; };
	  //jscs:enable requireCamelCaseOrUpperCaseIdentifiers
	
	  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	    /**
	     * The object interactivity controls.
	     * @private
	     */
	    _controlsVisibility: null,
	
	    /**
	     * Determines which corner has been clicked
	     * @private
	     * @param {Object} pointer The pointer indicating the mouse position
	     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
	     */
	    _findTargetCorner: function(pointer) {
	      if (!this.hasControls || !this.active) {
	        return false;
	      }
	
	      var ex = pointer.x,
	          ey = pointer.y,
	          xPoints,
	          lines;
	
	      for (var i in this.oCoords) {
	
	        if (!this.isControlVisible(i)) {
	          continue;
	        }
	
	        if (i === 'mtr' && !this.hasRotatingPoint) {
	          continue;
	        }
	
	        if (this.get('lockUniScaling') &&
	           (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {
	          continue;
	        }
	
	        lines = this._getImageLines(this.oCoords[i].corner);
	
	        // debugging
	
	        // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);
	
	        // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);
	
	        // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);
	
	        // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
	        // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);
	
	        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
	        if (xPoints !== 0 && xPoints % 2 === 1) {
	          this.__corner = i;
	          return i;
	        }
	      }
	      return false;
	    },
	
	    /**
	     * Sets the coordinates of the draggable boxes in the corners of
	     * the image used to scale/rotate it.
	     * @private
	     */
	    _setCornerCoords: function() {
	      var coords = this.oCoords,
	          newTheta = degreesToRadians(45 - this.angle),
	          /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */
	          /* 0.707106 stands for sqrt(2)/2 */
	          cornerHypotenuse = this.cornerSize * 0.707106,
	          cosHalfOffset = cornerHypotenuse * Math.cos(newTheta),
	          sinHalfOffset = cornerHypotenuse * Math.sin(newTheta),
	          x, y;
	
	      for (var point in coords) {
	        x = coords[point].x;
	        y = coords[point].y;
	        coords[point].corner = {
	          tl: {
	            x: x - sinHalfOffset,
	            y: y - cosHalfOffset
	          },
	          tr: {
	            x: x + cosHalfOffset,
	            y: y - sinHalfOffset
	          },
	          bl: {
	            x: x - cosHalfOffset,
	            y: y + sinHalfOffset
	          },
	          br: {
	            x: x + sinHalfOffset,
	            y: y + cosHalfOffset
	          }
	        };
	      }
	    },
	
	    /*
	     * Calculate object dimensions from its properties
	     * @private
	     */
	    _getNonTransformedDimensions: function() {
	      var strokeWidth = this.strokeWidth,
	          w = this.width,
	          h = this.height,
	          capped = this.strokeLineCap === 'round' || this.strokeLineCap === 'square',
	          vLine = this.type === 'line' && this.width === 0,
	          hLine = this.type === 'line' && this.height === 0,
	          sLine = vLine || hLine,
	          strokeW = (capped && hLine) || !sLine,
	          strokeH = (capped && vLine) || !sLine;
	
	      if (vLine) {
	        w = strokeWidth;
	      }
	      else if (hLine) {
	        h = strokeWidth;
	      }
	      if (strokeW) {
	        w += (w < 0 ? -strokeWidth : strokeWidth);
	      }
	      if (strokeH) {
	        h += (h < 0 ? -strokeWidth : strokeWidth);
	      }
	      return { x: w, y: h };
	    },
	
	    /*
	     * @private
	     */
	    _getTransformedDimensions: function(dimensions) {
	      if (!dimensions) {
	        dimensions = this._getNonTransformedDimensions();
	      }
	      var transformMatrix = this._calcDimensionsTransformMatrix();
	      return fabric.util.transformPoint(dimensions, transformMatrix, true);
	    },
	
	    /*
	     * private
	     */
	    _calculateCurrentDimensions: function(shouldTransform)  {
	      var vpt = this.getViewportTransform(),
	          dim = this._getTransformedDimensions(),
	          w = dim.x, h = dim.y;
	
	      w += 2 * this.padding;
	      h += 2 * this.padding;
	
	      if (shouldTransform) {
	        return fabric.util.transformPoint(new fabric.Point(w, h), vpt, true);
	      }
	      return { x: w, y: h };
	    },
	
	    /**
	     * Draws borders of an object's bounding box.
	     * Requires public properties: width, height
	     * Requires public options: padding, borderColor
	     * @param {CanvasRenderingContext2D} ctx Context to draw on
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    drawBorders: function(ctx) {
	      if (!this.hasBorders) {
	        return this;
	      }
	
	      ctx.save();
	
	      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
	      ctx.strokeStyle = this.borderColor;
	      ctx.lineWidth = 1 / this.borderScaleFactor;
	
	      var wh = this._calculateCurrentDimensions(true),
	          width = wh.x,
	          height = wh.y;
	      if (this.group) {
	        width = width * this.group.scaleX;
	        height = height * this.group.scaleY;
	      }
	
	      ctx.strokeRect(
	        ~~(-(width / 2)) - 0.5, // offset needed to make lines look sharper
	        ~~(-(height / 2)) - 0.5,
	        ~~(width) + 1, // double offset needed to make lines look sharper
	        ~~(height) + 1
	      );
	
	      if (this.hasRotatingPoint && this.isControlVisible('mtr') && !this.get('lockRotation') && this.hasControls) {
	
	        var rotateHeight = -height / 2;
	
	        ctx.beginPath();
	        ctx.moveTo(0, rotateHeight);
	        ctx.lineTo(0, rotateHeight - this.rotatingPointOffset);
	        ctx.closePath();
	        ctx.stroke();
	      }
	
	      ctx.restore();
	      return this;
	    },
	
	    /**
	     * Draws corners of an object's bounding box.
	     * Requires public properties: width, height
	     * Requires public options: cornerSize, padding
	     * @param {CanvasRenderingContext2D} ctx Context to draw on
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    drawControls: function(ctx) {
	      if (!this.hasControls) {
	        return this;
	      }
	
	      var wh = this._calculateCurrentDimensions(true),
	          width = wh.x,
	          height = wh.y,
	          left = -(width / 2),
	          top = -(height / 2),
	          scaleOffset = this.cornerSize / 2,
	          methodName = this.transparentCorners ? 'strokeRect' : 'fillRect';
	
	      ctx.save();
	
	      ctx.lineWidth = 1;
	
	      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
	      ctx.strokeStyle = ctx.fillStyle = this.cornerColor;
	
	      // top-left
	      this._drawControl('tl', ctx, methodName,
	        left - scaleOffset,
	        top - scaleOffset);
	
	      // top-right
	      this._drawControl('tr', ctx, methodName,
	        left + width - scaleOffset,
	        top - scaleOffset);
	
	      // bottom-left
	      this._drawControl('bl', ctx, methodName,
	        left - scaleOffset,
	        top + height - scaleOffset);
	
	      // bottom-right
	      this._drawControl('br', ctx, methodName,
	        left + width - scaleOffset,
	        top + height - scaleOffset);
	
	      if (!this.get('lockUniScaling')) {
	
	        // middle-top
	        this._drawControl('mt', ctx, methodName,
	          left + width/2 - scaleOffset,
	          top - scaleOffset);
	
	        // middle-bottom
	        this._drawControl('mb', ctx, methodName,
	          left + width/2 - scaleOffset,
	          top + height - scaleOffset);
	
	        // middle-right
	        this._drawControl('mr', ctx, methodName,
	          left + width - scaleOffset,
	          top + height/2 - scaleOffset);
	
	        // middle-left
	        this._drawControl('ml', ctx, methodName,
	          left - scaleOffset,
	          top + height/2 - scaleOffset);
	      }
	
	      // middle-top-rotate
	      if (this.hasRotatingPoint) {
	        this._drawControl('mtr', ctx, methodName,
	          left + width/2 - scaleOffset,
	          top - this.rotatingPointOffset - scaleOffset);
	      }
	
	      ctx.restore();
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _drawControl: function(control, ctx, methodName, left, top) {
	      if (!this.isControlVisible(control)) {
	        return;
	      }
	      var size = this.cornerSize;
	      isVML() || this.transparentCorners || ctx.clearRect(left, top, size, size);
	      ctx[methodName](left, top, size, size);
	    },
	
	    /**
	     * Returns true if the specified control is visible, false otherwise.
	     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
	     * @returns {Boolean} true if the specified control is visible, false otherwise
	     */
	    isControlVisible: function(controlName) {
	      return this._getControlsVisibility()[controlName];
	    },
	
	    /**
	     * Sets the visibility of the specified control.
	     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
	     * @param {Boolean} visible true to set the specified control visible, false otherwise
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setControlVisible: function(controlName, visible) {
	      this._getControlsVisibility()[controlName] = visible;
	      return this;
	    },
	
	    /**
	     * Sets the visibility state of object controls.
	     * @param {Object} [options] Options object
	     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
	     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
	     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
	     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
	     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
	     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
	     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
	     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
	     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
	     * @return {fabric.Object} thisArg
	     * @chainable
	     */
	    setControlsVisibility: function(options) {
	      options || (options = { });
	
	      for (var p in options) {
	        this.setControlVisible(p, options[p]);
	      }
	      return this;
	    },
	
	    /**
	     * Returns the instance of the control visibility set for this object.
	     * @private
	     * @returns {Object}
	     */
	    _getControlsVisibility: function() {
	      if (!this._controlsVisibility) {
	        this._controlsVisibility = {
	          tl: true,
	          tr: true,
	          br: true,
	          bl: true,
	          ml: true,
	          mt: true,
	          mr: true,
	          mb: true,
	          mtr: true
	        };
	      }
	      return this._controlsVisibility;
	    }
	  });
	})();
	
	
	fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	  /**
	   * Animation duration (in ms) for fx* methods
	   * @type Number
	   * @default
	   */
	  FX_DURATION: 500,
	
	  /**
	   * Centers object horizontally with animation.
	   * @param {fabric.Object} object Object to center
	   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxCenterObjectH: function (object, callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: object.get('left'),
	      endValue: this.getCenter().left,
	      duration: this.FX_DURATION,
	      onChange: function(value) {
	        object.set('left', value);
	        _this.renderAll();
	        onChange();
	      },
	      onComplete: function() {
	        object.setCoords();
	        onComplete();
	      }
	    });
	
	    return this;
	  },
	
	  /**
	   * Centers object vertically with animation.
	   * @param {fabric.Object} object Object to center
	   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxCenterObjectV: function (object, callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: object.get('top'),
	      endValue: this.getCenter().top,
	      duration: this.FX_DURATION,
	      onChange: function(value) {
	        object.set('top', value);
	        _this.renderAll();
	        onChange();
	      },
	      onComplete: function() {
	        object.setCoords();
	        onComplete();
	      }
	    });
	
	    return this;
	  },
	
	  /**
	   * Same as `fabric.Canvas#remove` but animated
	   * @param {fabric.Object} object Object to remove
	   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxRemove: function (object, callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: object.get('opacity'),
	      endValue: 0,
	      duration: this.FX_DURATION,
	      onStart: function() {
	        object.set('active', false);
	      },
	      onChange: function(value) {
	        object.set('opacity', value);
	        _this.renderAll();
	        onChange();
	      },
	      onComplete: function () {
	        _this.remove(object);
	        onComplete();
	      }
	    });
	
	    return this;
	  }
	});
	
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	  /**
	   * Animates object's properties
	   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
	   * @param {Number|Object} value Value to animate property to (if string was given first) or options object
	   * @return {fabric.Object} thisArg
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#animation}
	   * @chainable
	   *
	   * As object  multiple properties
	   *
	   * object.animate({ left: ..., top: ... });
	   * object.animate({ left: ..., top: ... }, { duration: ... });
	   *
	   * As string  one property
	   *
	   * object.animate('left', ...);
	   * object.animate('left', { duration: ... });
	   *
	   */
	  animate: function() {
	    if (arguments[0] && typeof arguments[0] === 'object') {
	      var propsToAnimate = [ ], prop, skipCallbacks;
	      for (prop in arguments[0]) {
	        propsToAnimate.push(prop);
	      }
	      for (var i = 0, len = propsToAnimate.length; i < len; i++) {
	        prop = propsToAnimate[i];
	        skipCallbacks = i !== len - 1;
	        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
	      }
	    }
	    else {
	      this._animate.apply(this, arguments);
	    }
	    return this;
	  },
	
	  /**
	   * @private
	   * @param {String} property Property to animate
	   * @param {String} to Value to animate to
	   * @param {Object} [options] Options object
	   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
	   */
	  _animate: function(property, to, options, skipCallbacks) {
	    var _this = this, propPair;
	
	    to = to.toString();
	
	    if (!options) {
	      options = { };
	    }
	    else {
	      options = fabric.util.object.clone(options);
	    }
	
	    if (~property.indexOf('.')) {
	      propPair = property.split('.');
	    }
	
	    var currentValue = propPair
	      ? this.get(propPair[0])[propPair[1]]
	      : this.get(property);
	
	    if (!('from' in options)) {
	      options.from = currentValue;
	    }
	
	    if (~to.indexOf('=')) {
	      to = currentValue + parseFloat(to.replace('=', ''));
	    }
	    else {
	      to = parseFloat(to);
	    }
	
	    fabric.util.animate({
	      startValue: options.from,
	      endValue: to,
	      byValue: options.by,
	      easing: options.easing,
	      duration: options.duration,
	      abort: options.abort && function() {
	        return options.abort.call(_this);
	      },
	      onChange: function(value) {
	        if (propPair) {
	          _this[propPair[0]][propPair[1]] = value;
	        }
	        else {
	          _this.set(property, value);
	        }
	        if (skipCallbacks) {
	          return;
	        }
	        options.onChange && options.onChange();
	      },
	      onComplete: function() {
	        if (skipCallbacks) {
	          return;
	        }
	
	        _this.setCoords();
	        options.onComplete && options.onComplete();
	      }
	    });
	  }
	});
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },
	      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');
	
	  if (fabric.Line) {
	    fabric.warn('fabric.Line is already defined');
	    return;
	  }
	
	  /**
	   * Line class
	   * @class fabric.Line
	   * @extends fabric.Object
	   * @see {@link fabric.Line#initialize} for constructor definition
	   */
	  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'line',
	
	    /**
	     * x value or first line edge
	     * @type Number
	     * @default
	     */
	    x1: 0,
	
	    /**
	     * y value or first line edge
	     * @type Number
	     * @default
	     */
	    y1: 0,
	
	    /**
	     * x value or second line edge
	     * @type Number
	     * @default
	     */
	    x2: 0,
	
	    /**
	     * y value or second line edge
	     * @type Number
	     * @default
	     */
	    y2: 0,
	
	    /**
	     * Constructor
	     * @param {Array} [points] Array of points
	     * @param {Object} [options] Options object
	     * @return {fabric.Line} thisArg
	     */
	    initialize: function(points, options) {
	      options = options || { };
	
	      if (!points) {
	        points = [0, 0, 0, 0];
	      }
	
	      this.callSuper('initialize', options);
	
	      this.set('x1', points[0]);
	      this.set('y1', points[1]);
	      this.set('x2', points[2]);
	      this.set('y2', points[3]);
	
	      this._setWidthHeight(options);
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options
	     */
	    _setWidthHeight: function(options) {
	      options || (options = { });
	
	      this.width = Math.abs(this.x2 - this.x1);
	      this.height = Math.abs(this.y2 - this.y1);
	
	      this.left = 'left' in options
	        ? options.left
	        : this._getLeftToOriginX();
	
	      this.top = 'top' in options
	        ? options.top
	        : this._getTopToOriginY();
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {Any} value
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	      if (typeof coordProps[key] !== 'undefined') {
	        this._setWidthHeight();
	      }
	      return this;
	    },
	
	    /**
	     * @private
	     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
	     */
	    _getLeftToOriginX: makeEdgeToOriginGetter(
	      { // property names
	        origin: 'originX',
	        axis1: 'x1',
	        axis2: 'x2',
	        dimension: 'width'
	      },
	      { // possible values of origin
	        nearest: 'left',
	        center: 'center',
	        farthest: 'right'
	      }
	    ),
	
	    /**
	     * @private
	     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
	     */
	    _getTopToOriginY: makeEdgeToOriginGetter(
	      { // property names
	        origin: 'originY',
	        axis1: 'y1',
	        axis2: 'y2',
	        dimension: 'height'
	      },
	      { // possible values of origin
	        nearest: 'top',
	        center: 'center',
	        farthest: 'bottom'
	      }
	    ),
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx, noTransform) {
	      ctx.beginPath();
	
	      if (noTransform) {
	        //  Line coords are distances from left-top of canvas to origin of line.
	        //  To render line in a path-group, we need to translate them to
	        //  distances from center of path-group to center of line.
	        var cp = this.getCenterPoint();
	        ctx.translate(
	          cp.x - this.strokeWidth / 2,
	          cp.y - this.strokeWidth / 2
	        );
	      }
	
	      if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
	        // move from center (of virtual box) to its left/top corner
	        // we can't assume x1, y1 is top left and x2, y2 is bottom right
	        var p = this.calcLinePoints();
	        ctx.moveTo(p.x1, p.y1);
	        ctx.lineTo(p.x2, p.y2);
	      }
	
	      ctx.lineWidth = this.strokeWidth;
	
	      // TODO: test this
	      // make sure setting "fill" changes color of a line
	      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
	      var origStrokeStyle = ctx.strokeStyle;
	      ctx.strokeStyle = this.stroke || ctx.fillStyle;
	      this.stroke && this._renderStroke(ctx);
	      ctx.strokeStyle = origStrokeStyle;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var p = this.calcLinePoints();
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);
	      ctx.closePath();
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @methd toObject
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
	    },
	
	    /**
	     * Recalculates line points given width and height
	     * @private
	     */
	    calcLinePoints: function() {
	      var xMult = this.x1 <= this.x2 ? -1 : 1,
	          yMult = this.y1 <= this.y2 ? -1 : 1,
	          x1 = (xMult * this.width * 0.5),
	          y1 = (yMult * this.height * 0.5),
	          x2 = (xMult * this.width * -0.5),
	          y2 = (yMult * this.height * -0.5);
	
	      return {
	        x1: x1,
	        x2: x2,
	        y1: y1,
	        y2: y2
	      };
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(),
	          p = { x1: this.x1, x2: this.x2, y1: this.y1, y2: this.y2 };
	
	      if (!(this.group && this.group.type === 'path-group')) {
	        p = this.calcLinePoints();
	      }
	      markup.push(
	        '<line ',
	          'x1="', p.x1,
	          '" y1="', p.y1,
	          '" x2="', p.x2,
	          '" y2="', p.y2,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          this.getSvgTransformMatrix(),
	        '"/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
	   * @static
	   * @memberOf fabric.Line
	   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
	   */
	  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));
	
	  /**
	   * Returns fabric.Line instance from an SVG element
	   * @static
	   * @memberOf fabric.Line
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Line} instance of fabric.Line
	   */
	  fabric.Line.fromElement = function(element, options) {
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
	        points = [
	          parsedAttributes.x1 || 0,
	          parsedAttributes.y1 || 0,
	          parsedAttributes.x2 || 0,
	          parsedAttributes.y2 || 0
	        ];
	    return new fabric.Line(points, extend(parsedAttributes, options));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Line instance from an object representation
	   * @static
	   * @memberOf fabric.Line
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Line} instance of fabric.Line
	   */
	  fabric.Line.fromObject = function(object) {
	    var points = [object.x1, object.y1, object.x2, object.y2];
	    return new fabric.Line(points, object);
	  };
	
	  /**
	   * Produces a function that calculates distance from canvas edge to Line origin.
	   */
	  function makeEdgeToOriginGetter(propertyNames, originValues) {
	    var origin = propertyNames.origin,
	        axis1 = propertyNames.axis1,
	        axis2 = propertyNames.axis2,
	        dimension = propertyNames.dimension,
	        nearest = originValues.nearest,
	        center = originValues.center,
	        farthest = originValues.farthest;
	
	    return function() {
	      switch (this.get(origin)) {
	      case nearest:
	        return Math.min(this.get(axis1), this.get(axis2));
	      case center:
	        return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
	      case farthest:
	        return Math.max(this.get(axis1), this.get(axis2));
	      }
	    };
	
	  }
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      pi = Math.PI,
	      extend = fabric.util.object.extend;
	
	  if (fabric.Circle) {
	    fabric.warn('fabric.Circle is already defined.');
	    return;
	  }
	
	  /**
	   * Circle class
	   * @class fabric.Circle
	   * @extends fabric.Object
	   * @see {@link fabric.Circle#initialize} for constructor definition
	   */
	  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'circle',
	
	    /**
	     * Radius of this circle
	     * @type Number
	     * @default
	     */
	    radius: 0,
	
	    /**
	     * Start angle of the circle, moving clockwise
	     * @type Number
	     * @default 0
	     */
	    startAngle: 0,
	
	    /**
	     * End angle of the circle
	     * @type Number
	     * @default 2Pi
	     */
	    endAngle: pi * 2,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {fabric.Circle} thisArg
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.callSuper('initialize', options);
	      this.set('radius', options.radius || 0);
	
	      this.startAngle = options.startAngle || this.startAngle;
	      this.endAngle = options.endAngle || this.endAngle;
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {Any} value
	     * @return {fabric.Circle} thisArg
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	
	      if (key === 'radius') {
	        this.setRadius(value);
	      }
	
	      return this;
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), {
	        radius: this.get('radius'),
	        startAngle: this.startAngle,
	        endAngle: this.endAngle
	      });
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = 0, y = 0,
	      angle = (this.endAngle - this.startAngle) % ( 2 * pi);
	
	      if (angle === 0) {
	        if (this.group && this.group.type === 'path-group') {
	          x = this.left + this.radius;
	          y = this.top + this.radius;
	        }
	        markup.push(
	          '<circle ',
	            'cx="' + x + '" cy="' + y + '" ',
	            'r="', this.radius,
	            '" style="', this.getSvgStyles(),
	            '" transform="', this.getSvgTransform(),
	            ' ', this.getSvgTransformMatrix(),
	          '"/>\n'
	        );
	      }
	      else {
	        var startX = Math.cos(this.startAngle) * this.radius,
	            startY = Math.sin(this.startAngle) * this.radius,
	            endX = Math.cos(this.endAngle) * this.radius,
	            endY = Math.sin(this.endAngle) * this.radius,
	            largeFlag = angle > pi ? '1' : '0';
	
	        markup.push(
	          '<path d="M ' + startX + ' ' + startY,
	          ' A ' + this.radius + ' ' + this.radius,
	          ' 0 ', + largeFlag + ' 1', ' ' + endX + ' ' + endY,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          ' ', this.getSvgTransformMatrix(),
	          '"/>\n'
	        );
	      }
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _render: function(ctx, noTransform) {
	      ctx.beginPath();
	      ctx.arc(noTransform ? this.left + this.radius : 0,
	              noTransform ? this.top + this.radius : 0,
	              this.radius,
	              this.startAngle,
	              this.endAngle, false);
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * Returns horizontal radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRadiusX: function() {
	      return this.get('radius') * this.get('scaleX');
	    },
	
	    /**
	     * Returns vertical radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRadiusY: function() {
	      return this.get('radius') * this.get('scaleY');
	    },
	
	    /**
	     * Sets radius of an object (and updates width accordingly)
	     * @return {fabric.Circle} thisArg
	     */
	    setRadius: function(value) {
	      this.radius = value;
	      return this.set('width', value * 2).set('height', value * 2);
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
	   * @static
	   * @memberOf fabric.Circle
	   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
	   */
	  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));
	
	  /**
	   * Returns {@link fabric.Circle} instance from an SVG element
	   * @static
	   * @memberOf fabric.Circle
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @throws {Error} If value of `r` attribute is missing or invalid
	   * @return {fabric.Circle} Instance of fabric.Circle
	   */
	  fabric.Circle.fromElement = function(element, options) {
	    options || (options = { });
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);
	
	    if (!isValidRadius(parsedAttributes)) {
	      throw new Error('value of `r` attribute is required and can not be negative');
	    }
	
	    parsedAttributes.left = parsedAttributes.left || 0;
	    parsedAttributes.top = parsedAttributes.top || 0;
	
	    var obj = new fabric.Circle(extend(parsedAttributes, options));
	
	    obj.left -= obj.radius;
	    obj.top -= obj.radius;
	    return obj;
	  };
	
	  /**
	   * @private
	   */
	  function isValidRadius(attributes) {
	    return (('radius' in attributes) && (attributes.radius >= 0));
	  }
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns {@link fabric.Circle} instance from an object representation
	   * @static
	   * @memberOf fabric.Circle
	   * @param {Object} object Object to create an instance from
	   * @return {Object} Instance of fabric.Circle
	   */
	  fabric.Circle.fromObject = function(object) {
	    return new fabric.Circle(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Triangle) {
	    fabric.warn('fabric.Triangle is already defined');
	    return;
	  }
	
	  /**
	   * Triangle class
	   * @class fabric.Triangle
	   * @extends fabric.Object
	   * @return {fabric.Triangle} thisArg
	   * @see {@link fabric.Triangle#initialize} for constructor definition
	   */
	  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'triangle',
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.callSuper('initialize', options);
	
	      this.set('width', options.width || 100)
	          .set('height', options.height || 100);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      var widthBy2 = this.width / 2,
	          heightBy2 = this.height / 2;
	
	      ctx.beginPath();
	      ctx.moveTo(-widthBy2, heightBy2);
	      ctx.lineTo(0, -heightBy2);
	      ctx.lineTo(widthBy2, heightBy2);
	      ctx.closePath();
	
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var widthBy2 = this.width / 2,
	          heightBy2 = this.height / 2;
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
	      ctx.closePath();
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(),
	          widthBy2 = this.width / 2,
	          heightBy2 = this.height / 2,
	          points = [
	            -widthBy2 + ' ' + heightBy2,
	            '0 ' + -heightBy2,
	            widthBy2 + ' ' + heightBy2
	          ]
	          .join(',');
	
	      markup.push(
	        '<polygon ',
	          'points="', points,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	        '"/>'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /**
	   * Returns fabric.Triangle instance from an object representation
	   * @static
	   * @memberOf fabric.Triangle
	   * @param {Object} object Object to create an instance from
	   * @return {Object} instance of Canvas.Triangle
	   */
	  fabric.Triangle.fromObject = function(object) {
	    return new fabric.Triangle(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      piBy2   = Math.PI * 2,
	      extend = fabric.util.object.extend;
	
	  if (fabric.Ellipse) {
	    fabric.warn('fabric.Ellipse is already defined.');
	    return;
	  }
	
	  /**
	   * Ellipse class
	   * @class fabric.Ellipse
	   * @extends fabric.Object
	   * @return {fabric.Ellipse} thisArg
	   * @see {@link fabric.Ellipse#initialize} for constructor definition
	   */
	  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'ellipse',
	
	    /**
	     * Horizontal radius
	     * @type Number
	     * @default
	     */
	    rx:   0,
	
	    /**
	     * Vertical radius
	     * @type Number
	     * @default
	     */
	    ry:   0,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {fabric.Ellipse} thisArg
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.callSuper('initialize', options);
	
	      this.set('rx', options.rx || 0);
	      this.set('ry', options.ry || 0);
	    },
	
	    /**
	     * @private
	     * @param {String} key
	     * @param {Any} value
	     * @return {fabric.Ellipse} thisArg
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	      switch (key) {
	
	        case 'rx':
	          this.rx = value;
	          this.set('width', value * 2);
	          break;
	
	        case 'ry':
	          this.ry = value;
	          this.set('height', value * 2);
	          break;
	
	      }
	      return this;
	    },
	
	    /**
	     * Returns horizontal radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRx: function() {
	      return this.get('rx') * this.get('scaleX');
	    },
	
	    /**
	     * Returns Vertical radius of an object (according to how an object is scaled)
	     * @return {Number}
	     */
	    getRy: function() {
	      return this.get('ry') * this.get('scaleY');
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), {
	        rx: this.get('rx'),
	        ry: this.get('ry')
	      });
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = 0, y = 0;
	      if (this.group && this.group.type === 'path-group') {
	        x = this.left + this.rx;
	        y = this.top + this.ry;
	      }
	      markup.push(
	        '<ellipse ',
	          'cx="', x, '" cy="', y, '" ',
	          'rx="', this.rx,
	          '" ry="', this.ry,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          this.getSvgTransformMatrix(),
	        '"/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _render: function(ctx, noTransform) {
	      ctx.beginPath();
	      ctx.save();
	      ctx.transform(1, 0, 0, this.ry/this.rx, 0, 0);
	      ctx.arc(
	        noTransform ? this.left + this.rx : 0,
	        noTransform ? (this.top + this.ry) * this.rx/this.ry : 0,
	        this.rx,
	        0,
	        piBy2,
	        false);
	      ctx.restore();
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
	   * @static
	   * @memberOf fabric.Ellipse
	   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
	   */
	  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));
	
	  /**
	   * Returns {@link fabric.Ellipse} instance from an SVG element
	   * @static
	   * @memberOf fabric.Ellipse
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Ellipse}
	   */
	  fabric.Ellipse.fromElement = function(element, options) {
	    options || (options = { });
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);
	
	    parsedAttributes.left = parsedAttributes.left || 0;
	    parsedAttributes.top = parsedAttributes.top || 0;
	
	    var ellipse = new fabric.Ellipse(extend(parsedAttributes, options));
	
	    ellipse.top -= ellipse.ry;
	    ellipse.left -= ellipse.rx;
	    return ellipse;
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns {@link fabric.Ellipse} instance from an object representation
	   * @static
	   * @memberOf fabric.Ellipse
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Ellipse}
	   */
	  fabric.Ellipse.fromObject = function(object) {
	    return new fabric.Ellipse(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  if (fabric.Rect) {
	    fabric.warn('fabric.Rect is already defined');
	    return;
	  }
	
	  var stateProperties = fabric.Object.prototype.stateProperties.concat();
	  stateProperties.push('rx', 'ry', 'x', 'y');
	
	  /**
	   * Rectangle class
	   * @class fabric.Rect
	   * @extends fabric.Object
	   * @return {fabric.Rect} thisArg
	   * @see {@link fabric.Rect#initialize} for constructor definition
	   */
	  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {
	
	    /**
	     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties: stateProperties,
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'rect',
	
	    /**
	     * Horizontal border radius
	     * @type Number
	     * @default
	     */
	    rx:   0,
	
	    /**
	     * Vertical border radius
	     * @type Number
	     * @default
	     */
	    ry:   0,
	
	    /**
	     * Used to specify dash pattern for stroke on this object
	     * @type Array
	     */
	    strokeDashArray: null,
	
	    /**
	     * Constructor
	     * @param {Object} [options] Options object
	     * @return {Object} thisArg
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.callSuper('initialize', options);
	      this._initRxRy();
	
	    },
	
	    /**
	     * Initializes rx/ry attributes
	     * @private
	     */
	    _initRxRy: function() {
	      if (this.rx && !this.ry) {
	        this.ry = this.rx;
	      }
	      else if (this.ry && !this.rx) {
	        this.rx = this.ry;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx, noTransform) {
	
	      // optimize 1x1 case (used in spray brush)
	      if (this.width === 1 && this.height === 1) {
	        ctx.fillRect(0, 0, 1, 1);
	        return;
	      }
	
	      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
	          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
	          w = this.width,
	          h = this.height,
	          x = noTransform ? this.left : -this.width / 2,
	          y = noTransform ? this.top : -this.height / 2,
	          isRounded = rx !== 0 || ry !== 0,
	          k = 1 - 0.5522847498 /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */;
	
	      ctx.beginPath();
	
	      ctx.moveTo(x + rx, y);
	
	      ctx.lineTo(x + w - rx, y);
	      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);
	
	      ctx.lineTo(x + w, y + h - ry);
	      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);
	
	      ctx.lineTo(x + rx, y + h);
	      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);
	
	      ctx.lineTo(x, y + ry);
	      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);
	
	      ctx.closePath();
	
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var x = -this.width / 2,
	          y = -this.height / 2,
	          w = this.width,
	          h = this.height;
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
	      ctx.closePath();
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var object = extend(this.callSuper('toObject', propertiesToInclude), {
	        rx: this.get('rx') || 0,
	        ry: this.get('ry') || 0
	      });
	      if (!this.includeDefaultValues) {
	        this._removeDefaultValues(object);
	      }
	      return object;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(), x = this.left, y = this.top;
	      if (!(this.group && this.group.type === 'path-group')) {
	        x = -this.width / 2;
	        y = -this.height / 2;
	      }
	      markup.push(
	        '<rect ',
	          'x="', x, '" y="', y,
	          '" rx="', this.get('rx'), '" ry="', this.get('ry'),
	          '" width="', this.width, '" height="', this.height,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          this.getSvgTransformMatrix(),
	        '"/>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
	   * @static
	   * @memberOf fabric.Rect
	   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
	   */
	  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));
	
	  /**
	   * Returns {@link fabric.Rect} instance from an SVG element
	   * @static
	   * @memberOf fabric.Rect
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Rect} Instance of fabric.Rect
	   */
	  fabric.Rect.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	    options = options || { };
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);
	
	    parsedAttributes.left = parsedAttributes.left || 0;
	    parsedAttributes.top  = parsedAttributes.top  || 0;
	    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
	    rect.visible = rect.width > 0 && rect.height > 0;
	    return rect;
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns {@link fabric.Rect} instance from an object representation
	   * @static
	   * @memberOf fabric.Rect
	   * @param {Object} object Object to create an instance from
	   * @return {Object} instance of fabric.Rect
	   */
	  fabric.Rect.fromObject = function(object) {
	    return new fabric.Rect(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { });
	
	  if (fabric.Polyline) {
	    fabric.warn('fabric.Polyline is already defined');
	    return;
	  }
	
	  /**
	   * Polyline class
	   * @class fabric.Polyline
	   * @extends fabric.Object
	   * @see {@link fabric.Polyline#initialize} for constructor definition
	   */
	  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'polyline',
	
	    /**
	     * Points array
	     * @type Array
	     * @default
	     */
	    points: null,
	
	    /**
	     * Minimum X from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minX: 0,
	
	    /**
	     * Minimum Y from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minY: 0,
	
	    /**
	     * Constructor
	     * @param {Array} points Array of points (where each point is an object with x and y)
	     * @param {Object} [options] Options object
	     * @param {Boolean} [skipOffset] Whether points offsetting should be skipped
	     * @return {fabric.Polyline} thisArg
	     * @example
	     * var poly = new fabric.Polyline([
	     *     { x: 10, y: 10 },
	     *     { x: 50, y: 30 },
	     *     { x: 40, y: 70 },
	     *     { x: 60, y: 50 },
	     *     { x: 100, y: 150 },
	     *     { x: 40, y: 100 }
	     *   ], {
	     *   stroke: 'red',
	     *   left: 100,
	     *   top: 100
	     * });
	     */
	    initialize: function(points, options) {
	      return fabric.Polygon.prototype.initialize.call(this, points, options);
	    },
	
	    /**
	     * @private
	     */
	    _calcDimensions: function() {
	      return fabric.Polygon.prototype._calcDimensions.call(this);
	    },
	
	    /**
	     * @private
	     */
	    _applyPointOffset: function() {
	      return fabric.Polygon.prototype._applyPointOffset.call(this);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return fabric.Polygon.prototype.toObject.call(this, propertiesToInclude);
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      return fabric.Polygon.prototype.toSVG.call(this, reviver);
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      if (!fabric.Polygon.prototype.commonRender.call(this, ctx)) {
	        return;
	      }
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var p1, p2;
	
	      ctx.beginPath();
	      for (var i = 0, len = this.points.length; i < len; i++) {
	        p1 = this.points[i];
	        p2 = this.points[i + 1] || p1;
	        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
	      }
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return this.get('points').length;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
	   * @static
	   * @memberOf fabric.Polyline
	   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
	   */
	  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
	
	  /**
	   * Returns fabric.Polyline instance from an SVG element
	   * @static
	   * @memberOf fabric.Polyline
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Polyline} Instance of fabric.Polyline
	   */
	  fabric.Polyline.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	    options || (options = { });
	
	    var points = fabric.parsePointsAttribute(element.getAttribute('points')),
	        parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);
	
	    return new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Polyline instance from an object representation
	   * @static
	   * @memberOf fabric.Polyline
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Polyline} Instance of fabric.Polyline
	   */
	  fabric.Polyline.fromObject = function(object) {
	    var points = object.points;
	    return new fabric.Polyline(points, object, true);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      min = fabric.util.array.min,
	      max = fabric.util.array.max,
	      toFixed = fabric.util.toFixed;
	
	  if (fabric.Polygon) {
	    fabric.warn('fabric.Polygon is already defined');
	    return;
	  }
	
	  /**
	   * Polygon class
	   * @class fabric.Polygon
	   * @extends fabric.Object
	   * @see {@link fabric.Polygon#initialize} for constructor definition
	   */
	  fabric.Polygon = fabric.util.createClass(fabric.Object, /** @lends fabric.Polygon.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'polygon',
	
	    /**
	     * Points array
	     * @type Array
	     * @default
	     */
	    points: null,
	
	    /**
	     * Minimum X from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minX: 0,
	
	    /**
	     * Minimum Y from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minY: 0,
	
	    /**
	     * Constructor
	     * @param {Array} points Array of points
	     * @param {Object} [options] Options object
	     * @return {fabric.Polygon} thisArg
	     */
	    initialize: function(points, options) {
	      options = options || { };
	      this.points = points || [ ];
	      this.callSuper('initialize', options);
	      this._calcDimensions();
	      if (!('top' in options)) {
	        this.top = this.minY;
	      }
	      if (!('left' in options)) {
	        this.left = this.minX;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _calcDimensions: function() {
	
	      var points = this.points,
	          minX = min(points, 'x'),
	          minY = min(points, 'y'),
	          maxX = max(points, 'x'),
	          maxY = max(points, 'y');
	
	      this.width = (maxX - minX) || 0;
	      this.height = (maxY - minY) || 0;
	
	      this.minX = minX || 0,
	      this.minY = minY || 0;
	    },
	
	    /**
	     * @private
	     */
	    _applyPointOffset: function() {
	      // change points to offset polygon into a bounding box
	      // executed one time
	      this.points.forEach(function(p) {
	        p.x -= (this.minX + this.width / 2);
	        p.y -= (this.minY + this.height / 2);
	      }, this);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), {
	        points: this.points.concat()
	      });
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var points = [],
	          markup = this._createBaseSVGMarkup();
	
	      for (var i = 0, len = this.points.length; i < len; i++) {
	        points.push(toFixed(this.points[i].x, 2), ',', toFixed(this.points[i].y, 2), ' ');
	      }
	
	      markup.push(
	        '<', this.type, ' ',
	          'points="', points.join(''),
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(),
	          ' ', this.getSvgTransformMatrix(),
	        '"/>\n'
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      if (!this.commonRender(ctx)) {
	        return;
	      }
	      this._renderFill(ctx);
	      if (this.stroke || this.strokeDashArray) {
	        ctx.closePath();
	        this._renderStroke(ctx);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    commonRender: function(ctx) {
	      var point, len = this.points.length;
	
	      if (!len || isNaN(this.points[len - 1].y)) {
	        // do not draw if no points or odd points
	        // NaN comes from parseFloat of a empty string in parser
	        return false;
	      }
	
	      ctx.beginPath();
	
	      if (this._applyPointOffset) {
	        if (!(this.group && this.group.type === 'path-group')) {
	          this._applyPointOffset();
	        }
	        this._applyPointOffset = null;
	      }
	
	      ctx.moveTo(this.points[0].x, this.points[0].y);
	      for (var i = 0; i < len; i++) {
	        point = this.points[i];
	        ctx.lineTo(point.x, point.y);
	      }
	      return true;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      fabric.Polyline.prototype._renderDashedStroke.call(this, ctx);
	      ctx.closePath();
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return this.points.length;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
	   * @static
	   * @memberOf fabric.Polygon
	   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
	   */
	  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
	
	  /**
	   * Returns {@link fabric.Polygon} instance from an SVG element
	   * @static
	   * @memberOf fabric.Polygon
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Polygon} Instance of fabric.Polygon
	   */
	  fabric.Polygon.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	
	    options || (options = { });
	
	    var points = fabric.parsePointsAttribute(element.getAttribute('points')),
	        parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);
	
	    return new fabric.Polygon(points, extend(parsedAttributes, options));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Polygon instance from an object representation
	   * @static
	   * @memberOf fabric.Polygon
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Polygon} Instance of fabric.Polygon
	   */
	  fabric.Polygon.fromObject = function(object) {
	    return new fabric.Polygon(object.points, object, true);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      min = fabric.util.array.min,
	      max = fabric.util.array.max,
	      extend = fabric.util.object.extend,
	      _toString = Object.prototype.toString,
	      drawArc = fabric.util.drawArc,
	      commandLengths = {
	        m: 2,
	        l: 2,
	        h: 1,
	        v: 1,
	        c: 6,
	        s: 4,
	        q: 4,
	        t: 2,
	        a: 7
	      },
	      repeatedCommands = {
	        m: 'l',
	        M: 'L'
	      };
	
	  if (fabric.Path) {
	    fabric.warn('fabric.Path is already defined');
	    return;
	  }
	
	  /**
	   * Path class
	   * @class fabric.Path
	   * @extends fabric.Object
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#path_and_pathgroup}
	   * @see {@link fabric.Path#initialize} for constructor definition
	   */
	  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'path',
	
	    /**
	     * Array of path points
	     * @type Array
	     * @default
	     */
	    path: null,
	
	    /**
	     * Minimum X from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minX: 0,
	
	    /**
	     * Minimum Y from points values, necessary to offset points
	     * @type Number
	     * @default
	     */
	    minY: 0,
	
	    /**
	     * Constructor
	     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
	     * @param {Object} [options] Options object
	     * @return {fabric.Path} thisArg
	     */
	    initialize: function(path, options) {
	      options = options || { };
	
	      this.setOptions(options);
	
	      if (!path) {
	        path = [ ];
	      }
	
	      var fromArray = _toString.call(path) === '[object Array]';
	
	      this.path = fromArray
	        ? path
	        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
	        : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
	
	      if (!this.path) {
	        return;
	      }
	
	      if (!fromArray) {
	        this.path = this._parsePath();
	      }
	
	      this._setPositionDimensions(options);
	
	      if (options.sourcePath) {
	        this.setSourcePath(options.sourcePath);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} options Options object
	     */
	    _setPositionDimensions: function(options) {
	      var calcDim = this._parseDimensions();
	
	      this.minX = calcDim.left;
	      this.minY = calcDim.top;
	      this.width = calcDim.width;
	      this.height = calcDim.height;
	
	      if (typeof options.left === 'undefined') {
	        this.left = calcDim.left + (this.originX === 'center'
	          ? this.width / 2
	          : this.originX === 'right'
	            ? this.width
	            : 0);
	      }
	
	      if (typeof options.top === 'undefined') {
	        this.top = calcDim.top + (this.originY === 'center'
	          ? this.height / 2
	          : this.originY === 'bottom'
	            ? this.height
	            : 0);
	      }
	
	      this.pathOffset = this.pathOffset || {
	        x: this.minX + this.width / 2,
	        y: this.minY + this.height / 2
	      };
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx context to render path on
	     */
	    _render: function(ctx) {
	      var current, // current instruction
	          previous = null,
	          subpathStartX = 0,
	          subpathStartY = 0,
	          x = 0, // current x
	          y = 0, // current y
	          controlX = 0, // current control point x
	          controlY = 0, // current control point y
	          tempX,
	          tempY,
	          l = -this.pathOffset.x,
	          t = -this.pathOffset.y;
	
	      if (this.group && this.group.type === 'path-group') {
	        l = 0;
	        t = 0;
	      }
	
	      ctx.beginPath();
	
	      for (var i = 0, len = this.path.length; i < len; ++i) {
	
	        current = this.path[i];
	
	        switch (current[0]) { // first letter
	
	          case 'l': // lineto, relative
	            x += current[1];
	            y += current[2];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'L': // lineto, absolute
	            x = current[1];
	            y = current[2];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'h': // horizontal lineto, relative
	            x += current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'H': // horizontal lineto, absolute
	            x = current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'v': // vertical lineto, relative
	            y += current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'V': // verical lineto, absolute
	            y = current[1];
	            ctx.lineTo(x + l, y + t);
	            break;
	
	          case 'm': // moveTo, relative
	            x += current[1];
	            y += current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            ctx.moveTo(x + l, y + t);
	            break;
	
	          case 'M': // moveTo, absolute
	            x = current[1];
	            y = current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            ctx.moveTo(x + l, y + t);
	            break;
	
	          case 'c': // bezierCurveTo, relative
	            tempX = x + current[5];
	            tempY = y + current[6];
	            controlX = x + current[3];
	            controlY = y + current[4];
	            ctx.bezierCurveTo(
	              x + current[1] + l, // x1
	              y + current[2] + t, // y1
	              controlX + l, // x2
	              controlY + t, // y2
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'C': // bezierCurveTo, absolute
	            x = current[5];
	            y = current[6];
	            controlX = current[3];
	            controlY = current[4];
	            ctx.bezierCurveTo(
	              current[1] + l,
	              current[2] + t,
	              controlX + l,
	              controlY + t,
	              x + l,
	              y + t
	            );
	            break;
	
	          case 's': // shorthand cubic bezierCurveTo, relative
	
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            ctx.bezierCurveTo(
	              controlX + l,
	              controlY + t,
	              x + current[1] + l,
	              y + current[2] + t,
	              tempX + l,
	              tempY + t
	            );
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = x + current[1];
	            controlY = y + current[2];
	
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'S': // shorthand cubic bezierCurveTo, absolute
	            tempX = current[3];
	            tempY = current[4];
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            ctx.bezierCurveTo(
	              controlX + l,
	              controlY + t,
	              current[1] + l,
	              current[2] + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = current[1];
	            controlY = current[2];
	
	            break;
	
	          case 'q': // quadraticCurveTo, relative
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	
	            controlX = x + current[1];
	            controlY = y + current[2];
	
	            ctx.quadraticCurveTo(
	              controlX + l,
	              controlY + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'Q': // quadraticCurveTo, absolute
	            tempX = current[3];
	            tempY = current[4];
	
	            ctx.quadraticCurveTo(
	              current[1] + l,
	              current[2] + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            controlX = current[1];
	            controlY = current[2];
	            break;
	
	          case 't': // shorthand quadraticCurveTo, relative
	
	            // transform to absolute x,y
	            tempX = x + current[1];
	            tempY = y + current[2];
	
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            ctx.quadraticCurveTo(
	              controlX + l,
	              controlY + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	
	            break;
	
	          case 'T':
	            tempX = current[1];
	            tempY = current[2];
	
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            ctx.quadraticCurveTo(
	              controlX + l,
	              controlY + t,
	              tempX + l,
	              tempY + t
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'a':
	            // TODO: optimize this
	            drawArc(ctx, x + l, y + t, [
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6] + x + l,
	              current[7] + y + t
	            ]);
	            x += current[6];
	            y += current[7];
	            break;
	
	          case 'A':
	            // TODO: optimize this
	            drawArc(ctx, x + l, y + t, [
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6] + l,
	              current[7] + t
	            ]);
	            x = current[6];
	            y = current[7];
	            break;
	
	          case 'z':
	          case 'Z':
	            x = subpathStartX;
	            y = subpathStartY;
	            ctx.closePath();
	            break;
	        }
	        previous = current;
	      }
	      this._renderFill(ctx);
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * Returns string representation of an instance
	     * @return {String} string representation of an instance
	     */
	    toString: function() {
	      return '#<fabric.Path (' + this.complexity() +
	        '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var o = extend(this.callSuper('toObject', propertiesToInclude), {
	        path: this.path.map(function(item) { return item.slice() }),
	        pathOffset: this.pathOffset
	      });
	      if (this.sourcePath) {
	        o.sourcePath = this.sourcePath;
	      }
	      if (this.transformMatrix) {
	        o.transformMatrix = this.transformMatrix;
	      }
	      return o;
	    },
	
	    /**
	     * Returns dataless object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toDatalessObject: function(propertiesToInclude) {
	      var o = this.toObject(propertiesToInclude);
	      if (this.sourcePath) {
	        o.path = this.sourcePath;
	      }
	      delete o.sourcePath;
	      return o;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var chunks = [],
	          markup = this._createBaseSVGMarkup(), addTransform = '';
	
	      for (var i = 0, len = this.path.length; i < len; i++) {
	        chunks.push(this.path[i].join(' '));
	      }
	      var path = chunks.join(' ');
	      if (!(this.group && this.group.type === 'path-group')) {
	        addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';
	      }
	      markup.push(
	        //jscs:disable validateIndentation
	        '<path ',
	          'd="', path,
	          '" style="', this.getSvgStyles(),
	          '" transform="', this.getSvgTransform(), addTransform,
	          this.getSvgTransformMatrix(), '" stroke-linecap="round" ',
	        '/>\n'
	        //jscs:enable validateIndentation
	      );
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns number representation of an instance complexity
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return this.path.length;
	    },
	
	    /**
	     * @private
	     */
	    _parsePath: function() {
	      var result = [ ],
	          coords = [ ],
	          currentPath,
	          parsed,
	          re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/ig,
	          match,
	          coordsStr;
	
	      for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {
	        currentPath = this.path[i];
	
	        coordsStr = currentPath.slice(1).trim();
	        coords.length = 0;
	
	        while ((match = re.exec(coordsStr))) {
	          coords.push(match[0]);
	        }
	
	        coordsParsed = [ currentPath.charAt(0) ];
	
	        for (var j = 0, jlen = coords.length; j < jlen; j++) {
	          parsed = parseFloat(coords[j]);
	          if (!isNaN(parsed)) {
	            coordsParsed.push(parsed);
	          }
	        }
	
	        var command = coordsParsed[0],
	            commandLength = commandLengths[command.toLowerCase()],
	            repeatedCommand = repeatedCommands[command] || command;
	
	        if (coordsParsed.length - 1 > commandLength) {
	          for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
	            result.push([ command ].concat(coordsParsed.slice(k, k + commandLength)));
	            command = repeatedCommand;
	          }
	        }
	        else {
	          result.push(coordsParsed);
	        }
	      }
	
	      return result;
	    },
	
	    /**
	     * @private
	     */
	    _parseDimensions: function() {
	
	      var aX = [],
	          aY = [],
	          current, // current instruction
	          previous = null,
	          subpathStartX = 0,
	          subpathStartY = 0,
	          x = 0, // current x
	          y = 0, // current y
	          controlX = 0, // current control point x
	          controlY = 0, // current control point y
	          tempX,
	          tempY,
	          bounds;
	
	      for (var i = 0, len = this.path.length; i < len; ++i) {
	
	        current = this.path[i];
	
	        switch (current[0]) { // first letter
	
	          case 'l': // lineto, relative
	            x += current[1];
	            y += current[2];
	            bounds = [ ];
	            break;
	
	          case 'L': // lineto, absolute
	            x = current[1];
	            y = current[2];
	            bounds = [ ];
	            break;
	
	          case 'h': // horizontal lineto, relative
	            x += current[1];
	            bounds = [ ];
	            break;
	
	          case 'H': // horizontal lineto, absolute
	            x = current[1];
	            bounds = [ ];
	            break;
	
	          case 'v': // vertical lineto, relative
	            y += current[1];
	            bounds = [ ];
	            break;
	
	          case 'V': // verical lineto, absolute
	            y = current[1];
	            bounds = [ ];
	            break;
	
	          case 'm': // moveTo, relative
	            x += current[1];
	            y += current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            bounds = [ ];
	            break;
	
	          case 'M': // moveTo, absolute
	            x = current[1];
	            y = current[2];
	            subpathStartX = x;
	            subpathStartY = y;
	            bounds = [ ];
	            break;
	
	          case 'c': // bezierCurveTo, relative
	            tempX = x + current[5];
	            tempY = y + current[6];
	            controlX = x + current[3];
	            controlY = y + current[4];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              x + current[1], // x1
	              y + current[2], // y1
	              controlX, // x2
	              controlY, // y2
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'C': // bezierCurveTo, absolute
	            x = current[5];
	            y = current[6];
	            controlX = current[3];
	            controlY = current[4];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              current[1],
	              current[2],
	              controlX,
	              controlY,
	              x,
	              y
	            );
	            break;
	
	          case 's': // shorthand cubic bezierCurveTo, relative
	
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              x + current[1],
	              y + current[2],
	              tempX,
	              tempY
	            );
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = x + current[1];
	            controlY = y + current[2];
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'S': // shorthand cubic bezierCurveTo, absolute
	            tempX = current[3];
	            tempY = current[4];
	            if (previous[0].match(/[CcSs]/) === null) {
	              // If there is no previous command or if the previous command was not a C, c, S, or s,
	              // the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control points
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              current[1],
	              current[2],
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            // set control point to 2nd one of this command
	            // "... the first control point is assumed to be
	            // the reflection of the second control point on
	            // the previous command relative to the current point."
	            controlX = current[1];
	            controlY = current[2];
	            break;
	
	          case 'q': // quadraticCurveTo, relative
	            // transform to absolute x,y
	            tempX = x + current[3];
	            tempY = y + current[4];
	            controlX = x + current[1];
	            controlY = y + current[2];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'Q': // quadraticCurveTo, absolute
	            controlX = current[1];
	            controlY = current[2];
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              current[3],
	              current[4]
	            );
	            x = current[3];
	            y = current[4];
	            break;
	
	          case 't': // shorthand quadraticCurveTo, relative
	            // transform to absolute x,y
	            tempX = x + current[1];
	            tempY = y + current[2];
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	
	            break;
	
	          case 'T':
	            tempX = current[1];
	            tempY = current[2];
	
	            if (previous[0].match(/[QqTt]/) === null) {
	              // If there is no previous command or if the previous command was not a Q, q, T or t,
	              // assume the control point is coincident with the current point
	              controlX = x;
	              controlY = y;
	            }
	            else {
	              // calculate reflection of previous control point
	              controlX = 2 * x - controlX;
	              controlY = 2 * y - controlY;
	            }
	            bounds = fabric.util.getBoundsOfCurve(x, y,
	              controlX,
	              controlY,
	              controlX,
	              controlY,
	              tempX,
	              tempY
	            );
	            x = tempX;
	            y = tempY;
	            break;
	
	          case 'a':
	            // TODO: optimize this
	            bounds = fabric.util.getBoundsOfArc(x, y,
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6] + x,
	              current[7] + y
	            );
	            x += current[6];
	            y += current[7];
	            break;
	
	          case 'A':
	            // TODO: optimize this
	            bounds = fabric.util.getBoundsOfArc(x, y,
	              current[1],
	              current[2],
	              current[3],
	              current[4],
	              current[5],
	              current[6],
	              current[7]
	            );
	            x = current[6];
	            y = current[7];
	            break;
	
	          case 'z':
	          case 'Z':
	            x = subpathStartX;
	            y = subpathStartY;
	            break;
	        }
	        previous = current;
	        bounds.forEach(function (point) {
	          aX.push(point.x);
	          aY.push(point.y);
	        });
	        aX.push(x);
	        aY.push(y);
	      }
	
	      var minX = min(aX) || 0,
	          minY = min(aY) || 0,
	          maxX = max(aX) || 0,
	          maxY = max(aY) || 0,
	          deltaX = maxX - minX,
	          deltaY = maxY - minY,
	
	          o = {
	            left: minX,
	            top: minY,
	            width: deltaX,
	            height: deltaY
	          };
	
	      return o;
	    }
	  });
	
	  /**
	   * Creates an instance of fabric.Path from an object
	   * @static
	   * @memberOf fabric.Path
	   * @param {Object} object
	   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
	   */
	  fabric.Path.fromObject = function(object, callback) {
	    if (typeof object.path === 'string') {
	      fabric.loadSVGFromURL(object.path, function (elements) {
	        var path = elements[0],
	            pathUrl = object.path;
	
	        delete object.path;
	
	        fabric.util.object.extend(path, object);
	        path.setSourcePath(pathUrl);
	
	        callback(path);
	      });
	    }
	    else {
	      callback(new fabric.Path(object.path, object));
	    }
	  };
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
	   * @static
	   * @memberOf fabric.Path
	   * @see http://www.w3.org/TR/SVG/paths.html#PathElement
	   */
	  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);
	
	  /**
	   * Creates an instance of fabric.Path from an SVG <path> element
	   * @static
	   * @memberOf fabric.Path
	   * @param {SVGElement} element to parse
	   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
	   * @param {Object} [options] Options object
	   */
	  fabric.Path.fromElement = function(element, callback, options) {
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
	    callback && callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @memberOf fabric.Path
	   * @type Boolean
	   * @default
	   */
	  fabric.Path.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      invoke = fabric.util.array.invoke,
	      parentToObject = fabric.Object.prototype.toObject;
	
	  if (fabric.PathGroup) {
	    fabric.warn('fabric.PathGroup is already defined');
	    return;
	  }
	
	  /**
	   * Path group class
	   * @class fabric.PathGroup
	   * @extends fabric.Path
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#path_and_pathgroup}
	   * @see {@link fabric.PathGroup#initialize} for constructor definition
	   */
	  fabric.PathGroup = fabric.util.createClass(fabric.Path, /** @lends fabric.PathGroup.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'path-group',
	
	    /**
	     * Fill value
	     * @type String
	     * @default
	     */
	    fill: '',
	
	    /**
	     * Constructor
	     * @param {Array} paths
	     * @param {Object} [options] Options object
	     * @return {fabric.PathGroup} thisArg
	     */
	    initialize: function(paths, options) {
	
	      options = options || { };
	      this.paths = paths || [ ];
	
	      for (var i = this.paths.length; i--;) {
	        this.paths[i].group = this;
	      }
	
	      if (options.toBeParsed) {
	        this.parseDimensionsFromPaths(options);
	        delete options.toBeParsed;
	      }
	      this.setOptions(options);
	      this.setCoords();
	
	      if (options.sourcePath) {
	        this.setSourcePath(options.sourcePath);
	      }
	    },
	
	    /**
	     * Calculate width and height based on paths contained
	     */
	    parseDimensionsFromPaths: function(options) {
	      var points, p, xC = [ ], yC = [ ], path, height, width,
	          m;
	      for (var j = this.paths.length; j--;) {
	        path = this.paths[j];
	        height = path.height + path.strokeWidth;
	        width = path.width + path.strokeWidth;
	        points = [
	          { x: path.left, y: path.top },
	          { x: path.left + width, y: path.top },
	          { x: path.left, y: path.top + height },
	          { x: path.left + width, y: path.top + height }
	        ];
	        m = this.paths[j].transformMatrix;
	        for (var i = 0; i < points.length; i++) {
	          p = points[i];
	          if (m) {
	            p = fabric.util.transformPoint(p, m, false);
	          }
	          xC.push(p.x);
	          yC.push(p.y);
	        }
	      }
	      options.width = Math.max.apply(null, xC);
	      options.height = Math.max.apply(null, yC);
	    },
	
	    /**
	     * Renders this group on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render this instance on
	     */
	    render: function(ctx) {
	      // do not render if object is not visible
	      if (!this.visible) {
	        return;
	      }
	
	      ctx.save();
	
	      if (this.transformMatrix) {
	        ctx.transform.apply(ctx, this.transformMatrix);
	      }
	      this.transform(ctx);
	
	      this._setShadow(ctx);
	      this.clipTo && fabric.util.clipContext(this, ctx);
	      ctx.translate(-this.width/2, -this.height/2);
	      for (var i = 0, l = this.paths.length; i < l; ++i) {
	        this.paths[i].render(ctx, true);
	      }
	      this.clipTo && ctx.restore();
	      ctx.restore();
	    },
	
	    /**
	     * Sets certain property to a certain value
	     * @param {String} prop
	     * @param {Any} value
	     * @return {fabric.PathGroup} thisArg
	     */
	    _set: function(prop, value) {
	
	      if (prop === 'fill' && value && this.isSameColor()) {
	        var i = this.paths.length;
	        while (i--) {
	          this.paths[i]._set(prop, value);
	        }
	      }
	
	      return this.callSuper('_set', prop, value);
	    },
	
	    /**
	     * Returns object representation of this path group
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var o = extend(parentToObject.call(this, propertiesToInclude), {
	        paths: invoke(this.getObjects(), 'toObject', propertiesToInclude)
	      });
	      if (this.sourcePath) {
	        o.sourcePath = this.sourcePath;
	      }
	      return o;
	    },
	
	    /**
	     * Returns dataless object representation of this path group
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} dataless object representation of an instance
	     */
	    toDatalessObject: function(propertiesToInclude) {
	      var o = this.toObject(propertiesToInclude);
	      if (this.sourcePath) {
	        o.paths = this.sourcePath;
	      }
	      return o;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var objects = this.getObjects(),
	          p = this.getPointByOrigin('left', 'top'),
	          translatePart = 'translate(' + p.x + ' ' + p.y + ')',
	          markup = [
	            //jscs:disable validateIndentation
	            '<g ',
	              'style="', this.getSvgStyles(), '" ',
	              'transform="', this.getSvgTransformMatrix(), translatePart, this.getSvgTransform(), '" ',
	            '>\n'
	            //jscs:enable validateIndentation
	          ];
	
	      for (var i = 0, len = objects.length; i < len; i++) {
	        markup.push(objects[i].toSVG(reviver));
	      }
	      markup.push('</g>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns a string representation of this path group
	     * @return {String} string representation of an object
	     */
	    toString: function() {
	      return '#<fabric.PathGroup (' + this.complexity() +
	        '): { top: ' + this.top + ', left: ' + this.left + ' }>';
	    },
	
	    /**
	     * Returns true if all paths in this group are of same color
	     * @return {Boolean} true if all paths are of the same color (`fill`)
	     */
	    isSameColor: function() {
	      var firstPathFill = (this.getObjects()[0].get('fill') || '').toLowerCase();
	      return this.getObjects().every(function(path) {
	        return (path.get('fill') || '').toLowerCase() === firstPathFill;
	      });
	    },
	
	    /**
	     * Returns number representation of object's complexity
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return this.paths.reduce(function(total, path) {
	        return total + ((path && path.complexity) ? path.complexity() : 0);
	      }, 0);
	    },
	
	    /**
	     * Returns all paths in this path group
	     * @return {Array} array of path objects included in this path group
	     */
	    getObjects: function() {
	      return this.paths;
	    }
	  });
	
	  /**
	   * Creates fabric.PathGroup instance from an object representation
	   * @static
	   * @memberOf fabric.PathGroup
	   * @param {Object} object Object to create an instance from
	   * @param {Function} callback Callback to invoke when an fabric.PathGroup instance is created
	   */
	  fabric.PathGroup.fromObject = function(object, callback) {
	    if (typeof object.paths === 'string') {
	      fabric.loadSVGFromURL(object.paths, function (elements) {
	
	        var pathUrl = object.paths;
	        delete object.paths;
	
	        var pathGroup = fabric.util.groupSVGElements(elements, object, pathUrl);
	
	        callback(pathGroup);
	      });
	    }
	    else {
	      fabric.util.enlivenObjects(object.paths, function(enlivenedObjects) {
	        delete object.paths;
	        callback(new fabric.PathGroup(enlivenedObjects, object));
	      });
	    }
	  };
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @memberOf fabric.PathGroup
	   * @type Boolean
	   * @default
	   */
	  fabric.PathGroup.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      min = fabric.util.array.min,
	      max = fabric.util.array.max,
	      invoke = fabric.util.array.invoke;
	
	  if (fabric.Group) {
	    return;
	  }
	
	  // lock-related properties, for use in fabric.Group#get
	  // to enable locking behavior on group
	  // when one of its objects has lock-related properties set
	  var _lockProperties = {
	    lockMovementX:  true,
	    lockMovementY:  true,
	    lockRotation:   true,
	    lockScalingX:   true,
	    lockScalingY:   true,
	    lockUniScaling: true
	  };
	
	  /**
	   * Group class
	   * @class fabric.Group
	   * @extends fabric.Object
	   * @mixes fabric.Collection
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3/#groups}
	   * @see {@link fabric.Group#initialize} for constructor definition
	   */
	  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'group',
	
	    /**
	     * Width of stroke
	     * @type Number
	     * @default
	     */
	    strokeWidth: 0,
	
	    /**
	     * Constructor
	     * @param {Object} objects Group objects
	     * @param {Object} [options] Options object
	     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
	     * @return {Object} thisArg
	     */
	    initialize: function(objects, options, isAlreadyGrouped) {
	      options = options || { };
	
	      this._objects = [];
	      // if objects enclosed in a group have been grouped already,
	      // we cannot change properties of objects.
	      // Thus we need to set options to group without objects,
	      // because delegatedProperties propagate to objects.
	      isAlreadyGrouped && this.callSuper('initialize', options);
	
	      this._objects = objects || [];
	      for (var i = this._objects.length; i--; ) {
	        this._objects[i].group = this;
	      }
	
	      this.originalState = { };
	
	      if (options.originX) {
	        this.originX = options.originX;
	      }
	      if (options.originY) {
	        this.originY = options.originY;
	      }
	
	      if (isAlreadyGrouped) {
	        // do not change coordinate of objects enclosed in a group,
	        // because objects coordinate system have been group coodinate system already.
	        this._updateObjectsCoords(true);
	      }
	      else {
	        this._calcBounds();
	        this._updateObjectsCoords();
	        this.callSuper('initialize', options);
	      }
	
	      this.setCoords();
	      this.saveCoords();
	    },
	
	    /**
	     * @private
	     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
	     */
	    _updateObjectsCoords: function(skipCoordsChange) {
	      for (var i = this._objects.length; i--; ){
	        this._updateObjectCoords(this._objects[i], skipCoordsChange);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} object
	     * @param {Boolean} [skipCoordsChange] if true, coordinates of object dose not change
	     */
	    _updateObjectCoords: function(object, skipCoordsChange) {
	      // do not display corners of objects enclosed in a group
	      object.__origHasControls = object.hasControls;
	      object.hasControls = false;
	
	      if (skipCoordsChange) {
	        return;
	      }
	
	      var objectLeft = object.getLeft(),
	          objectTop = object.getTop(),
	          center = this.getCenterPoint();
	
	      object.set({
	        originalLeft: objectLeft,
	        originalTop: objectTop,
	        left: objectLeft - center.x,
	        top: objectTop - center.y
	      });
	      object.setCoords();
	    },
	
	    /**
	     * Returns string represenation of a group
	     * @return {String}
	     */
	    toString: function() {
	      return '#<fabric.Group: (' + this.complexity() + ')>';
	    },
	
	    /**
	     * Adds an object to a group; Then recalculates group's dimension, position.
	     * @param {Object} object
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    addWithUpdate: function(object) {
	      this._restoreObjectsState();
	      if (object) {
	        this._objects.push(object);
	        object.group = this;
	        object._set('canvas', this.canvas);
	      }
	      // since _restoreObjectsState set objects inactive
	      this.forEachObject(this._setObjectActive, this);
	      this._calcBounds();
	      this._updateObjectsCoords();
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _setObjectActive: function(object) {
	      object.set('active', true);
	      object.group = this;
	    },
	
	    /**
	     * Removes an object from a group; Then recalculates group's dimension, position.
	     * @param {Object} object
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    removeWithUpdate: function(object) {
	      this._moveFlippedObject(object);
	      this._restoreObjectsState();
	
	      // since _restoreObjectsState set objects inactive
	      this.forEachObject(this._setObjectActive, this);
	
	      this.remove(object);
	      this._calcBounds();
	      this._updateObjectsCoords();
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _onObjectAdded: function(object) {
	      object.group = this;
	      object._set('canvas', this.canvas);
	    },
	
	    /**
	     * @private
	     */
	    _onObjectRemoved: function(object) {
	      delete object.group;
	      object.set('active', false);
	    },
	
	    /**
	     * Properties that are delegated to group objects when reading/writing
	     * @param {Object} delegatedProperties
	     */
	    delegatedProperties: {
	      fill:             true,
	      opacity:          true,
	      fontFamily:       true,
	      fontWeight:       true,
	      fontSize:         true,
	      fontStyle:        true,
	      lineHeight:       true,
	      textDecoration:   true,
	      textAlign:        true,
	      backgroundColor:  true
	    },
	
	    /**
	     * @private
	     */
	    _set: function(key, value) {
	      var i = this._objects.length;
	
	      if (this.delegatedProperties[key] || key === 'canvas') {
	        while (i--) {
	          this._objects[i].set(key, value);
	        }
	      }
	      else {
	        while (i--) {
	          this._objects[i].setOnGroup(key, value);
	        }
	      }
	
	      this.callSuper('_set', key, value);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return extend(this.callSuper('toObject', propertiesToInclude), {
	        objects: invoke(this._objects, 'toObject', propertiesToInclude)
	      });
	    },
	
	    /**
	     * Renders instance on a given context
	     * @param {CanvasRenderingContext2D} ctx context to render instance on
	     */
	    render: function(ctx) {
	      // do not render if object is not visible
	      if (!this.visible) {
	        return;
	      }
	
	      ctx.save();
	      if (this.transformMatrix) {
	        ctx.transform.apply(ctx, this.transformMatrix);
	      }
	      this.transform(ctx);
	      this.clipTo && fabric.util.clipContext(this, ctx);
	      // the array is now sorted in order of highest first, so start from end
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        this._renderObject(this._objects[i], ctx);
	      }
	
	      this.clipTo && ctx.restore();
	
	      ctx.restore();
	    },
	
	    /**
	     * Renders controls and borders for the object
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} [noTransform] When true, context is not transformed
	     */
	    _renderControls: function(ctx, noTransform) {
	      this.callSuper('_renderControls', ctx, noTransform);
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        this._objects[i]._renderControls(ctx);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _renderObject: function(object, ctx) {
	      // do not render if object is not visible
	      if (!object.visible) {
	        return;
	      }
	
	      var originalHasRotatingPoint = object.hasRotatingPoint;
	      object.hasRotatingPoint = false;
	      object.render(ctx);
	      object.hasRotatingPoint = originalHasRotatingPoint;
	    },
	
	    /**
	     * Retores original state of each of group objects (original state is that which was before group was created).
	     * @private
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    _restoreObjectsState: function() {
	      this._objects.forEach(this._restoreObjectState, this);
	      return this;
	    },
	
	    /**
	     * Realises the transform from this group onto the supplied object
	     * i.e. it tells you what would happen if the supplied object was in
	     * the group, and then the group was destroyed. It mutates the supplied
	     * object.
	     * @param {fabric.Object} object
	     * @return {fabric.Object} transformedObject
	     */
	    realizeTransform: function(object) {
	      this._moveFlippedObject(object);
	      this._setObjectPosition(object);
	      return object;
	    },
	
	    /**
	     * Moves a flipped object to the position where it's displayed
	     * @private
	     * @param {fabric.Object} object
	     * @return {fabric.Group} thisArg
	     */
	    _moveFlippedObject: function(object) {
	      var oldOriginX = object.get('originX'),
	          oldOriginY = object.get('originY'),
	          center = object.getCenterPoint();
	
	      object.set({
	        originX: 'center',
	        originY: 'center',
	        left: center.x,
	        top: center.y
	      });
	
	      this._toggleFlipping(object);
	
	      var newOrigin = object.getPointByOrigin(oldOriginX, oldOriginY);
	
	      object.set({
	        originX: oldOriginX,
	        originY: oldOriginY,
	        left: newOrigin.x,
	        top: newOrigin.y
	      });
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _toggleFlipping: function(object) {
	      if (this.flipX) {
	        object.toggle('flipX');
	        object.set('left', -object.get('left'));
	        object.setAngle(-object.getAngle());
	      }
	      if (this.flipY) {
	        object.toggle('flipY');
	        object.set('top', -object.get('top'));
	        object.setAngle(-object.getAngle());
	      }
	    },
	
	    /**
	     * Restores original state of a specified object in group
	     * @private
	     * @param {fabric.Object} object
	     * @return {fabric.Group} thisArg
	     */
	    _restoreObjectState: function(object) {
	      this._setObjectPosition(object);
	
	      object.setCoords();
	      object.hasControls = object.__origHasControls;
	      delete object.__origHasControls;
	      object.set('active', false);
	      object.setCoords();
	      delete object.group;
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _setObjectPosition: function(object) {
	      var center = this.getCenterPoint(),
	          rotated = this._getRotatedLeftTop(object);
	
	      object.set({
	        angle: object.getAngle() + this.getAngle(),
	        left: center.x + rotated.left,
	        top: center.y + rotated.top,
	        scaleX: object.get('scaleX') * this.get('scaleX'),
	        scaleY: object.get('scaleY') * this.get('scaleY')
	      });
	    },
	
	    /**
	     * @private
	     */
	    _getRotatedLeftTop: function(object) {
	      var groupAngle = this.getAngle() * (Math.PI / 180);
	      return {
	        left: (-Math.sin(groupAngle) * object.getTop() * this.get('scaleY') +
	                Math.cos(groupAngle) * object.getLeft() * this.get('scaleX')),
	
	        top:  (Math.cos(groupAngle) * object.getTop() * this.get('scaleY') +
	               Math.sin(groupAngle) * object.getLeft() * this.get('scaleX'))
	      };
	    },
	
	    /**
	     * Destroys a group (restoring state of its objects)
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    destroy: function() {
	      this._objects.forEach(this._moveFlippedObject, this);
	      return this._restoreObjectsState();
	    },
	
	    /**
	     * Saves coordinates of this instance (to be used together with `hasMoved`)
	     * @saveCoords
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    saveCoords: function() {
	      this._originalLeft = this.get('left');
	      this._originalTop = this.get('top');
	      return this;
	    },
	
	    /**
	     * Checks whether this group was moved (since `saveCoords` was called last)
	     * @return {Boolean} true if an object was moved (since fabric.Group#saveCoords was called)
	     */
	    hasMoved: function() {
	      return this._originalLeft !== this.get('left') ||
	             this._originalTop !== this.get('top');
	    },
	
	    /**
	     * Sets coordinates of all group objects
	     * @return {fabric.Group} thisArg
	     * @chainable
	     */
	    setObjectsCoords: function() {
	      this.forEachObject(function(object) {
	        object.setCoords();
	      });
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _calcBounds: function(onlyWidthHeight) {
	      var aX = [],
	          aY = [],
	          o, prop,
	          props = ['tr', 'br', 'bl', 'tl'],
	          i = 0, iLen = this._objects.length,
	          j, jLen = props.length;
	
	      for ( ; i < iLen; ++i) {
	        o = this._objects[i];
	        o.setCoords();
	        for (j = 0; j < jLen; j++) {
	          prop = props[j];
	          aX.push(o.oCoords[prop].x);
	          aY.push(o.oCoords[prop].y);
	        }
	      }
	
	      this.set(this._getBounds(aX, aY, onlyWidthHeight));
	    },
	
	    /**
	     * @private
	     */
	    _getBounds: function(aX, aY, onlyWidthHeight) {
	      var ivt = fabric.util.invertTransform(this.getViewportTransform()),
	          minXY = fabric.util.transformPoint(new fabric.Point(min(aX), min(aY)), ivt),
	          maxXY = fabric.util.transformPoint(new fabric.Point(max(aX), max(aY)), ivt),
	          obj = {
	            width: (maxXY.x - minXY.x) || 0,
	            height: (maxXY.y - minXY.y) || 0
	          };
	
	      if (!onlyWidthHeight) {
	        obj.left = minXY.x || 0;
	        obj.top = minXY.y || 0;
	        if (this.originX === 'center') {
	          obj.left += obj.width / 2;
	        }
	        if (this.originX === 'right') {
	          obj.left += obj.width;
	        }
	        if (this.originY === 'center') {
	          obj.top += obj.height / 2;
	        }
	        if (this.originY === 'bottom') {
	          obj.top += obj.height;
	        }
	      }
	      return obj;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns svg representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = [
	        //jscs:disable validateIndentation
	        '<g ',
	          'transform="', this.getSvgTransform(),
	        '">\n'
	        //jscs:enable validateIndentation
	      ];
	
	      for (var i = 0, len = this._objects.length; i < len; i++) {
	        markup.push(this._objects[i].toSVG(reviver));
	      }
	
	      markup.push('</g>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns requested property
	     * @param {String} prop Property to get
	     * @return {Any}
	     */
	    get: function(prop) {
	      if (prop in _lockProperties) {
	        if (this[prop]) {
	          return this[prop];
	        }
	        else {
	          for (var i = 0, len = this._objects.length; i < len; i++) {
	            if (this._objects[i][prop]) {
	              return true;
	            }
	          }
	          return false;
	        }
	      }
	      else {
	        if (prop in this.delegatedProperties) {
	          return this._objects[0] && this._objects[0].get(prop);
	        }
	        return this[prop];
	      }
	    }
	  });
	
	  /**
	   * Returns {@link fabric.Group} instance from an object representation
	   * @static
	   * @memberOf fabric.Group
	   * @param {Object} object Object to create a group from
	   * @param {Function} [callback] Callback to invoke when an group instance is created
	   * @return {fabric.Group} An instance of fabric.Group
	   */
	  fabric.Group.fromObject = function(object, callback) {
	    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
	      delete object.objects;
	      callback && callback(new fabric.Group(enlivenedObjects, object, true));
	    });
	  };
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @memberOf fabric.Group
	   * @type Boolean
	   * @default
	   */
	  fabric.Group.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var extend = fabric.util.object.extend;
	
	  if (!global.fabric) {
	    global.fabric = { };
	  }
	
	  if (global.fabric.Image) {
	    fabric.warn('fabric.Image is already defined.');
	    return;
	  }
	
	  /**
	   * Image class
	   * @class fabric.Image
	   * @extends fabric.Object
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1/#images}
	   * @see {@link fabric.Image#initialize} for constructor definition
	   */
	  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'image',
	
	    /**
	     * crossOrigin value (one of "", "anonymous", "allow-credentials")
	     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
	     * @type String
	     * @default
	     */
	    crossOrigin: '',
	
	    /**
	     * AlignX value, part of preserveAspectRatio (one of "none", "mid", "min", "max")
	     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
	     * This parameter defines how the picture is aligned to its viewport when image element width differs from image width.
	     * @type String
	     * @default
	     */
	    alignX: 'none',
	
	    /**
	     * AlignY value, part of preserveAspectRatio (one of "none", "mid", "min", "max")
	     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
	     * This parameter defines how the picture is aligned to its viewport when image element height differs from image height.
	     * @type String
	     * @default
	     */
	    alignY: 'none',
	
	    /**
	     * meetOrSlice value, part of preserveAspectRatio  (one of "meet", "slice").
	     * if meet the image is always fully visibile, if slice the viewport is always filled with image.
	     * @see http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
	     * @type String
	     * @default
	     */
	    meetOrSlice: 'meet',
	
	    /**
	     * private
	     * contains last value of scaleX to detect
	     * if the Image got resized after the last Render
	     * @type Number
	     */
	    _lastScaleX: 1,
	
	    /**
	     * private
	     * contains last value of scaleY to detect
	     * if the Image got resized after the last Render
	     * @type Number
	     */
	    _lastScaleY: 1,
	
	    /**
	     * Constructor
	     * @param {HTMLImageElement | String} element Image element
	     * @param {Object} [options] Options object
	     * @return {fabric.Image} thisArg
	     */
	    initialize: function(element, options) {
	      options || (options = { });
	      this.filters = [ ];
	      this.resizeFilters = [ ];
	      this.callSuper('initialize', options);
	      this._initElement(element, options);
	    },
	
	    /**
	     * Returns image element which this instance if based on
	     * @return {HTMLImageElement} Image element
	     */
	    getElement: function() {
	      return this._element;
	    },
	
	    /**
	     * Sets image element for this instance to a specified one.
	     * If filters defined they are applied to new image.
	     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
	     * @param {HTMLImageElement} element
	     * @param {Function} [callback] Callback is invoked when all filters have been applied and new image is generated
	     * @param {Object} [options] Options object
	     * @return {fabric.Image} thisArg
	     * @chainable
	     */
	    setElement: function(element, callback, options) {
	      this._element = element;
	      this._originalElement = element;
	      this._initConfig(options);
	
	      if (this.filters.length !== 0) {
	        this.applyFilters(callback);
	      }
	      else if (callback) {
	        callback();
	      }
	
	      return this;
	    },
	
	    /**
	     * Sets crossOrigin value (on an instance and corresponding image element)
	     * @return {fabric.Image} thisArg
	     * @chainable
	     */
	    setCrossOrigin: function(value) {
	      this.crossOrigin = value;
	      this._element.crossOrigin = value;
	
	      return this;
	    },
	
	    /**
	     * Returns original size of an image
	     * @return {Object} Object with "width" and "height" properties
	     */
	    getOriginalSize: function() {
	      var element = this.getElement();
	      return {
	        width: element.width,
	        height: element.height
	      };
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _stroke: function(ctx) {
	      ctx.save();
	      this._setStrokeStyles(ctx);
	      ctx.beginPath();
	      ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
	      ctx.closePath();
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderDashedStroke: function(ctx) {
	      var x = -this.width / 2,
	          y = -this.height / 2,
	          w = this.width,
	          h = this.height;
	
	      ctx.save();
	      this._setStrokeStyles(ctx);
	
	      ctx.beginPath();
	      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
	      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
	      ctx.closePath();
	      ctx.restore();
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var filters = [ ];
	      this.filters.forEach(function(filterObj) {
	        if (filterObj) {
	          filters.push(filterObj.toObject());
	        }
	      });
	      var object = extend(this.callSuper('toObject', propertiesToInclude), {
	        src: this._originalElement.src || this._originalElement._src,
	        filters: filters,
	        crossOrigin: this.crossOrigin,
	        alignX: this.alignX,
	        alignY: this.alignY,
	        meetOrSlice: this.meetOrSlice
	      });
	
	      if (this.resizeFilters.length > 0) {
	        object.resizeFilters = this.resizeFilters.map(function(filterObj) {
	          return filterObj && filterObj.toObject();
	        });
	      }
	
	      if (!this.includeDefaultValues) {
	        this._removeDefaultValues(object);
	      }
	
	      return object;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = [], x = -this.width / 2, y = -this.height / 2,
	          preserveAspectRatio = 'none';
	      if (this.group && this.group.type === 'path-group') {
	        x = this.left;
	        y = this.top;
	      }
	      if (this.alignX !== 'none' && this.alignY !== 'none') {
	        preserveAspectRatio = 'x' + this.alignX + 'Y' + this.alignY + ' ' + this.meetOrSlice;
	      }
	      markup.push(
	        '<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n',
	          '<image xlink:href="', this.getSvgSrc(),
	            '" x="', x, '" y="', y,
	            '" style="', this.getSvgStyles(),
	            // we're essentially moving origin of transformation from top/left corner to the center of the shape
	            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
	            // so that object's center aligns with container's left/top
	            '" width="', this.width,
	            '" height="', this.height,
	            '" preserveAspectRatio="', preserveAspectRatio, '"',
	          '></image>\n'
	      );
	
	      if (this.stroke || this.strokeDashArray) {
	        var origFill = this.fill;
	        this.fill = null;
	        markup.push(
	          '<rect ',
	            'x="', x, '" y="', y,
	            '" width="', this.width, '" height="', this.height,
	            '" style="', this.getSvgStyles(),
	          '"/>\n'
	        );
	        this.fill = origFill;
	      }
	
	      markup.push('</g>\n');
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Returns source of an image
	     * @return {String} Source of an image
	     */
	    getSrc: function() {
	      if (this.getElement()) {
	        return this.getElement().src || this.getElement()._src;
	      }
	    },
	
	    /**
	     * Sets source of an image
	     * @param {String} src Source string (URL)
	     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
	     * @param {Object} [options] Options object
	     * @return {fabric.Image} thisArg
	     * @chainable
	     */
	    setSrc: function(src, callback, options) {
	      fabric.util.loadImage(src, function(img) {
	        return this.setElement(img, callback, options);
	      }, this, options && options.crossOrigin);
	    },
	
	    /**
	     * Returns string representation of an instance
	     * @return {String} String representation of an instance
	     */
	    toString: function() {
	      return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
	    },
	
	    /**
	     * Returns a clone of an instance
	     * @param {Function} callback Callback is invoked with a clone as a first argument
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     */
	    clone: function(callback, propertiesToInclude) {
	      this.constructor.fromObject(this.toObject(propertiesToInclude), callback);
	    },
	
	    /**
	     * Applies filters assigned to this image (from "filters" array)
	     * @method applyFilters
	     * @param {Function} callback Callback is invoked when all filters have been applied and new image is generated
	     * @return {fabric.Image} thisArg
	     * @chainable
	     */
	    applyFilters: function(callback, filters, imgElement, forResizing) {
	
	      filters = filters || this.filters;
	      imgElement = imgElement || this._originalElement;
	
	      if (!imgElement) {
	        return;
	      }
	
	      var imgEl = imgElement,
	          canvasEl = fabric.util.createCanvasElement(),
	          replacement = fabric.util.createImage(),
	          _this = this;
	
	      canvasEl.width = imgEl.width;
	      canvasEl.height = imgEl.height;
	      canvasEl.getContext('2d').drawImage(imgEl, 0, 0, imgEl.width, imgEl.height);
	
	      if (filters.length === 0) {
	        this._element = imgElement;
	        callback && callback();
	        return canvasEl;
	      }
	      filters.forEach(function(filter) {
	        filter && filter.applyTo(canvasEl, filter.scaleX || _this.scaleX, filter.scaleY || _this.scaleY);
	        if (!forResizing && filter && filter.type === 'Resize') {
	          _this.width *= filter.scaleX;
	          _this.height *= filter.scaleY;
	        }
	      });
	
	      /** @ignore */
	      replacement.width = canvasEl.width;
	      replacement.height = canvasEl.height;
	
	      if (fabric.isLikelyNode) {
	        replacement.src = canvasEl.toBuffer(undefined, fabric.Image.pngCompression);
	        // onload doesn't fire in some node versions, so we invoke callback manually
	        _this._element = replacement;
	        !forResizing && (_this._filteredEl = replacement);
	        callback && callback();
	      }
	      else {
	        replacement.onload = function() {
	          _this._element = replacement;
	          !forResizing && (_this._filteredEl = replacement);
	          callback && callback();
	          replacement.onload = canvasEl = imgEl = null;
	        };
	        replacement.src = canvasEl.toDataURL('image/png');
	      }
	      return canvasEl;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx, noTransform) {
	      var x, y, imageMargins = this._findMargins(), elementToDraw;
	
	      x = (noTransform ? this.left : -this.width / 2);
	      y = (noTransform ? this.top : -this.height / 2);
	
	      if (this.meetOrSlice === 'slice') {
	        ctx.beginPath();
	        ctx.rect(x, y, this.width, this.height);
	        ctx.clip();
	      }
	
	      if (this.isMoving === false && this.resizeFilters.length && this._needsResize()) {
	        this._lastScaleX = this.scaleX;
	        this._lastScaleY = this.scaleY;
	        elementToDraw = this.applyFilters(null, this.resizeFilters, this._filteredEl || this._originalElement, true);
	      }
	      else {
	        elementToDraw = this._element;
	      }
	      elementToDraw && ctx.drawImage(elementToDraw,
	                                     x + imageMargins.marginX,
	                                     y + imageMargins.marginY,
	                                     imageMargins.width,
	                                     imageMargins.height
	                                    );
	
	      this._renderStroke(ctx);
	    },
	
	    /**
	     * @private, needed to check if image needs resize
	     */
	    _needsResize: function() {
	      return (this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY);
	    },
	
	    /**
	     * @private
	     */
	    _findMargins: function() {
	      var width = this.width, height = this.height, scales,
	          scale, marginX = 0, marginY = 0;
	
	      if (this.alignX !== 'none' || this.alignY !== 'none') {
	        scales = [this.width / this._element.width, this.height / this._element.height];
	        scale = this.meetOrSlice === 'meet'
	                ? Math.min.apply(null, scales) : Math.max.apply(null, scales);
	        width = this._element.width * scale;
	        height = this._element.height * scale;
	        if (this.alignX === 'Mid') {
	          marginX = (this.width - width) / 2;
	        }
	        if (this.alignX === 'Max') {
	          marginX = this.width - width;
	        }
	        if (this.alignY === 'Mid') {
	          marginY = (this.height - height) / 2;
	        }
	        if (this.alignY === 'Max') {
	          marginY = this.height - height;
	        }
	      }
	      return {
	        width:  width,
	        height: height,
	        marginX: marginX,
	        marginY: marginY
	      };
	    },
	
	    /**
	     * @private
	     */
	    _resetWidthHeight: function() {
	      var element = this.getElement();
	
	      this.set('width', element.width);
	      this.set('height', element.height);
	    },
	
	    /**
	     * The Image class's initialization method. This method is automatically
	     * called by the constructor.
	     * @private
	     * @param {HTMLImageElement|String} element The element representing the image
	     * @param {Object} [options] Options object
	     */
	    _initElement: function(element, options) {
	      this.setElement(fabric.util.getById(element), null, options);
	      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Options object
	     */
	    _initConfig: function(options) {
	      options || (options = { });
	      this.setOptions(options);
	      this._setWidthHeight(options);
	      if (this._element && this.crossOrigin) {
	        this._element.crossOrigin = this.crossOrigin;
	      }
	    },
	
	    /**
	     * @private
	     * @param {Array} filters to be initialized
	     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
	     */
	    _initFilters: function(filters, callback) {
	      if (filters && filters.length) {
	        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
	          callback && callback(enlivenedObjects);
	        }, 'fabric.Image.filters');
	      }
	      else {
	        callback && callback();
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} [options] Object with width/height properties
	     */
	    _setWidthHeight: function(options) {
	      this.width = 'width' in options
	        ? options.width
	        : (this.getElement()
	            ? this.getElement().width || 0
	            : 0);
	
	      this.height = 'height' in options
	        ? options.height
	        : (this.getElement()
	            ? this.getElement().height || 0
	            : 0);
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity of this instance
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /**
	   * Default CSS class name for canvas
	   * @static
	   * @type String
	   * @default
	   */
	  fabric.Image.CSS_CANVAS = 'canvas-img';
	
	  /**
	   * Alias for getSrc
	   * @static
	   */
	  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;
	
	  /**
	   * Creates an instance of fabric.Image from its object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when an image instance is created
	   */
	  fabric.Image.fromObject = function(object, callback) {
	    fabric.util.loadImage(object.src, function(img) {
	      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
	        object.filters = filters || [ ];
	        fabric.Image.prototype._initFilters.call(object, object.resizeFilters, function(resizeFilters) {
	          object.resizeFilters = resizeFilters || [ ];
	          var instance = new fabric.Image(img, object);
	          callback && callback(instance);
	        });
	      });
	    }, null, object.crossOrigin);
	  };
	
	  /**
	   * Creates an instance of fabric.Image from an URL string
	   * @static
	   * @param {String} url URL to create an image from
	   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)
	   * @param {Object} [imgOptions] Options object
	   */
	  fabric.Image.fromURL = function(url, callback, imgOptions) {
	    fabric.util.loadImage(url, function(img) {
	      callback && callback(new fabric.Image(img, imgOptions));
	    }, null, imgOptions && imgOptions.crossOrigin);
	  };
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
	   * @static
	   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
	   */
	  fabric.Image.ATTRIBUTE_NAMES =
	    fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href'.split(' '));
	
	  /**
	   * Returns {@link fabric.Image} instance from an SVG element
	   * @static
	   * @param {SVGElement} element Element to parse
	   * @param {Function} callback Callback to execute when fabric.Image object is created
	   * @param {Object} [options] Options object
	   * @return {fabric.Image} Instance of fabric.Image
	   */
	  fabric.Image.fromElement = function(element, callback, options) {
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES),
	        align = 'xMidYMid', meetOrSlice = 'meet', alignX, alignY, aspectRatioAttrs;
	
	    if (parsedAttributes.preserveAspectRatio) {
	      aspectRatioAttrs = parsedAttributes.preserveAspectRatio.split(' ');
	    }
	
	    if (aspectRatioAttrs && aspectRatioAttrs.length) {
	      meetOrSlice = aspectRatioAttrs.pop();
	      if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
	        align = meetOrSlice;
	        meetOrSlice = 'meet';
	      }
	      else if (aspectRatioAttrs.length) {
	        align = aspectRatioAttrs.pop();
	      }
	    }
	    //divide align in alignX and alignY
	    alignX = align !== 'none' ? align.slice(1, 4) : 'none';
	    alignY = align !== 'none' ? align.slice(5, 8) : 'none';
	    parsedAttributes.alignX = alignX;
	    parsedAttributes.alignY = alignY;
	    parsedAttributes.meetOrSlice = meetOrSlice;
	    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
	      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @type Boolean
	   * @default
	   */
	  fabric.Image.async = true;
	
	  /**
	   * Indicates compression level used when generating PNG under Node (in applyFilters). Any of 0-9
	   * @static
	   * @type Number
	   * @default
	   */
	  fabric.Image.pngCompression = 1;
	
	})( true ? exports : this);
	
	
	fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
	
	  /**
	   * @private
	   * @return {Number} angle value
	   */
	  _getAngleValueForStraighten: function() {
	    var angle = this.getAngle() % 360;
	    if (angle > 0) {
	      return Math.round((angle - 1) / 90) * 90;
	    }
	    return Math.round(angle / 90) * 90;
	  },
	
	  /**
	   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  straighten: function() {
	    this.setAngle(this._getAngleValueForStraighten());
	    return this;
	  },
	
	  /**
	   * Same as {@link fabric.Object.prototype.straighten} but with animation
	   * @param {Object} callbacks Object with callback functions
	   * @param {Function} [callbacks.onComplete] Invoked on completion
	   * @param {Function} [callbacks.onChange] Invoked on every step of animation
	   * @return {fabric.Object} thisArg
	   * @chainable
	   */
	  fxStraighten: function(callbacks) {
	    callbacks = callbacks || { };
	
	    var empty = function() { },
	        onComplete = callbacks.onComplete || empty,
	        onChange = callbacks.onChange || empty,
	        _this = this;
	
	    fabric.util.animate({
	      startValue: this.get('angle'),
	      endValue: this._getAngleValueForStraighten(),
	      duration: this.FX_DURATION,
	      onChange: function(value) {
	        _this.setAngle(value);
	        onChange();
	      },
	      onComplete: function() {
	        _this.setCoords();
	        onComplete();
	      },
	      onStart: function() {
	        _this.set('active', false);
	      }
	    });
	
	    return this;
	  }
	});
	
	fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {
	
	  /**
	   * Straightens object, then rerenders canvas
	   * @param {fabric.Object} object Object to straighten
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  straightenObject: function (object) {
	    object.straighten();
	    this.renderAll();
	    return this;
	  },
	
	  /**
	   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
	   * @param {fabric.Object} object Object to straighten
	   * @return {fabric.Canvas} thisArg
	   * @chainable
	   */
	  fxStraightenObject: function (object) {
	    object.fxStraighten({
	      onChange: this.renderAll.bind(this)
	    });
	    return this;
	  }
	});
	
	
	/**
	 * @namespace fabric.Image.filters
	 * @memberOf fabric.Image
	 * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#image_filters}
	 * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	 */
	fabric.Image.filters = fabric.Image.filters || { };
	
	/**
	 * Root filter class from which all filter classes inherit from
	 * @class fabric.Image.filters.BaseFilter
	 * @memberOf fabric.Image.filters
	 */
	fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {
	
	  /**
	   * Filter type
	   * @param {String} type
	   * @default
	   */
	  type: 'BaseFilter',
	
	  /**
	   * Constructor
	   * @param {Object} [options] Options object
	   */
	  initialize: function(options) {
	    if (options) {
	      this.setOptions(options);
	    }
	  },
	
	  /**
	   * Sets filter's properties from options
	   * @param {Object} [options] Options object
	   */
	  setOptions: function(options) {
	    for (var prop in options) {
	      this[prop] = options[prop];
	    }
	  },
	
	  /**
	   * Returns object representation of an instance
	   * @return {Object} Object representation of an instance
	   */
	  toObject: function() {
	    return { type: this.type };
	  },
	
	  /**
	   * Returns a JSON representation of an instance
	   * @return {Object} JSON
	   */
	  toJSON: function() {
	    // delegate, not alias
	    return this.toObject();
	  }
	});
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  /**
	   * Brightness filter class
	   * @class fabric.Image.filters.Brightness
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Brightness({
	   *   brightness: 200
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Brightness = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Brightness',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Brightness.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.brightness=0] Value to brighten the image up (0..255)
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.brightness = options.brightness || 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          brightness = this.brightness;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        data[i] += brightness;
	        data[i + 1] += brightness;
	        data[i + 2] += brightness;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        brightness: this.brightness
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
	   */
	  fabric.Image.filters.Brightness.fromObject = function(object) {
	    return new fabric.Image.filters.Brightness(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  /**
	   * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
	   * @class fabric.Image.filters.Convolute
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example <caption>Sharpen filter</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   matrix: [ 0, -1,  0,
	   *            -1,  5, -1,
	   *             0, -1,  0 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Blur filter</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   matrix: [ 1/9, 1/9, 1/9,
	   *             1/9, 1/9, 1/9,
	   *             1/9, 1/9, 1/9 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Emboss filter</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   matrix: [ 1,   1,  1,
	   *             1, 0.7, -1,
	   *            -1,  -1, -1 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Emboss filter with opaqueness</caption>
	   * var filter = new fabric.Image.filters.Convolute({
	   *   opaque: true,
	   *   matrix: [ 1,   1,  1,
	   *             1, 0.7, -1,
	   *            -1,  -1, -1 ]
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Convolute = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Convolute',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Convolute.prototype
	     * @param {Object} [options] Options object
	     * @param {Boolean} [options.opaque=false] Opaque value (true/false)
	     * @param {Array} [options.matrix] Filter matrix
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.opaque = options.opaque;
	      this.matrix = options.matrix || [
	        0, 0, 0,
	        0, 1, 0,
	        0, 0, 0
	      ];
	
	      var canvasEl = fabric.util.createCanvasElement();
	      this.tmpCtx = canvasEl.getContext('2d');
	    },
	
	    /**
	     * @private
	     */
	    _createImageData: function(w, h) {
	      return this.tmpCtx.createImageData(w, h);
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	
	      var weights = this.matrix,
	          context = canvasEl.getContext('2d'),
	          pixels = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	
	          side = Math.round(Math.sqrt(weights.length)),
	          halfSide = Math.floor(side/2),
	          src = pixels.data,
	          sw = pixels.width,
	          sh = pixels.height,
	
	          // pad output by the convolution matrix
	          w = sw,
	          h = sh,
	          output = this._createImageData(w, h),
	
	          dst = output.data,
	
	          // go through the destination image pixels
	          alphaFac = this.opaque ? 1 : 0;
	
	      for (var y = 0; y < h; y++) {
	        for (var x = 0; x < w; x++) {
	          var sy = y,
	              sx = x,
	              dstOff = (y * w + x) * 4,
	              // calculate the weighed sum of the source image pixels that
	              // fall under the convolution matrix
	              r = 0, g = 0, b = 0, a = 0;
	
	          for (var cy = 0; cy < side; cy++) {
	            for (var cx = 0; cx < side; cx++) {
	
	              var scy = sy + cy - halfSide,
	                  scx = sx + cx - halfSide;
	
	              /* jshint maxdepth:5 */
	              if (scy < 0 || scy > sh || scx < 0 || scx > sw) {
	                continue;
	              }
	
	              var srcOff = (scy * sw + scx) * 4,
	                  wt = weights[cy * side + cx];
	
	              r += src[srcOff] * wt;
	              g += src[srcOff + 1] * wt;
	              b += src[srcOff + 2] * wt;
	              a += src[srcOff + 3] * wt;
	            }
	          }
	          dst[dstOff] = r;
	          dst[dstOff + 1] = g;
	          dst[dstOff + 2] = b;
	          dst[dstOff + 3] = a + alphaFac * (255 - a);
	        }
	      }
	
	      context.putImageData(output, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        opaque: this.opaque,
	        matrix: this.matrix
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
	   */
	  fabric.Image.filters.Convolute.fromObject = function(object) {
	    return new fabric.Image.filters.Convolute(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  /**
	   * GradientTransparency filter class
	   * @class fabric.Image.filters.GradientTransparency
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.GradientTransparency#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.GradientTransparency({
	   *   threshold: 200
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.GradientTransparency = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.GradientTransparency.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'GradientTransparency',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.GradientTransparency.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.threshold=100] Threshold value
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.threshold = options.threshold || 100;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          threshold = this.threshold,
	          total = data.length;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        data[i + 3] = threshold + 255 * (total - i) / total;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        threshold: this.threshold
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.GradientTransparency} Instance of fabric.Image.filters.GradientTransparency
	   */
	  fabric.Image.filters.GradientTransparency.fromObject = function(object) {
	    return new fabric.Image.filters.GradientTransparency(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { });
	
	  /**
	   * Grayscale image filter class
	   * @class fabric.Image.filters.Grayscale
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Grayscale();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Grayscale = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Grayscale',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Grayscale.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          len = imageData.width * imageData.height * 4,
	          index = 0,
	          average;
	
	      while (index < len) {
	        average = (data[index] + data[index + 1] + data[index + 2]) / 3;
	        data[index]     = average;
	        data[index + 1] = average;
	        data[index + 2] = average;
	        index += 4;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
	   */
	  fabric.Image.filters.Grayscale.fromObject = function() {
	    return new fabric.Image.filters.Grayscale();
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { });
	
	  /**
	   * Invert filter class
	   * @class fabric.Image.filters.Invert
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Invert();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Invert = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Invert',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Invert.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i;
	
	      for (i = 0; i < iLen; i+=4) {
	        data[i] = 255 - data[i];
	        data[i + 1] = 255 - data[i + 1];
	        data[i + 2] = 255 - data[i + 2];
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
	   */
	  fabric.Image.filters.Invert.fromObject = function() {
	    return new fabric.Image.filters.Invert();
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  /**
	   * Mask filter class
	   * See http://resources.aleph-1.com/mask/
	   * @class fabric.Image.filters.Mask
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Mask#initialize} for constructor definition
	   */
	  fabric.Image.filters.Mask = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Mask.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Mask',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Mask.prototype
	     * @param {Object} [options] Options object
	     * @param {fabric.Image} [options.mask] Mask image object
	     * @param {Number} [options.channel=0] Rgb channel (0, 1, 2 or 3)
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.mask = options.mask;
	      this.channel = [ 0, 1, 2, 3 ].indexOf(options.channel) > -1 ? options.channel : 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      if (!this.mask) {
	        return;
	      }
	
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          maskEl = this.mask.getElement(),
	          maskCanvasEl = fabric.util.createCanvasElement(),
	          channel = this.channel,
	          i,
	          iLen = imageData.width * imageData.height * 4;
	
	      maskCanvasEl.width = maskEl.width;
	      maskCanvasEl.height = maskEl.height;
	
	      maskCanvasEl.getContext('2d').drawImage(maskEl, 0, 0, maskEl.width, maskEl.height);
	
	      var maskImageData = maskCanvasEl.getContext('2d').getImageData(0, 0, maskEl.width, maskEl.height),
	          maskData = maskImageData.data;
	
	      for (i = 0; i < iLen; i += 4) {
	        data[i + 3] = maskData[i + channel];
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        mask: this.mask.toObject(),
	        channel: this.channel
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @param {Function} [callback] Callback to invoke when a mask filter instance is created
	   */
	  fabric.Image.filters.Mask.fromObject = function(object, callback) {
	    fabric.util.loadImage(object.mask.src, function(img) {
	      object.mask = new fabric.Image(img, object.mask);
	      callback && callback(new fabric.Image.filters.Mask(object));
	    });
	  };
	
	  /**
	   * Indicates that instances of this type are async
	   * @static
	   * @type Boolean
	   * @default
	   */
	  fabric.Image.filters.Mask.async = true;
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  /**
	   * Noise filter class
	   * @class fabric.Image.filters.Noise
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Noise({
	   *   noise: 700
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Noise = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Noise',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Noise.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.noise=0] Noise value
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.noise = options.noise || 0;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          noise = this.noise, rand;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	
	        rand = (0.5 - Math.random()) * noise;
	
	        data[i] += rand;
	        data[i + 1] += rand;
	        data[i + 2] += rand;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        noise: this.noise
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
	   */
	  fabric.Image.filters.Noise.fromObject = function(object) {
	    return new fabric.Image.filters.Noise(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  /**
	   * Pixelate filter class
	   * @class fabric.Image.filters.Pixelate
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Pixelate({
	   *   blocksize: 8
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Pixelate = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Pixelate',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Pixelate.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.blocksize=4] Blocksize for pixelate
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.blocksize = options.blocksize || 4;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = imageData.height,
	          jLen = imageData.width,
	          index, i, j, r, g, b, a;
	
	      for (i = 0; i < iLen; i += this.blocksize) {
	        for (j = 0; j < jLen; j += this.blocksize) {
	
	          index = (i * 4) * jLen + (j * 4);
	
	          r = data[index];
	          g = data[index + 1];
	          b = data[index + 2];
	          a = data[index + 3];
	
	          /*
	           blocksize: 4
	
	           [1,x,x,x,1]
	           [x,x,x,x,1]
	           [x,x,x,x,1]
	           [x,x,x,x,1]
	           [1,1,1,1,1]
	           */
	
	          for (var _i = i, _ilen = i + this.blocksize; _i < _ilen; _i++) {
	            for (var _j = j, _jlen = j + this.blocksize; _j < _jlen; _j++) {
	              index = (_i * 4) * jLen + (_j * 4);
	              data[index] = r;
	              data[index + 1] = g;
	              data[index + 2] = b;
	              data[index + 3] = a;
	            }
	          }
	        }
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        blocksize: this.blocksize
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
	   */
	  fabric.Image.filters.Pixelate.fromObject = function(object) {
	    return new fabric.Image.filters.Pixelate(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  /**
	   * Remove white filter class
	   * @class fabric.Image.filters.RemoveWhite
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.RemoveWhite#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.RemoveWhite({
	   *   threshold: 40,
	   *   distance: 140
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.RemoveWhite = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.RemoveWhite.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'RemoveWhite',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.RemoveWhite.prototype
	     * @param {Object} [options] Options object
	     * @param {Number} [options.threshold=30] Threshold value
	     * @param {Number} [options.distance=20] Distance value
	     */
	    initialize: function(options) {
	      options = options || { };
	      this.threshold = options.threshold || 30;
	      this.distance = options.distance || 20;
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          threshold = this.threshold,
	          distance = this.distance,
	          limit = 255 - threshold,
	          abs = Math.abs,
	          r, g, b;
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        if (r > limit &&
	            g > limit &&
	            b > limit &&
	            abs(r - g) < distance &&
	            abs(r - b) < distance &&
	            abs(g - b) < distance
	        ) {
	          data[i + 3] = 1;
	        }
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        threshold: this.threshold,
	        distance: this.distance
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.RemoveWhite} Instance of fabric.Image.filters.RemoveWhite
	   */
	  fabric.Image.filters.RemoveWhite.fromObject = function(object) {
	    return new fabric.Image.filters.RemoveWhite(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { });
	
	  /**
	   * Sepia filter class
	   * @class fabric.Image.filters.Sepia
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Sepia();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Sepia = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Sepia.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Sepia',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Sepia.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i, avg;
	
	      for (i = 0; i < iLen; i+=4) {
	        avg = 0.3  * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];
	        data[i] = avg + 100;
	        data[i + 1] = avg + 50;
	        data[i + 2] = avg + 255;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @return {fabric.Image.filters.Sepia} Instance of fabric.Image.filters.Sepia
	   */
	  fabric.Image.filters.Sepia.fromObject = function() {
	    return new fabric.Image.filters.Sepia();
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { });
	
	  /**
	   * Sepia2 filter class
	   * @class fabric.Image.filters.Sepia2
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Sepia2();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Sepia2 = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Sepia2.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Sepia2',
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Sepia.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i, r, g, b;
	
	      for (i = 0; i < iLen; i+=4) {
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        data[i] = (r * 0.393 + g * 0.769 + b * 0.189 ) / 1.351;
	        data[i + 1] = (r * 0.349 + g * 0.686 + b * 0.168 ) / 1.203;
	        data[i + 2] = (r * 0.272 + g * 0.534 + b * 0.131 ) / 2.140;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @return {fabric.Image.filters.Sepia2} Instance of fabric.Image.filters.Sepia2
	   */
	  fabric.Image.filters.Sepia2.fromObject = function() {
	    return new fabric.Image.filters.Sepia2();
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  /**
	   * Tint filter class
	   * Adapted from <a href="https://github.com/mezzoblue/PaintbrushJS">https://github.com/mezzoblue/PaintbrushJS</a>
	   * @class fabric.Image.filters.Tint
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link fabric.Image.filters.Tint#initialize} for constructor definition
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example <caption>Tint filter with hex color and opacity</caption>
	   * var filter = new fabric.Image.filters.Tint({
	   *   color: '#3513B0',
	   *   opacity: 0.5
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Tint filter with rgba color</caption>
	   * var filter = new fabric.Image.filters.Tint({
	   *   color: 'rgba(53, 21, 176, 0.5)'
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Tint = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Tint.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Tint',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Tint.prototype
	     * @param {Object} [options] Options object
	     * @param {String} [options.color=#000000] Color to tint the image with
	     * @param {Number} [options.opacity] Opacity value that controls the tint effect's transparency (0..1)
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.color = options.color || '#000000';
	      this.opacity = typeof options.opacity !== 'undefined'
	                      ? options.opacity
	                      : new fabric.Color(this.color).getAlpha();
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i,
	          tintR, tintG, tintB,
	          r, g, b, alpha1,
	          source;
	
	      source = new fabric.Color(this.color).getSource();
	
	      tintR = source[0] * this.opacity;
	      tintG = source[1] * this.opacity;
	      tintB = source[2] * this.opacity;
	
	      alpha1 = 1 - this.opacity;
	
	      for (i = 0; i < iLen; i+=4) {
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        // alpha compositing
	        data[i] = tintR + r * alpha1;
	        data[i + 1] = tintG + g * alpha1;
	        data[i + 2] = tintB + b * alpha1;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        color: this.color,
	        opacity: this.opacity
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Tint} Instance of fabric.Image.filters.Tint
	   */
	  fabric.Image.filters.Tint.fromObject = function(object) {
	    return new fabric.Image.filters.Tint(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend;
	
	  /**
	   * Multiply filter class
	   * Adapted from <a href="http://www.laurenscorijn.com/articles/colormath-basics">http://www.laurenscorijn.com/articles/colormath-basics</a>
	   * @class fabric.Image.filters.Multiply
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @example <caption>Multiply filter with hex color</caption>
	   * var filter = new fabric.Image.filters.Multiply({
	   *   color: '#F0F'
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   * @example <caption>Multiply filter with rgb color</caption>
	   * var filter = new fabric.Image.filters.Multiply({
	   *   color: 'rgb(53, 21, 176)'
	   * });
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Multiply = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Multiply.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Multiply',
	
	    /**
	     * Constructor
	     * @memberOf fabric.Image.filters.Multiply.prototype
	     * @param {Object} [options] Options object
	     * @param {String} [options.color=#000000] Color to multiply the image pixels with
	     */
	    initialize: function(options) {
	      options = options || { };
	
	      this.color = options.color || '#000000';
	    },
	
	    /**
	     * Applies filter to canvas element
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          iLen = data.length, i,
	          source;
	
	      source = new fabric.Color(this.color).getSource();
	
	      for (i = 0; i < iLen; i+=4) {
	        data[i] *= source[0] / 255;
	        data[i + 1] *= source[1] / 255;
	        data[i + 2] *= source[2] / 255;
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return extend(this.callSuper('toObject'), {
	        color: this.color
	      });
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Image.filters.Multiply} Instance of fabric.Image.filters.Multiply
	   */
	  fabric.Image.filters.Multiply.fromObject = function(object) {
	    return new fabric.Image.filters.Multiply(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	  'use strict';
	
	  var fabric = global.fabric;
	
	  /**
	   * Color Blend filter class
	   * @class fabric.Image.filter.Blend
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @example
	   * var filter = new fabric.Image.filters.Blend({
	   *  color: '#000',
	   *  mode: 'multiply'
	   * });
	   *
	   * var filter = new fabric.Image.filters.Blend({
	   *  image: fabricImageObject,
	   *  mode: 'multiply',
	   *  alpha: 0.5
	   * });
	
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Blend = fabric.util.createClass({
	    type: 'Blend',
	
	    initialize: function(options) {
	      options = options || {};
	      this.color = options.color || '#000';
	      this.image = options.image || false;
	      this.mode = options.mode || 'multiply';
	      this.alpha = options.alpha || 1;
	    },
	
	    applyTo: function(canvasEl) {
	      var context = canvasEl.getContext('2d'),
	          imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
	          data = imageData.data,
	          tr, tg, tb,
	          r, g, b,
	          _r, _g, _b,
	          source,
	          isImage = false;
	
	      if (this.image) {
	        // Blend images
	        isImage = true;
	
	        var _el = fabric.util.createCanvasElement();
	        _el.width = this.image.width;
	        _el.height = this.image.height;
	
	        var tmpCanvas = new fabric.StaticCanvas(_el);
	        tmpCanvas.add(this.image);
	        var context2 =  tmpCanvas.getContext('2d');
	        source = context2.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height).data;
	      }
	      else {
	        // Blend color
	        source = new fabric.Color(this.color).getSource();
	
	        tr = source[0] * this.alpha;
	        tg = source[1] * this.alpha;
	        tb = source[2] * this.alpha;
	      }
	
	      for (var i = 0, len = data.length; i < len; i += 4) {
	
	        r = data[i];
	        g = data[i + 1];
	        b = data[i + 2];
	
	        if (isImage) {
	          tr = source[i] * this.alpha;
	          tg = source[i + 1] * this.alpha;
	          tb = source[i + 2] * this.alpha;
	        }
	
	        switch (this.mode) {
	          case 'multiply':
	            data[i] = r * tr / 255;
	            data[i + 1] = g * tg / 255;
	            data[i + 2] = b * tb / 255;
	            break;
	          case 'screen':
	            data[i] = 1 - (1 - r) * (1 - tr);
	            data[i + 1] = 1 - (1 - g) * (1 - tg);
	            data[i + 2] = 1 - (1 - b) * (1 - tb);
	            break;
	          case 'add':
	            data[i] = Math.min(255, r + tr);
	            data[i + 1] = Math.min(255, g + tg);
	            data[i + 2] = Math.min(255, b + tb);
	            break;
	          case 'diff':
	          case 'difference':
	            data[i] = Math.abs(r - tr);
	            data[i + 1] = Math.abs(g - tg);
	            data[i + 2] = Math.abs(b - tb);
	            break;
	          case 'subtract':
	            _r = r - tr;
	            _g = g - tg;
	            _b = b - tb;
	
	            data[i] = (_r < 0) ? 0 : _r;
	            data[i + 1] = (_g < 0) ? 0 : _g;
	            data[i + 2] = (_b < 0) ? 0 : _b;
	            break;
	          case 'darken':
	            data[i] = Math.min(r, tr);
	            data[i + 1] = Math.min(g, tg);
	            data[i + 2] = Math.min(b, tb);
	            break;
	          case 'lighten':
	            data[i] = Math.max(r, tr);
	            data[i + 1] = Math.max(g, tg);
	            data[i + 2] = Math.max(b, tb);
	            break;
	        }
	      }
	
	      context.putImageData(imageData, 0, 0);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return {
	        color: this.color,
	        image: this.image,
	        mode: this.mode,
	        alpha: this.alpha
	      };
	    }
	  });
	
	  fabric.Image.filters.Blend.fromObject = function(object) {
	    return new fabric.Image.filters.Blend(object);
	  };
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
	      sqrt = Math.sqrt, abs = Math.abs, max = Math.max, round = Math.round, sin = Math.sin,
	      ceil = Math.ceil;
	
	  /**
	   * Resize image filter class
	   * @class fabric.Image.filters.Resize
	   * @memberOf fabric.Image.filters
	   * @extends fabric.Image.filters.BaseFilter
	   * @see {@link http://fabricjs.com/image-filters/|ImageFilters demo}
	   * @example
	   * var filter = new fabric.Image.filters.Resize();
	   * object.filters.push(filter);
	   * object.applyFilters(canvas.renderAll.bind(canvas));
	   */
	  fabric.Image.filters.Resize = fabric.util.createClass(fabric.Image.filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {
	
	    /**
	     * Filter type
	     * @param {String} type
	     * @default
	     */
	    type: 'Resize',
	
	    /**
	     * Resize type
	     * @param {String} resizeType
	     * @default
	     */
	    resizeType: 'hermite',
	
	    /**
	     * Scale factor for resizing, x axis
	     * @param {Number} scaleX
	     * @default
	     */
	    scaleX: 0,
	
	    /**
	     * Scale factor for resizing, y axis
	     * @param {Number} scaleY
	     * @default
	     */
	    scaleY: 0,
	
	    /**
	     * LanczosLobes parameter for lanczos filter
	     * @param {Number} lanczosLobes
	     * @default
	     */
	    lanczosLobes: 3,
	
	    /**
	     * Applies filter to canvas element
	     * @memberOf fabric.Image.filters.Resize.prototype
	     * @param {Object} canvasEl Canvas element to apply filter to
	     */
	    applyTo: function(canvasEl, scaleX, scaleY) {
	
	      this.rcpScaleX = 1 / scaleX;
	      this.rcpScaleY = 1 / scaleY;
	
	      var oW = canvasEl.width, oH = canvasEl.height,
	          dW = round(oW * scaleX), dH = round(oH * scaleY),
	          imageData;
	
	      if (this.resizeType === 'sliceHack') {
	        imageData = this.sliceByTwo(canvasEl, oW, oH, dW, dH);
	      }
	      if (this.resizeType === 'hermite') {
	        imageData = this.hermiteFastResize(canvasEl, oW, oH, dW, dH);
	      }
	      if (this.resizeType === 'bilinear') {
	        imageData = this.bilinearFiltering(canvasEl, oW, oH, dW, dH);
	      }
	      if (this.resizeType === 'lanczos') {
	        imageData = this.lanczosResize(canvasEl, oW, oH, dW, dH);
	      }
	      canvasEl.width = dW;
	      canvasEl.height = dH;
	      canvasEl.getContext('2d').putImageData(imageData, 0, 0);
	    },
	
	    sliceByTwo: function(canvasEl, width, height, newWidth, newHeight) {
	      var context = canvasEl.getContext('2d'), imageData,
	          multW = 0.5, multH = 0.5, signW = 1, signH = 1,
	          doneW = false, doneH = false, stepW = width, stepH = height,
	          tmpCanvas = fabric.util.createCanvasElement(),
	          tmpCtx = tmpCanvas.getContext('2d');
	      newWidth = floor(newWidth);
	      newHeight = floor(newHeight);
	      tmpCanvas.width = max(newWidth, width);
	      tmpCanvas.height = max(newHeight, height);
	
	      if (newWidth > width) {
	        multW = 2;
	        signW = -1;
	      }
	      if (newHeight > height) {
	        multH = 2;
	        signH = -1;
	      }
	      imageData = context.getImageData(0, 0, width, height);
	      canvasEl.width = max(newWidth, width);
	      canvasEl.height = max(newHeight, height);
	      context.putImageData(imageData, 0, 0);
	
	      while (!doneW || !doneH) {
	        width = stepW;
	        height = stepH;
	        if (newWidth * signW < floor(stepW * multW * signW)) {
	          stepW = floor(stepW * multW);
	        }
	        else {
	          stepW = newWidth;
	          doneW = true;
	        }
	        if (newHeight * signH < floor(stepH * multH * signH)) {
	          stepH = floor(stepH * multH);
	        }
	        else {
	          stepH = newHeight;
	          doneH = true;
	        }
	        imageData = context.getImageData(0, 0, width, height);
	        tmpCtx.putImageData(imageData, 0, 0);
	        context.clearRect(0, 0, stepW, stepH);
	        context.drawImage(tmpCanvas, 0, 0, width, height, 0, 0, stepW, stepH);
	      }
	      return context.getImageData(0, 0, newWidth, newHeight);
	    },
	
	    lanczosResize: function(canvasEl, oW, oH, dW, dH) {
	
	      function lanczosCreate(lobes) {
	        return function(x) {
	          if (x > lobes) {
	            return 0;
	          }
	          x *= Math.PI;
	          if (abs(x) < 1e-16) {
	            return 1;
	          }
	          var xx = x / lobes;
	          return sin(x) * sin(xx) / x / xx;
	        };
	      }
	
	      function process(u) {
	        var v, i, weight, idx, a, red, green,
	            blue, alpha, fX, fY;
	        center.x = (u + 0.5) * ratioX;
	        icenter.x = floor(center.x);
	        for (v = 0; v < dH; v++) {
	          center.y = (v + 0.5) * ratioY;
	          icenter.y = floor(center.y);
	          a = 0, red = 0, green = 0, blue = 0, alpha = 0;
	          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
	            if (i < 0 || i >= oW) {
	              continue;
	            }
	            fX = floor(1000 * abs(i - center.x));
	            if (!cacheLanc[fX]) {
	              cacheLanc[fX] = { };
	            }
	            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
	              if (j < 0 || j >= oH) {
	                continue;
	              }
	              fY = floor(1000 * abs(j - center.y));
	              if (!cacheLanc[fX][fY]) {
	                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
	              }
	              weight = cacheLanc[fX][fY];
	              if (weight > 0) {
	                idx = (j * oW + i) * 4;
	                a += weight;
	                red += weight * srcData[idx];
	                green += weight * srcData[idx + 1];
	                blue += weight * srcData[idx + 2];
	                alpha += weight * srcData[idx + 3];
	              }
	            }
	          }
	          idx = (v * dW + u) * 4;
	          destData[idx] = red / a;
	          destData[idx + 1] = green / a;
	          destData[idx + 2] = blue / a;
	          destData[idx + 3] = alpha / a;
	        }
	
	        if (++u < dW) {
	          return process(u);
	        }
	        else {
	          return destImg;
	        }
	      }
	
	      var context = canvasEl.getContext('2d'),
	          srcImg = context.getImageData(0, 0, oW, oH),
	          destImg = context.getImageData(0, 0, dW, dH),
	          srcData = srcImg.data, destData = destImg.data,
	          lanczos = lanczosCreate(this.lanczosLobes),
	          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
	          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
	          range2X = ceil(ratioX * this.lanczosLobes / 2),
	          range2Y = ceil(ratioY * this.lanczosLobes / 2),
	          cacheLanc = { }, center = { }, icenter = { };
	
	      return process(0);
	    },
	
	    bilinearFiltering: function(canvasEl, w, h, w2, h2) {
	      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
	          color, offset = 0, origPix, ratioX = this.rcpScaleX,
	          ratioY = this.rcpScaleY, context = canvasEl.getContext('2d'),
	          w4 = 4 * (w - 1), img = context.getImageData(0, 0, w, h),
	          pixels = img.data, destImage = context.getImageData(0, 0, w2, h2),
	          destPixels = destImage.data;
	      for (i = 0; i < h2; i++) {
	        for (j = 0; j < w2; j++) {
	          x = floor(ratioX * j);
	          y = floor(ratioY * i);
	          xDiff = ratioX * j - x;
	          yDiff = ratioY * i - y;
	          origPix = 4 * (y * w + x);
	
	          for (chnl = 0; chnl < 4; chnl++) {
	            a = pixels[origPix + chnl];
	            b = pixels[origPix + 4 + chnl];
	            c = pixels[origPix + w4 + chnl];
	            d = pixels[origPix + w4 + 4 + chnl];
	            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
	                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
	            destPixels[offset++] = color;
	          }
	        }
	      }
	      return destImage;
	    },
	
	    hermiteFastResize: function(canvasEl, oW, oH, dW, dH) {
	      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
	          ratioWHalf = ceil(ratioW / 2),
	          ratioHHalf = ceil(ratioH / 2),
	          context = canvasEl.getContext('2d'),
	          img = context.getImageData(0, 0, oW, oH), data = img.data,
	          img2 = context.getImageData(0, 0, dW, dH), data2 = img2.data;
	      for (var j = 0; j < dH; j++) {
	        for (var i = 0; i < dW; i++) {
	          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
	              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
	          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
	            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
	                centerX = (i + 0.5) * ratioW, w0 = dy * dy;
	            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
	              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
	                  w = sqrt(w0 + dx * dx);
	              /*jshint maxdepth:5 */
	              if (w > 1 && w < -1) {
	                continue;
	              }
	              //hermite filter
	              weight = 2 * w * w * w - 3 * w * w + 1;
	              if (weight > 0) {
	                dx = 4 * (xx + yy * oW);
	                //alpha
	                gxA += weight * data[dx + 3];
	                weightsAlpha += weight;
	                //colors
	                /*jshint maxdepth:6 */
	                if (data[dx + 3] < 255) {
	                  weight = weight * data[dx + 3] / 250;
	                }
	                /*jshint maxdepth:5 */
	                gxR += weight * data[dx];
	                gxG += weight * data[dx + 1];
	                gxB += weight * data[dx + 2];
	                weights += weight;
	              }
	              /*jshint maxdepth:4 */
	            }
	          }
	          data2[x2] = gxR / weights;
	          data2[x2 + 1] = gxG / weights;
	          data2[x2 + 2] = gxB / weights;
	          data2[x2 + 3] = gxA / weightsAlpha;
	        }
	      }
	      return img2;
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function() {
	      return {
	        type: this.type,
	        scaleX: this.scaleX,
	        scaleY: this.scaleY,
	        resizeType: this.resizeType,
	        lanczosLobes: this.lanczosLobes
	      };
	    }
	  });
	
	  /**
	   * Returns filter instance from an object representation
	   * @static
	   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
	   */
	  fabric.Image.filters.Resize.fromObject = function(object) {
	    return new fabric.Image.filters.Resize(object);
	  };
	
	})( true ? exports : this);
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = { }),
	      extend = fabric.util.object.extend,
	      clone = fabric.util.object.clone,
	      toFixed = fabric.util.toFixed,
	      supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),
	      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
	
	  if (fabric.Text) {
	    fabric.warn('fabric.Text is already defined');
	    return;
	  }
	
	  var stateProperties = fabric.Object.prototype.stateProperties.concat();
	  stateProperties.push(
	    'fontFamily',
	    'fontWeight',
	    'fontSize',
	    'text',
	    'textDecoration',
	    'textAlign',
	    'fontStyle',
	    'lineHeight',
	    'textBackgroundColor'
	  );
	
	  /**
	   * Text class
	   * @class fabric.Text
	   * @extends fabric.Object
	   * @return {fabric.Text} thisArg
	   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#text}
	   * @see {@link fabric.Text#initialize} for constructor definition
	   */
	  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {
	
	    /**
	     * Properties which when set cause object to change dimensions
	     * @type Object
	     * @private
	     */
	    _dimensionAffectingProps: {
	      fontSize: true,
	      fontWeight: true,
	      fontFamily: true,
	      fontStyle: true,
	      lineHeight: true,
	      stroke: true,
	      strokeWidth: true,
	      text: true,
	      textAlign: true
	    },
	
	    /**
	     * @private
	     */
	    _reNewline: /\r?\n/,
	
	    /**
	     * Use this regular expression to filter for whitespace that is not a new line.
	     * Mostly used when text is 'justify' aligned.
	     * @private
	     */
	    _reSpacesAndTabs: /[ \t\r]+/g,
	
	    /**
	     * Retrieves object's fontSize
	     * @method getFontSize
	     * @memberOf fabric.Text.prototype
	     * @return {String} Font size (in pixels)
	     */
	
	    /**
	     * Sets object's fontSize
	     * @method setFontSize
	     * @memberOf fabric.Text.prototype
	     * @param {Number} fontSize Font size (in pixels)
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's fontWeight
	     * @method getFontWeight
	     * @memberOf fabric.Text.prototype
	     * @return {(String|Number)} Font weight
	     */
	
	    /**
	     * Sets object's fontWeight
	     * @method setFontWeight
	     * @memberOf fabric.Text.prototype
	     * @param {(Number|String)} fontWeight Font weight
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's fontFamily
	     * @method getFontFamily
	     * @memberOf fabric.Text.prototype
	     * @return {String} Font family
	     */
	
	    /**
	     * Sets object's fontFamily
	     * @method setFontFamily
	     * @memberOf fabric.Text.prototype
	     * @param {String} fontFamily Font family
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's text
	     * @method getText
	     * @memberOf fabric.Text.prototype
	     * @return {String} text
	     */
	
	    /**
	     * Sets object's text
	     * @method setText
	     * @memberOf fabric.Text.prototype
	     * @param {String} text Text
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's textDecoration
	     * @method getTextDecoration
	     * @memberOf fabric.Text.prototype
	     * @return {String} Text decoration
	     */
	
	    /**
	     * Sets object's textDecoration
	     * @method setTextDecoration
	     * @memberOf fabric.Text.prototype
	     * @param {String} textDecoration Text decoration
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's fontStyle
	     * @method getFontStyle
	     * @memberOf fabric.Text.prototype
	     * @return {String} Font style
	     */
	
	    /**
	     * Sets object's fontStyle
	     * @method setFontStyle
	     * @memberOf fabric.Text.prototype
	     * @param {String} fontStyle Font style
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's lineHeight
	     * @method getLineHeight
	     * @memberOf fabric.Text.prototype
	     * @return {Number} Line height
	     */
	
	    /**
	     * Sets object's lineHeight
	     * @method setLineHeight
	     * @memberOf fabric.Text.prototype
	     * @param {Number} lineHeight Line height
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's textAlign
	     * @method getTextAlign
	     * @memberOf fabric.Text.prototype
	     * @return {String} Text alignment
	     */
	
	    /**
	     * Sets object's textAlign
	     * @method setTextAlign
	     * @memberOf fabric.Text.prototype
	     * @param {String} textAlign Text alignment
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Retrieves object's textBackgroundColor
	     * @method getTextBackgroundColor
	     * @memberOf fabric.Text.prototype
	     * @return {String} Text background color
	     */
	
	    /**
	     * Sets object's textBackgroundColor
	     * @method setTextBackgroundColor
	     * @memberOf fabric.Text.prototype
	     * @param {String} textBackgroundColor Text background color
	     * @return {fabric.Text}
	     * @chainable
	     */
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type:                 'text',
	
	    /**
	     * Font size (in pixels)
	     * @type Number
	     * @default
	     */
	    fontSize:             40,
	
	    /**
	     * Font weight (e.g. bold, normal, 400, 600, 800)
	     * @type {(Number|String)}
	     * @default
	     */
	    fontWeight:           'normal',
	
	    /**
	     * Font family
	     * @type String
	     * @default
	     */
	    fontFamily:           'Times New Roman',
	
	    /**
	     * Text decoration Possible values: "", "underline", "overline" or "line-through".
	     * @type String
	     * @default
	     */
	    textDecoration:       '',
	
	    /**
	     * Text alignment. Possible values: "left", "center", or "right".
	     * @type String
	     * @default
	     */
	    textAlign:            'left',
	
	    /**
	     * Font style . Possible values: "", "normal", "italic" or "oblique".
	     * @type String
	     * @default
	     */
	    fontStyle:            '',
	
	    /**
	     * Line height
	     * @type Number
	     * @default
	     */
	    lineHeight:           1.16,
	
	    /**
	     * Background color of text lines
	     * @type String
	     * @default
	     */
	    textBackgroundColor:  '',
	
	    /**
	     * List of properties to consider when checking if
	     * state of an object is changed ({@link fabric.Object#hasStateChanged})
	     * as well as for history (undo/redo) purposes
	     * @type Array
	     */
	    stateProperties:      stateProperties,
	
	    /**
	     * When defined, an object is rendered via stroke and this property specifies its color.
	     * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
	     * @type String
	     * @default
	     */
	    stroke:               null,
	
	    /**
	     * Shadow object representing shadow of this shape.
	     * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
	     * @type fabric.Shadow
	     * @default
	     */
	    shadow:               null,
	
	    /**
	     * @private
	     */
	    _fontSizeFraction: 0.25,
	
	    /**
	     * Text Line proportion to font Size (in pixels)
	     * @type Number
	     * @default
	     */
	    _fontSizeMult:             1.13,
	
	    /**
	     * Constructor
	     * @param {String} text Text string
	     * @param {Object} [options] Options object
	     * @return {fabric.Text} thisArg
	     */
	    initialize: function(text, options) {
	      options = options || { };
	      this.text = text;
	      this.__skipDimension = true;
	      this.setOptions(options);
	      this.__skipDimension = false;
	      this._initDimensions();
	    },
	
	    /**
	     * Renders text object on offscreen canvas, so that it would get dimensions
	     * @private
	     */
	    _initDimensions: function(ctx) {
	      if (this.__skipDimension) {
	        return;
	      }
	      if (!ctx) {
	        ctx = fabric.util.createCanvasElement().getContext('2d');
	        this._setTextStyles(ctx);
	      }
	      this._textLines = this._splitTextIntoLines();
	      this._clearCache();
	      //if textAlign is 'justify' i have to disable caching
	      //when calculating width of text and widths of line.
	      this._cacheLinesWidth = (this.textAlign !== 'justify');
	      this.width = this._getTextWidth(ctx);
	      this._cacheLinesWidth = true;
	      this.height = this._getTextHeight(ctx);
	    },
	
	    /**
	     * Returns string representation of an instance
	     * @return {String} String representation of text object
	     */
	    toString: function() {
	      return '#<fabric.Text (' + this.complexity() +
	        '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      this.clipTo && fabric.util.clipContext(this, ctx);
	      this._setOpacity(ctx);
	      this._setShadow(ctx);
	      this._setupCompositeOperation(ctx);
	      this._renderTextBackground(ctx);
	      this._setStrokeStyles(ctx);
	      this._setFillStyles(ctx);
	      this._renderText(ctx);
	      this._renderTextDecoration(ctx);
	      this.clipTo && ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderText: function(ctx) {
	
	      this._translateForTextAlign(ctx);
	      this._renderTextFill(ctx);
	      this._renderTextStroke(ctx);
	      this._translateForTextAlign(ctx, true);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Boolean} back Indicates if translate back or forward
	     */
	    _translateForTextAlign: function(ctx, back) {
	      if (this.textAlign !== 'left' && this.textAlign !== 'justify') {
	        var sign = back ? -1 : 1;
	        ctx.translate(this.textAlign === 'center' ? (sign * this.width / 2) : sign * this.width, 0);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _setTextStyles: function(ctx) {
	      ctx.textBaseline = 'alphabetic';
	      if (!this.skipTextAlign) {
	        ctx.textAlign = this.textAlign;
	      }
	      ctx.font = this._getFontDeclaration();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @return {Number} Height of fabric.Text object
	     */
	    _getTextHeight: function() {
	      return this._textLines.length * this._getHeightOfLine();
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @return {Number} Maximum width of fabric.Text object
	     */
	    _getTextWidth: function(ctx) {
	      var maxWidth = this._getLineWidth(ctx, 0);
	
	      for (var i = 1, len = this._textLines.length; i < len; i++) {
	        var currentLineWidth = this._getLineWidth(ctx, i);
	        if (currentLineWidth > maxWidth) {
	          maxWidth = currentLineWidth;
	        }
	      }
	      return maxWidth;
	    },
	
	    /**
	     * @private
	     * @param {String} method Method name ("fillText" or "strokeText")
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} chars Chars to render
	     * @param {Number} left Left position of text
	     * @param {Number} top Top position of text
	     */
	    _renderChars: function(method, ctx, chars, left, top) {
	      // remove Text word from method var
	      var shortM = method.slice(0, -4);
	      if (this[shortM].toLive) {
	        var offsetX = -this.width / 2 + this[shortM].offsetX || 0,
	            offsetY = -this.height / 2 + this[shortM].offsetY || 0;
	        ctx.save();
	        ctx.translate(offsetX, offsetY);
	        left -= offsetX;
	        top -= offsetY;
	      }
	      ctx[method](chars, left, top);
	      this[shortM].toLive && ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {String} method Method name ("fillText" or "strokeText")
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line Text to render
	     * @param {Number} left Left position of text
	     * @param {Number} top Top position of text
	     * @param {Number} lineIndex Index of a line in a text
	     */
	    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
	      // lift the line by quarter of fontSize
	      top -= this.fontSize * this._fontSizeFraction;
	
	      // short-circuit
	      if (this.textAlign !== 'justify') {
	        this._renderChars(method, ctx, line, left, top, lineIndex);
	        return;
	      }
	
	      var lineWidth = this._getLineWidth(ctx, lineIndex),
	          totalWidth = this.width;
	      if (totalWidth >= lineWidth) {
	        // stretch the line
	        var words = line.split(/\s+/),
	            wordsWidth = this._getWidthOfWords(ctx, line, lineIndex),
	            widthDiff = totalWidth - wordsWidth,
	            numSpaces = words.length - 1,
	            spaceWidth = widthDiff / numSpaces,
	            leftOffset = 0;
	
	        for (var i = 0, len = words.length; i < len; i++) {
	          this._renderChars(method, ctx, words[i], left + leftOffset, top, lineIndex);
	          leftOffset += ctx.measureText(words[i]).width + spaceWidth;
	        }
	      }
	      else {
	        this._renderChars(method, ctx, line, left, top, lineIndex);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} line
	     */
	    _getWidthOfWords: function (ctx, line) {
	      return ctx.measureText(line.replace(/\s+/g, '')).width;
	    },
	
	    /**
	     * @private
	     * @return {Number} Left offset
	     */
	    _getLeftOffset: function() {
	      return -this.width / 2;
	    },
	
	    /**
	     * @private
	     * @return {Number} Top offset
	     */
	    _getTopOffset: function() {
	      return -this.height / 2;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextFill: function(ctx) {
	      if (!this.fill && !this._skipFillStrokeCheck) {
	        return;
	      }
	
	      var lineHeights = 0;
	
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        var heightOfLine = this._getHeightOfLine(ctx, i),
	            maxHeight = heightOfLine / this.lineHeight;
	
	        this._renderTextLine(
	          'fillText',
	          ctx,
	          this._textLines[i],
	          this._getLeftOffset(),
	          this._getTopOffset() + lineHeights + maxHeight,
	          i
	        );
	        lineHeights += heightOfLine;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextStroke: function(ctx) {
	      if ((!this.stroke || this.strokeWidth === 0) && !this._skipFillStrokeCheck) {
	        return;
	      }
	
	      var lineHeights = 0;
	
	      if (this.shadow && !this.shadow.affectStroke) {
	        this._removeShadow(ctx);
	      }
	
	      ctx.save();
	
	      if (this.strokeDashArray) {
	        // Spec requires the concatenation of two copies the dash list when the number of elements is odd
	        if (1 & this.strokeDashArray.length) {
	          this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);
	        }
	        supportsLineDash && ctx.setLineDash(this.strokeDashArray);
	      }
	
	      ctx.beginPath();
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        var heightOfLine = this._getHeightOfLine(ctx, i),
	            maxHeight = heightOfLine / this.lineHeight;
	
	        this._renderTextLine(
	          'strokeText',
	          ctx,
	          this._textLines[i],
	          this._getLeftOffset(),
	          this._getTopOffset() + lineHeights + maxHeight,
	          i
	        );
	        lineHeights += heightOfLine;
	      }
	      ctx.closePath();
	      ctx.restore();
	    },
	
	    _getHeightOfLine: function() {
	      return this.fontSize * this._fontSizeMult * this.lineHeight;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Array} textLines Array of all text lines
	     */
	    _renderTextBackground: function(ctx) {
	      this._renderTextBoxBackground(ctx);
	      this._renderTextLinesBackground(ctx);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextBoxBackground: function(ctx) {
	      if (!this.backgroundColor) {
	        return;
	      }
	
	      ctx.fillStyle = this.backgroundColor;
	
	      ctx.fillRect(
	        this._getLeftOffset(),
	        this._getTopOffset(),
	        this.width,
	        this.height
	      );
	
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextLinesBackground: function(ctx) {
	      if (!this.textBackgroundColor) {
	        return;
	      }
	      var lineTopOffset = 0, heightOfLine = this._getHeightOfLine(),
	          lineWidth, lineLeftOffset;
	
	      ctx.fillStyle = this.textBackgroundColor;
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        if (this._textLines[i] !== '') {
	          lineWidth = this._getLineWidth(ctx, i);
	          lineLeftOffset = this._getLineLeftOffset(lineWidth);
	          ctx.fillRect(
	            this._getLeftOffset() + lineLeftOffset,
	            this._getTopOffset() + lineTopOffset,
	            lineWidth,
	            this.fontSize * this._fontSizeMult
	          );
	        }
	        lineTopOffset += heightOfLine;
	      }
	    },
	
	    /**
	     * @private
	     * @param {Number} lineWidth Width of text line
	     * @return {Number} Line left offset
	     */
	    _getLineLeftOffset: function(lineWidth) {
	      if (this.textAlign === 'center') {
	        return (this.width - lineWidth) / 2;
	      }
	      if (this.textAlign === 'right') {
	        return this.width - lineWidth;
	      }
	      return 0;
	    },
	
	    /**
	     * @private
	     */
	    _clearCache: function() {
	      this.__lineWidths = [ ];
	      this.__lineHeights = [ ];
	      this.__lineOffsets = [ ];
	    },
	
	    /**
	     * @private
	     */
	    _shouldClearCache: function() {
	      var shouldClear = false;
	      if (this._forceClearCache) {
	        this._forceClearCache = false;
	        return true;
	      }
	      for (var prop in this._dimensionAffectingProps) {
	        if (this['__' + prop] !== this[prop]) {
	          this['__' + prop] = this[prop];
	          shouldClear = true;
	        }
	      }
	      return shouldClear;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex line number
	     * @return {Number} Line width
	     */
	    _getLineWidth: function(ctx, lineIndex) {
	      if (this.__lineWidths[lineIndex]) {
	        return this.__lineWidths[lineIndex];
	      }
	      var width, wordCount, line = this._textLines[lineIndex];
	      if (line === '') {
	        width = 0;
	      }
	      else if (this.textAlign === 'justify' && this._cacheLinesWidth) {
	        wordCount = line.split(' ');
	        //consider not justify last line, not for now.
	        if (wordCount.length > 1) {
	          width = this.width;
	        }
	        else {
	          width = ctx.measureText(line).width;
	        }
	      }
	      else {
	        width = ctx.measureText(line).width;
	      }
	      this._cacheLinesWidth && (this.__lineWidths[lineIndex] = width);
	      return width;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextDecoration: function(ctx) {
	      if (!this.textDecoration) {
	        return;
	      }
	
	      var halfOfVerticalBox = this.height / 2,
	          _this = this, offsets = [];
	
	      /** @ignore */
	      function renderLinesAtOffset(offsets) {
	        var i, lineHeight = 0, len, j, oLen, lineWidth,
	            lineLeftOffset, heightOfLine;
	
	        for (i = 0, len = _this._textLines.length; i < len; i++) {
	
	          lineWidth = _this._getLineWidth(ctx, i),
	          lineLeftOffset = _this._getLineLeftOffset(lineWidth),
	          heightOfLine = _this._getHeightOfLine(ctx, i);
	
	          for (j = 0, oLen = offsets.length; j < oLen; j++) {
	            ctx.fillRect(
	              _this._getLeftOffset() + lineLeftOffset,
	              lineHeight + (_this._fontSizeMult - 1 + offsets[j] ) * _this.fontSize - halfOfVerticalBox,
	              lineWidth,
	              _this.fontSize / 15);
	          }
	          lineHeight += heightOfLine;
	        }
	      }
	
	      if (this.textDecoration.indexOf('underline') > -1) {
	        offsets.push(0.85); // 1 - 3/16
	      }
	      if (this.textDecoration.indexOf('line-through') > -1) {
	        offsets.push(0.43);
	      }
	      if (this.textDecoration.indexOf('overline') > -1) {
	        offsets.push(-0.12);
	      }
	      if (offsets.length > 0) {
	        renderLinesAtOffset(offsets);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _getFontDeclaration: function() {
	      return [
	        // node-canvas needs "weight style", while browsers need "style weight"
	        (fabric.isLikelyNode ? this.fontWeight : this.fontStyle),
	        (fabric.isLikelyNode ? this.fontStyle : this.fontWeight),
	        this.fontSize + 'px',
	        (fabric.isLikelyNode ? ('"' + this.fontFamily + '"') : this.fontFamily)
	      ].join(' ');
	    },
	
	    /**
	     * Renders text instance on a specified context
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    render: function(ctx, noTransform) {
	      // do not render if object is not visible
	      if (!this.visible) {
	        return;
	      }
	
	      ctx.save();
	      this._setTextStyles(ctx);
	
	      if (this._shouldClearCache()) {
	        this._initDimensions(ctx);
	      }
	      if (!noTransform) {
	        this.transform(ctx);
	      }
	      if (this.transformMatrix) {
	        ctx.transform.apply(ctx, this.transformMatrix);
	      }
	      if (this.group && this.group.type === 'path-group') {
	        ctx.translate(this.left, this.top);
	      }
	      this._render(ctx);
	      ctx.restore();
	    },
	
	    /**
	     * Returns the text as an array of lines.
	     * @returns {Array} Lines in the text
	     */
	    _splitTextIntoLines: function() {
	      return this.text.split(this._reNewline);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} Object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      var object = extend(this.callSuper('toObject', propertiesToInclude), {
	        text:                 this.text,
	        fontSize:             this.fontSize,
	        fontWeight:           this.fontWeight,
	        fontFamily:           this.fontFamily,
	        fontStyle:            this.fontStyle,
	        lineHeight:           this.lineHeight,
	        textDecoration:       this.textDecoration,
	        textAlign:            this.textAlign,
	        textBackgroundColor:  this.textBackgroundColor
	      });
	      if (!this.includeDefaultValues) {
	        this._removeDefaultValues(object);
	      }
	      return object;
	    },
	
	    /* _TO_SVG_START_ */
	    /**
	     * Returns SVG representation of an instance
	     * @param {Function} [reviver] Method for further parsing of svg representation.
	     * @return {String} svg representation of an instance
	     */
	    toSVG: function(reviver) {
	      var markup = this._createBaseSVGMarkup(),
	          offsets = this._getSVGLeftTopOffsets(this.ctx),
	          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
	      this._wrapSVGTextAndBg(markup, textAndBg);
	
	      return reviver ? reviver(markup.join('')) : markup.join('');
	    },
	
	    /**
	     * @private
	     */
	    _getSVGLeftTopOffsets: function(ctx) {
	      var lineTop = this._getHeightOfLine(ctx, 0),
	          textLeft = -this.width / 2,
	          textTop = 0;
	
	      return {
	        textLeft: textLeft + (this.group && this.group.type === 'path-group' ? this.left : 0),
	        textTop: textTop + (this.group && this.group.type === 'path-group' ? -this.top : 0),
	        lineTop: lineTop
	      };
	    },
	
	    /**
	     * @private
	     */
	    _wrapSVGTextAndBg: function(markup, textAndBg) {
	      markup.push(
	        '\t<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n',
	          textAndBg.textBgRects.join(''),
	          '\t\t<text ',
	            (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ': ''),
	            (this.fontSize ? 'font-size="' + this.fontSize + '" ': ''),
	            (this.fontStyle ? 'font-style="' + this.fontStyle + '" ': ''),
	            (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ': ''),
	            (this.textDecoration ? 'text-decoration="' + this.textDecoration + '" ': ''),
	            'style="', this.getSvgStyles(), '" >',
	            textAndBg.textSpans.join(''),
	          '</text>\n',
	        '\t</g>\n'
	      );
	    },
	
	    /**
	     * @private
	     * @param {Number} textTopOffset Text top offset
	     * @param {Number} textLeftOffset Text left offset
	     * @return {Object}
	     */
	    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
	      var textSpans = [ ],
	          textBgRects = [ ],
	          height = 0;
	      // bounding-box background
	      this._setSVGBg(textBgRects);
	
	      // text and text-background
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        if (this.textBackgroundColor) {
	          this._setSVGTextLineBg(textBgRects, i, textLeftOffset, textTopOffset, height);
	        }
	        this._setSVGTextLineText(i, textSpans, height, textLeftOffset, textTopOffset, textBgRects);
	        height += this._getHeightOfLine(this.ctx, i);
	      }
	
	      return {
	        textSpans: textSpans,
	        textBgRects: textBgRects
	      };
	    },
	
	    _setSVGTextLineText: function(i, textSpans, height, textLeftOffset, textTopOffset) {
	      var yPos = this.fontSize * (this._fontSizeMult - this._fontSizeFraction)
	        - textTopOffset + height - this.height / 2;
	      textSpans.push(
	        '<tspan x="',
	          toFixed(textLeftOffset + this._getLineLeftOffset(this.__lineWidths[i]), NUM_FRACTION_DIGITS), '" ',
	          'y="',
	          toFixed(yPos, NUM_FRACTION_DIGITS),
	          '" ',
	          // doing this on <tspan> elements since setting opacity
	          // on containing <text> one doesn't work in Illustrator
	          this._getFillAttributes(this.fill), '>',
	          fabric.util.string.escapeXml(this._textLines[i]),
	        '</tspan>'
	      );
	    },
	
	    _setSVGTextLineBg: function(textBgRects, i, textLeftOffset, textTopOffset, height) {
	      textBgRects.push(
	        '\t\t<rect ',
	          this._getFillAttributes(this.textBackgroundColor),
	          ' x="',
	          toFixed(textLeftOffset + this._getLineLeftOffset(this.__lineWidths[i]), NUM_FRACTION_DIGITS),
	          '" y="',
	          toFixed(height - this.height / 2, NUM_FRACTION_DIGITS),
	          '" width="',
	          toFixed(this.__lineWidths[i], NUM_FRACTION_DIGITS),
	          '" height="',
	          toFixed(this._getHeightOfLine(this.ctx, i) / this.lineHeight, NUM_FRACTION_DIGITS),
	        '"></rect>\n');
	    },
	
	    _setSVGBg: function(textBgRects) {
	      if (this.backgroundColor) {
	        textBgRects.push(
	          '\t\t<rect ',
	            this._getFillAttributes(this.backgroundColor),
	            ' x="',
	            toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
	            '" y="',
	            toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
	            '" width="',
	            toFixed(this.width, NUM_FRACTION_DIGITS),
	            '" height="',
	            toFixed(this.height, NUM_FRACTION_DIGITS),
	          '"></rect>\n');
	      }
	    },
	
	    /**
	     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
	     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
	     *
	     * @private
	     * @param {Any} value
	     * @return {String}
	     */
	    _getFillAttributes: function(value) {
	      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
	      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
	        return 'fill="' + value + '"';
	      }
	      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
	    },
	    /* _TO_SVG_END_ */
	
	    /**
	     * Sets specified property to a specified value
	     * @param {String} key
	     * @param {Any} value
	     * @return {fabric.Text} thisArg
	     * @chainable
	     */
	    _set: function(key, value) {
	      this.callSuper('_set', key, value);
	
	      if (key in this._dimensionAffectingProps) {
	        this._initDimensions();
	        this.setCoords();
	      }
	    },
	
	    /**
	     * Returns complexity of an instance
	     * @return {Number} complexity
	     */
	    complexity: function() {
	      return 1;
	    }
	  });
	
	  /* _FROM_SVG_START_ */
	  /**
	   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
	   * @static
	   * @memberOf fabric.Text
	   * @see: http://www.w3.org/TR/SVG/text.html#TextElement
	   */
	  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
	    'x y dx dy font-family font-style font-weight font-size text-decoration text-anchor'.split(' '));
	
	  /**
	   * Default SVG font size
	   * @static
	   * @memberOf fabric.Text
	   */
	  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;
	
	  /**
	   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
	   * @static
	   * @memberOf fabric.Text
	   * @param {SVGElement} element Element to parse
	   * @param {Object} [options] Options object
	   * @return {fabric.Text} Instance of fabric.Text
	   */
	  fabric.Text.fromElement = function(element, options) {
	    if (!element) {
	      return null;
	    }
	
	    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES);
	    options = fabric.util.object.extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes);
	
	    options.top = options.top || 0;
	    options.left = options.left || 0;
	    if ('dx' in parsedAttributes) {
	      options.left += parsedAttributes.dx;
	    }
	    if ('dy' in parsedAttributes) {
	      options.top += parsedAttributes.dy;
	    }
	    if (!('fontSize' in options)) {
	      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
	    }
	
	    if (!options.originX) {
	      options.originX = 'left';
	    }
	    var textContent = element.textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' '),
	        text = new fabric.Text(textContent, options),
	        /*
	          Adjust positioning:
	            x/y attributes in SVG correspond to the bottom-left corner of text bounding box
	            top/left properties in Fabric correspond to center point of text bounding box
	        */
	        offX = 0;
	
	    if (text.originX === 'left') {
	      offX = text.getWidth() / 2;
	    }
	    if (text.originX === 'right') {
	      offX = -text.getWidth() / 2;
	    }
	    text.set({
	      left: text.getLeft() + offX,
	      top: text.getTop() - text.getHeight() / 2 + text.fontSize * (0.18 + text._fontSizeFraction) /* 0.3 is the old lineHeight */
	    });
	
	    return text;
	  };
	  /* _FROM_SVG_END_ */
	
	  /**
	   * Returns fabric.Text instance from an object representation
	   * @static
	   * @memberOf fabric.Text
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Text} Instance of fabric.Text
	   */
	  fabric.Text.fromObject = function(object) {
	    return new fabric.Text(object.text, clone(object));
	  };
	
	  fabric.util.createAccessors(fabric.Text);
	
	})( true ? exports : this);
	
	
	(function() {
	
	  var clone = fabric.util.object.clone;
	
	  /**
	   * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
	   * prefix when observing canvas.
	   * @class fabric.IText
	   * @extends fabric.Text
	   * @mixes fabric.Observable
	   *
	   * @fires changed
	   * @fires selection:changed
	   * @fires editing:entered
	   * @fires editing:exited
	   *
	   * @return {fabric.IText} thisArg
	   * @see {@link fabric.IText#initialize} for constructor definition
	   *
	   * <p>Supported key combinations:</p>
	   * <pre>
	   *   Move cursor:                    left, right, up, down
	   *   Select character:               shift + left, shift + right
	   *   Select text vertically:         shift + up, shift + down
	   *   Move cursor by word:            alt + left, alt + right
	   *   Select words:                   shift + alt + left, shift + alt + right
	   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
	   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
	   *   Jump to start/end of text:      cmd + up, cmd + down
	   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
	   *   Delete character:               backspace
	   *   Delete word:                    alt + backspace
	   *   Delete line:                    cmd + backspace
	   *   Forward delete:                 delete
	   *   Copy text:                      ctrl/cmd + c
	   *   Paste text:                     ctrl/cmd + v
	   *   Cut text:                       ctrl/cmd + x
	   *   Select entire text:             ctrl/cmd + a
	   *   Quit editing                    tab or esc
	   * </pre>
	   *
	   * <p>Supported mouse/touch combination</p>
	   * <pre>
	   *   Position cursor:                click/touch
	   *   Create selection:               click/touch & drag
	   *   Create selection:               click & shift + click
	   *   Select word:                    double click
	   *   Select line:                    triple click
	   * </pre>
	   */
	  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {
	
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'i-text',
	
	    /**
	     * Index where text selection starts (or where cursor is when there is no selection)
	     * @type Number
	     * @default
	     */
	    selectionStart: 0,
	
	    /**
	     * Index where text selection ends
	     * @type Number
	     * @default
	     */
	    selectionEnd: 0,
	
	    /**
	     * Color of text selection
	     * @type String
	     * @default
	     */
	    selectionColor: 'rgba(17,119,255,0.3)',
	
	    /**
	     * Indicates whether text is in editing mode
	     * @type Boolean
	     * @default
	     */
	    isEditing: false,
	
	    /**
	     * Indicates whether a text can be edited
	     * @type Boolean
	     * @default
	     */
	    editable: true,
	
	    /**
	     * Border color of text object while it's in editing mode
	     * @type String
	     * @default
	     */
	    editingBorderColor: 'rgba(102,153,255,0.25)',
	
	    /**
	     * Width of cursor (in px)
	     * @type Number
	     * @default
	     */
	    cursorWidth: 2,
	
	    /**
	     * Color of default cursor (when not overwritten by character style)
	     * @type String
	     * @default
	     */
	    cursorColor: '#333',
	
	    /**
	     * Delay between cursor blink (in ms)
	     * @type Number
	     * @default
	     */
	    cursorDelay: 1000,
	
	    /**
	     * Duration of cursor fadein (in ms)
	     * @type Number
	     * @default
	     */
	    cursorDuration: 600,
	
	    /**
	     * Object containing character styles
	     * (where top-level properties corresponds to line number and 2nd-level properties -- to char number in a line)
	     * @type Object
	     * @default
	     */
	    styles: null,
	
	    /**
	     * Indicates whether internal text char widths can be cached
	     * @type Boolean
	     * @default
	     */
	    caching: true,
	
	    /**
	     * @private
	     * @type Boolean
	     * @default
	     */
	    _skipFillStrokeCheck: false,
	
	    /**
	     * @private
	     */
	    _reSpace: /\s|\n/,
	
	    /**
	     * @private
	     */
	    _currentCursorOpacity: 0,
	
	    /**
	     * @private
	     */
	    _selectionDirection: null,
	
	    /**
	     * @private
	     */
	    _abortCursorAnimation: false,
	
	    /**
	     * @private
	     */
	    _charWidthsCache: { },
	
	    /**
	     * Constructor
	     * @param {String} text Text string
	     * @param {Object} [options] Options object
	     * @return {fabric.IText} thisArg
	     */
	    initialize: function(text, options) {
	      this.styles = options ? (options.styles || { }) : { };
	      this.callSuper('initialize', text, options);
	      this.initBehavior();
	    },
	
	    /**
	     * @private
	     */
	    _clearCache: function() {
	      this.callSuper('_clearCache');
	      this.__maxFontHeights = [ ];
	      this.__widthOfSpace = [ ];
	    },
	
	    /**
	     * Returns true if object has no styling
	     */
	    isEmptyStyles: function() {
	      if (!this.styles) {
	        return true;
	      }
	      var obj = this.styles;
	
	      for (var p1 in obj) {
	        for (var p2 in obj[p1]) {
	          /*jshint unused:false */
	          for (var p3 in obj[p1][p2]) {
	            return false;
	          }
	        }
	      }
	      return true;
	    },
	
	    /**
	     * Sets selection start (left boundary of a selection)
	     * @param {Number} index Index to set selection start to
	     */
	    setSelectionStart: function(index) {
	      index = Math.max(index, 0);
	      if (this.selectionStart !== index) {
	        this.fire('selection:changed');
	        this.canvas && this.canvas.fire('text:selection:changed', { target: this });
	        this.selectionStart = index;
	      }
	      this._updateTextarea();
	    },
	
	    /**
	     * Sets selection end (right boundary of a selection)
	     * @param {Number} index Index to set selection end to
	     */
	    setSelectionEnd: function(index) {
	      index = Math.min(index, this.text.length);
	      if (this.selectionEnd !== index) {
	        this.fire('selection:changed');
	        this.canvas && this.canvas.fire('text:selection:changed', { target: this });
	        this.selectionEnd = index;
	      }
	      this._updateTextarea();
	    },
	
	    /**
	     * Gets style of a current selection/cursor (at the start position)
	     * @param {Number} [startIndex] Start index to get styles at
	     * @param {Number} [endIndex] End index to get styles at
	     * @return {Object} styles Style object at a specified (or current) index
	     */
	    getSelectionStyles: function(startIndex, endIndex) {
	
	      if (arguments.length === 2) {
	        var styles = [ ];
	        for (var i = startIndex; i < endIndex; i++) {
	          styles.push(this.getSelectionStyles(i));
	        }
	        return styles;
	      }
	
	      var loc = this.get2DCursorLocation(startIndex),
	          style = this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
	
	      return style || {};
	    },
	
	    /**
	     * Sets style of a current selection
	     * @param {Object} [styles] Styles object
	     * @return {fabric.IText} thisArg
	     * @chainable
	     */
	    setSelectionStyles: function(styles) {
	      if (this.selectionStart === this.selectionEnd) {
	        this._extendStyles(this.selectionStart, styles);
	      }
	      else {
	        for (var i = this.selectionStart; i < this.selectionEnd; i++) {
	          this._extendStyles(i, styles);
	        }
	      }
	      /* not included in _extendStyles to avoid clearing cache more than once */
	      this._forceClearCache = true;
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _extendStyles: function(index, styles) {
	      var loc = this.get2DCursorLocation(index);
	
	      if (!this._getLineStyle(loc.lineIndex)) {
	        this._setLineStyle(loc.lineIndex, {});
	      }
	
	      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
	        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
	      }
	
	      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _render: function(ctx) {
	      this.callSuper('_render', ctx);
	      this.ctx = ctx;
	      this.isEditing && this.renderCursorOrSelection();
	    },
	
	    /**
	     * Renders cursor or selection (depending on what exists)
	     */
	    renderCursorOrSelection: function() {
	      if (!this.active) {
	        return;
	      }
	
	      var chars = this.text.split(''),
	          boundaries, ctx;
	
	      if (this.canvas.contextTop) {
	        ctx = this.canvas.contextTop;
	        ctx.save();
	        ctx.transform.apply(ctx, this.canvas.viewportTransform);
	        this.transform(ctx);
	        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);
	      }
	      else {
	        ctx = this.ctx;
	        ctx.save();
	      }
	
	      if (this.selectionStart === this.selectionEnd) {
	        boundaries = this._getCursorBoundaries(chars, 'cursor');
	        this.renderCursor(boundaries, ctx);
	      }
	      else {
	        boundaries = this._getCursorBoundaries(chars, 'selection');
	        this.renderSelection(chars, boundaries, ctx);
	      }
	
	      ctx.restore();
	    },
	
	    /**
	     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
	     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
	     */
	    get2DCursorLocation: function(selectionStart) {
	      if (typeof selectionStart === 'undefined') {
	        selectionStart = this.selectionStart;
	      }
	      var len = this._textLines.length;
	      for (var i = 0; i < len; i++) {
	        if (selectionStart <= this._textLines[i].length) {
	          return {
	            lineIndex: i,
	            charIndex: selectionStart
	          };
	        }
	        selectionStart -= this._textLines[i].length + 1;
	      }
	      return {
	        lineIndex: i - 1,
	        charIndex: this._textLines[i - 1].length < selectionStart ? this._textLines[i - 1].length : selectionStart
	      };
	    },
	
	    /**
	     * Returns complete style of char at the current cursor
	     * @param {Number} lineIndex Line index
	     * @param {Number} charIndex Char index
	     * @return {Object} Character style
	     */
	    getCurrentCharStyle: function(lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);
	
	      return {
	        fontSize: style && style.fontSize || this.fontSize,
	        fill: style && style.fill || this.fill,
	        textBackgroundColor: style && style.textBackgroundColor || this.textBackgroundColor,
	        textDecoration: style && style.textDecoration || this.textDecoration,
	        fontFamily: style && style.fontFamily || this.fontFamily,
	        fontWeight: style && style.fontWeight || this.fontWeight,
	        fontStyle: style && style.fontStyle || this.fontStyle,
	        stroke: style && style.stroke || this.stroke,
	        strokeWidth: style && style.strokeWidth || this.strokeWidth
	      };
	    },
	
	    /**
	     * Returns fontSize of char at the current cursor
	     * @param {Number} lineIndex Line index
	     * @param {Number} charIndex Char index
	     * @return {Number} Character font size
	     */
	    getCurrentCharFontSize: function(lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);
	      return style && style.fontSize ? style.fontSize : this.fontSize;
	    },
	
	    /**
	     * Returns color (fill) of char at the current cursor
	     * @param {Number} lineIndex Line index
	     * @param {Number} charIndex Char index
	     * @return {String} Character color (fill)
	     */
	    getCurrentCharColor: function(lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex === 0 ? 0 : charIndex - 1);
	      return style && style.fill ? style.fill : this.cursorColor;
	    },
	
	    /**
	     * Returns cursor boundaries (left, top, leftOffset, topOffset)
	     * @private
	     * @param {Array} chars Array of characters
	     * @param {String} typeOfBoundaries
	     */
	    _getCursorBoundaries: function(chars, typeOfBoundaries) {
	
	      // left/top are left/top of entire text box
	      // leftOffset/topOffset are offset from that left/top point of a text box
	
	      var left = Math.round(this._getLeftOffset()),
	          top = this._getTopOffset(),
	
	          offsets = this._getCursorBoundariesOffsets(
	                      chars, typeOfBoundaries);
	
	      return {
	        left: left,
	        top: top,
	        leftOffset: offsets.left + offsets.lineLeft,
	        topOffset: offsets.top
	      };
	    },
	
	    /**
	     * @private
	     */
	    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {
	
	      var lineLeftOffset = 0,
	
	          lineIndex = 0,
	          charIndex = 0,
	          topOffset = 0,
	          leftOffset = 0;
	
	      for (var i = 0; i < this.selectionStart; i++) {
	        if (chars[i] === '\n') {
	          leftOffset = 0;
	          topOffset += this._getHeightOfLine(this.ctx, lineIndex);
	
	          lineIndex++;
	          charIndex = 0;
	        }
	        else {
	          leftOffset += this._getWidthOfChar(this.ctx, chars[i], lineIndex, charIndex);
	          charIndex++;
	        }
	
	        lineLeftOffset = this._getCachedLineOffset(lineIndex);
	      }
	      if (typeOfBoundaries === 'cursor') {
	        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, lineIndex) / this.lineHeight
	          - this.getCurrentCharFontSize(lineIndex, charIndex) * (1 - this._fontSizeFraction);
	      }
	
	      return {
	        top: topOffset,
	        left: leftOffset,
	        lineLeft: lineLeftOffset
	      };
	    },
	
	    /**
	     * @private
	     */
	    _getCachedLineOffset: function(lineIndex) {
	      var widthOfLine = this._getLineWidth(this.ctx, lineIndex);
	
	      return this.__lineOffsets[lineIndex] ||
	        (this.__lineOffsets[lineIndex] = this._getLineLeftOffset(widthOfLine));
	    },
	
	    /**
	     * Renders cursor
	     * @param {Object} boundaries
	     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
	     */
	    renderCursor: function(boundaries, ctx) {
	
	      var cursorLocation = this.get2DCursorLocation(),
	          lineIndex = cursorLocation.lineIndex,
	          charIndex = cursorLocation.charIndex,
	          charHeight = this.getCurrentCharFontSize(lineIndex, charIndex),
	          leftOffset = (lineIndex === 0 && charIndex === 0)
	                    ? this._getCachedLineOffset(lineIndex)
	                    : boundaries.leftOffset;
	
	      ctx.fillStyle = this.getCurrentCharColor(lineIndex, charIndex);
	      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
	
	      ctx.fillRect(
	        boundaries.left + leftOffset,
	        boundaries.top + boundaries.topOffset,
	        this.cursorWidth / this.scaleX,
	        charHeight);
	
	    },
	
	    /**
	     * Renders text selection
	     * @param {Array} chars Array of characters
	     * @param {Object} boundaries Object with left/top/leftOffset/topOffset
	     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
	     */
	    renderSelection: function(chars, boundaries, ctx) {
	
	      ctx.fillStyle = this.selectionColor;
	
	      var start = this.get2DCursorLocation(this.selectionStart),
	          end = this.get2DCursorLocation(this.selectionEnd),
	          startLine = start.lineIndex,
	          endLine = end.lineIndex;
	
	      for (var i = startLine; i <= endLine; i++) {
	        var lineOffset = this._getCachedLineOffset(i) || 0,
	            lineHeight = this._getHeightOfLine(this.ctx, i),
	            boxWidth = 0, line = this._textLines[i];
	
	        if (i === startLine) {
	          for (var j = 0, len = line.length; j < len; j++) {
	            if (j >= start.charIndex && (i !== endLine || j < end.charIndex)) {
	              boxWidth += this._getWidthOfChar(ctx, line[j], i, j);
	            }
	            if (j < start.charIndex) {
	              lineOffset += this._getWidthOfChar(ctx, line[j], i, j);
	            }
	          }
	        }
	        else if (i > startLine && i < endLine) {
	          boxWidth += this._getLineWidth(ctx, i) || 5;
	        }
	        else if (i === endLine) {
	          for (var j2 = 0, j2len = end.charIndex; j2 < j2len; j2++) {
	            boxWidth += this._getWidthOfChar(ctx, line[j2], i, j2);
	          }
	        }
	
	        ctx.fillRect(
	          boundaries.left + lineOffset,
	          boundaries.top + boundaries.topOffset,
	          boxWidth,
	          lineHeight);
	
	        boundaries.topOffset += lineHeight;
	      }
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderChars: function(method, ctx, line, left, top, lineIndex) {
	
	      if (this.isEmptyStyles()) {
	        return this._renderCharsFast(method, ctx, line, left, top);
	      }
	
	      this.skipTextAlign = true;
	
	      // set proper box offset
	      left -= this.textAlign === 'center'
	        ? (this.width / 2)
	        : (this.textAlign === 'right')
	          ? this.width
	          : 0;
	
	      // set proper line offset
	      var lineHeight = this._getHeightOfLine(ctx, lineIndex),
	          lineLeftOffset = this._getCachedLineOffset(lineIndex),
	          prevStyle,
	          charsToRender = '';
	
	      left += lineLeftOffset || 0;
	
	      ctx.save();
	      top -= lineHeight / this.lineHeight * this._fontSizeFraction;
	      for (var i = 0, len = line.length; i <= len; i++) {
	        prevStyle = prevStyle || this.getCurrentCharStyle(lineIndex, i);
	        var thisStyle = this.getCurrentCharStyle(lineIndex, i + 1);
	
	        if (this._hasStyleChanged(prevStyle, thisStyle) || i === len) {
	          this._renderChar(method, ctx, lineIndex, i - 1, charsToRender, left, top, lineHeight);
	          charsToRender = '';
	          prevStyle = thisStyle;
	        }
	        charsToRender += line[i];
	      }
	
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line Content of the line
	     * @param {Number} left Left coordinate
	     * @param {Number} top Top coordinate
	     */
	    _renderCharsFast: function(method, ctx, line, left, top) {
	      this.skipTextAlign = false;
	
	      if (method === 'fillText' && this.fill) {
	        this.callSuper('_renderChars', method, ctx, line, left, top);
	      }
	      if (method === 'strokeText' && ((this.stroke && this.strokeWidth > 0) || this.skipFillStrokeCheck)) {
	        this.callSuper('_renderChars', method, ctx, line, left, top);
	      }
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex
	     * @param {Number} i
	     * @param {String} _char
	     * @param {Number} left Left coordinate
	     * @param {Number} top Top coordinate
	     * @param {Number} lineHeight Height of the line
	     */
	    _renderChar: function(method, ctx, lineIndex, i, _char, left, top, lineHeight) {
	      var charWidth, charHeight,
	          decl = this._getStyleDeclaration(lineIndex, i),
	          offset = this._fontSizeFraction * lineHeight / this.lineHeight;
	
	      if (decl) {
	        var shouldStroke = decl.stroke || this.stroke,
	            shouldFill = decl.fill || this.fill;
	
	        ctx.save();
	        charWidth = this._applyCharStylesGetWidth(ctx, _char, lineIndex, i, decl);
	        charHeight = this._getHeightOfChar(ctx, _char, lineIndex, i);
	
	        if (shouldFill) {
	          ctx.fillText(_char, left, top);
	        }
	        if (shouldStroke) {
	          ctx.strokeText(_char, left, top);
	        }
	
	        this._renderCharDecoration(ctx, decl, left, top, offset, charWidth, charHeight);
	        ctx.restore();
	
	        ctx.translate(charWidth, 0);
	      }
	      else {
	        if (method === 'strokeText' && this.stroke) {
	          ctx[method](_char, left, top);
	        }
	        if (method === 'fillText' && this.fill) {
	          ctx[method](_char, left, top);
	        }
	        charWidth = this._applyCharStylesGetWidth(ctx, _char, lineIndex, i);
	        this._renderCharDecoration(ctx, null, left, top, offset, charWidth, this.fontSize);
	
	        ctx.translate(ctx.measureText(_char).width, 0);
	      }
	    },
	
	    /**
	     * @private
	     * @param {Object} prevStyle
	     * @param {Object} thisStyle
	     */
	    _hasStyleChanged: function(prevStyle, thisStyle) {
	      return (prevStyle.fill !== thisStyle.fill ||
	              prevStyle.fontSize !== thisStyle.fontSize ||
	              prevStyle.textBackgroundColor !== thisStyle.textBackgroundColor ||
	              prevStyle.textDecoration !== thisStyle.textDecoration ||
	              prevStyle.fontFamily !== thisStyle.fontFamily ||
	              prevStyle.fontWeight !== thisStyle.fontWeight ||
	              prevStyle.fontStyle !== thisStyle.fontStyle ||
	              prevStyle.stroke !== thisStyle.stroke ||
	              prevStyle.strokeWidth !== thisStyle.strokeWidth
	      );
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderCharDecoration: function(ctx, styleDeclaration, left, top, offset, charWidth, charHeight) {
	
	      var textDecoration = styleDeclaration
	            ? (styleDeclaration.textDecoration || this.textDecoration)
	            : this.textDecoration;
	
	      if (!textDecoration) {
	        return;
	      }
	
	      if (textDecoration.indexOf('underline') > -1) {
	        ctx.fillRect(
	          left,
	          top + charHeight / 10,
	          charWidth ,
	          charHeight / 15
	        );
	      }
	      if (textDecoration.indexOf('line-through') > -1) {
	        ctx.fillRect(
	          left,
	          top - charHeight * (this._fontSizeFraction + this._fontSizeMult - 1) + charHeight / 15,
	          charWidth,
	          charHeight / 15
	        );
	      }
	      if (textDecoration.indexOf('overline') > -1) {
	        ctx.fillRect(
	          left,
	          top - (this._fontSizeMult - this._fontSizeFraction) * charHeight,
	          charWidth,
	          charHeight / 15
	        );
	      }
	    },
	
	    /**
	     * @private
	     * @param {String} method
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} line
	     */
	    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
	      // to "cancel" this.fontSize subtraction in fabric.Text#_renderTextLine
	      // the adding 0.03 is just to align text with itext by overlap test
	      if (!this.isEmptyStyles()) {
	        top += this.fontSize * (this._fontSizeFraction + 0.03);
	      }
	      this.callSuper('_renderTextLine', method, ctx, line, left, top, lineIndex);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextDecoration: function(ctx) {
	      if (this.isEmptyStyles()) {
	        return this.callSuper('_renderTextDecoration', ctx);
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _renderTextLinesBackground: function(ctx) {
	      if (!this.textBackgroundColor && !this.styles) {
	        return;
	      }
	
	      ctx.save();
	
	      if (this.textBackgroundColor) {
	        ctx.fillStyle = this.textBackgroundColor;
	      }
	
	      var lineHeights = 0;
	
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	
	        var heightOfLine = this._getHeightOfLine(ctx, i);
	        if (this._textLines[i] === '') {
	          lineHeights += heightOfLine;
	          continue;
	        }
	
	        var lineWidth = this._getLineWidth(ctx, i),
	            lineLeftOffset = this._getCachedLineOffset(i);
	
	        if (this.textBackgroundColor) {
	          ctx.fillStyle = this.textBackgroundColor;
	
	          ctx.fillRect(
	            this._getLeftOffset() + lineLeftOffset,
	            this._getTopOffset() + lineHeights,
	            lineWidth,
	            heightOfLine / this.lineHeight
	          );
	        }
	        if (this._getLineStyle(i)) {
	          for (var j = 0, jlen = this._textLines[i].length; j < jlen; j++) {
	            var style = this._getStyleDeclaration(i, j);
	            if (style && style.textBackgroundColor) {
	
	              var _char = this._textLines[i][j];
	
	              ctx.fillStyle = style.textBackgroundColor;
	
	              ctx.fillRect(
	                this._getLeftOffset() + lineLeftOffset + this._getWidthOfCharsAt(ctx, i, j),
	                this._getTopOffset() + lineHeights,
	                this._getWidthOfChar(ctx, _char, i, j) + 1,
	                heightOfLine / this.lineHeight
	              );
	            }
	          }
	        }
	        lineHeights += heightOfLine;
	      }
	      ctx.restore();
	    },
	
	    /**
	     * @private
	     */
	    _getCacheProp: function(_char, styleDeclaration) {
	      return _char +
	             styleDeclaration.fontFamily +
	             styleDeclaration.fontSize +
	             styleDeclaration.fontWeight +
	             styleDeclaration.fontStyle +
	             styleDeclaration.shadow;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {String} _char
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Object} [decl]
	     */
	    _applyCharStylesGetWidth: function(ctx, _char, lineIndex, charIndex, decl) {
	      var styleDeclaration = decl || this._getStyleDeclaration(lineIndex, charIndex);
	
	      if (styleDeclaration) {
	        // cloning so that original style object is not polluted with following font declarations
	        styleDeclaration = clone(styleDeclaration);
	      }
	      else {
	        styleDeclaration = { };
	      }
	
	      this._applyFontStyles(styleDeclaration);
	
	      var cacheProp = this._getCacheProp(_char, styleDeclaration);
	
	      // short-circuit if no styles
	      if (this.isEmptyStyles() && this._charWidthsCache[cacheProp] && this.caching) {
	        return this._charWidthsCache[cacheProp];
	      }
	
	      if (typeof styleDeclaration.shadow === 'string') {
	        styleDeclaration.shadow = new fabric.Shadow(styleDeclaration.shadow);
	      }
	
	      var fill = styleDeclaration.fill || this.fill;
	      ctx.fillStyle = fill.toLive
	        ? fill.toLive(ctx, this)
	        : fill;
	
	      if (styleDeclaration.stroke) {
	        ctx.strokeStyle = (styleDeclaration.stroke && styleDeclaration.stroke.toLive)
	          ? styleDeclaration.stroke.toLive(ctx, this)
	          : styleDeclaration.stroke;
	      }
	
	      ctx.lineWidth = styleDeclaration.strokeWidth || this.strokeWidth;
	      ctx.font = this._getFontDeclaration.call(styleDeclaration);
	      this._setShadow.call(styleDeclaration, ctx);
	
	      if (!this.caching) {
	        return ctx.measureText(_char).width;
	      }
	
	      if (!this._charWidthsCache[cacheProp]) {
	        this._charWidthsCache[cacheProp] = ctx.measureText(_char).width;
	      }
	
	      return this._charWidthsCache[cacheProp];
	    },
	
	    /**
	     * @private
	     * @param {Object} styleDeclaration
	     */
	    _applyFontStyles: function(styleDeclaration) {
	      if (!styleDeclaration.fontFamily) {
	        styleDeclaration.fontFamily = this.fontFamily;
	      }
	      if (!styleDeclaration.fontSize) {
	        styleDeclaration.fontSize = this.fontSize;
	      }
	      if (!styleDeclaration.fontWeight) {
	        styleDeclaration.fontWeight = this.fontWeight;
	      }
	      if (!styleDeclaration.fontStyle) {
	        styleDeclaration.fontStyle = this.fontStyle;
	      }
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Boolean} [returnCloneOrEmpty=false]
	     * @private
	     */
	    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {
	      if (returnCloneOrEmpty) {
	        return (this.styles[lineIndex] && this.styles[lineIndex][charIndex])
	          ? clone(this.styles[lineIndex][charIndex])
	          : { };
	      }
	
	      return this.styles[lineIndex] && this.styles[lineIndex][charIndex] ? this.styles[lineIndex][charIndex] : null;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Object} style
	     * @private
	     */
	    _setStyleDeclaration: function(lineIndex, charIndex, style) {
	      this.styles[lineIndex][charIndex] = style;
	    },
	
	    /**
	     *
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @private
	     */
	    _deleteStyleDeclaration: function(lineIndex, charIndex) {
	      delete this.styles[lineIndex][charIndex];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _getLineStyle: function(lineIndex) {
	      return this.styles[lineIndex];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Object} style
	     * @private
	     */
	    _setLineStyle: function(lineIndex, style) {
	      this.styles[lineIndex] = style;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _deleteLineStyle: function(lineIndex) {
	      delete this.styles[lineIndex];
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getWidthOfChar: function(ctx, _char, lineIndex, charIndex) {
	      if (this.textAlign === 'justify' && this._reSpacesAndTabs.test(_char)) {
	        return this._getWidthOfSpace(ctx, lineIndex);
	      }
	
	      var styleDeclaration = this._getStyleDeclaration(lineIndex, charIndex, true);
	      this._applyFontStyles(styleDeclaration);
	      var cacheProp = this._getCacheProp(_char, styleDeclaration);
	
	      if (this._charWidthsCache[cacheProp] && this.caching) {
	        return this._charWidthsCache[cacheProp];
	      }
	      else if (ctx) {
	        ctx.save();
	        var width = this._applyCharStylesGetWidth(ctx, _char, lineIndex, charIndex);
	        ctx.restore();
	        return width;
	      }
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getHeightOfChar: function(ctx, _char, lineIndex, charIndex) {
	      var style = this._getStyleDeclaration(lineIndex, charIndex);
	      return style && style.fontSize ? style.fontSize : this.fontSize;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getHeightOfCharAt: function(ctx, lineIndex, charIndex) {
	      var _char = this._textLines[lineIndex][charIndex];
	      return this._getHeightOfChar(ctx, _char, lineIndex, charIndex);
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getWidthOfCharsAt: function(ctx, lineIndex, charIndex) {
	      var width = 0, i, _char;
	      for (i = 0; i < charIndex; i++) {
	        _char = this._textLines[lineIndex][i];
	        width += this._getWidthOfChar(ctx, _char, lineIndex, i);
	      }
	      return width;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getLineWidth: function(ctx, lineIndex) {
	      if (this.__lineWidths[lineIndex]) {
	        return this.__lineWidths[lineIndex];
	      }
	      this.__lineWidths[lineIndex] = this._getWidthOfCharsAt(ctx, lineIndex, this._textLines[lineIndex].length);
	      return this.__lineWidths[lineIndex];
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} lineIndex
	     */
	    _getWidthOfSpace: function (ctx, lineIndex) {
	      if (this.__widthOfSpace[lineIndex]) {
	        return this.__widthOfSpace[lineIndex];
	      }
	      var line = this._textLines[lineIndex],
	          wordsWidth = this._getWidthOfWords(ctx, line, lineIndex),
	          widthDiff = this.width - wordsWidth,
	          numSpaces = line.length - line.replace(this._reSpacesAndTabs, '').length,
	          width = widthDiff / numSpaces;
	      this.__widthOfSpace[lineIndex] = width;
	      return width;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     * @param {Number} line
	     * @param {Number} lineIndex
	     */
	    _getWidthOfWords: function (ctx, line, lineIndex) {
	      var width = 0;
	
	      for (var charIndex = 0; charIndex < line.length; charIndex++) {
	        var _char = line[charIndex];
	
	        if (!_char.match(/\s/)) {
	          width += this._getWidthOfChar(ctx, _char, lineIndex, charIndex);
	        }
	      }
	
	      return width;
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getHeightOfLine: function(ctx, lineIndex) {
	      if (this.__lineHeights[lineIndex]) {
	        return this.__lineHeights[lineIndex];
	      }
	
	      var line = this._textLines[lineIndex],
	          maxHeight = this._getHeightOfChar(ctx, line[0], lineIndex, 0);
	
	      for (var i = 1, len = line.length; i < len; i++) {
	        var currentCharHeight = this._getHeightOfChar(ctx, line[i], lineIndex, i);
	        if (currentCharHeight > maxHeight) {
	          maxHeight = currentCharHeight;
	        }
	      }
	      this.__maxFontHeights[lineIndex] = maxHeight;
	      this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
	      return this.__lineHeights[lineIndex];
	    },
	
	    /**
	     * @private
	     * @param {CanvasRenderingContext2D} ctx Context to render on
	     */
	    _getTextHeight: function(ctx) {
	      var height = 0;
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        height += this._getHeightOfLine(ctx, i);
	      }
	      return height;
	    },
	
	    /**
	     * This method is overwritten to account for different top offset
	     * @private
	     */
	    _renderTextBoxBackground: function(ctx) {
	      if (!this.backgroundColor) {
	        return;
	      }
	
	      ctx.save();
	      ctx.fillStyle = this.backgroundColor;
	
	      ctx.fillRect(
	        this._getLeftOffset(),
	        this._getTopOffset(),
	        this.width,
	        this.height
	      );
	
	      ctx.restore();
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @method toObject
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {
	        styles: clone(this.styles)
	      });
	    }
	  });
	
	  /**
	   * Returns fabric.IText instance from an object representation
	   * @static
	   * @memberOf fabric.IText
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.IText} instance of fabric.IText
	   */
	  fabric.IText.fromObject = function(object) {
	    return new fabric.IText(object.text, clone(object));
	  };
	})();
	
	
	(function() {
	
	  var clone = fabric.util.object.clone;
	
	  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	
	    /**
	     * Initializes all the interactive behavior of IText
	     */
	    initBehavior: function() {
	      this.initAddedHandler();
	      this.initRemovedHandler();
	      this.initCursorSelectionHandlers();
	      this.initDoubleClickSimulation();
	    },
	
	    /**
	     * Initializes "selected" event handler
	     */
	    initSelectedHandler: function() {
	      this.on('selected', function() {
	
	        var _this = this;
	        setTimeout(function() {
	          _this.selected = true;
	        }, 100);
	      });
	    },
	
	    /**
	     * Initializes "added" event handler
	     */
	    initAddedHandler: function() {
	      var _this = this;
	      this.on('added', function() {
	        if (this.canvas && !this.canvas._hasITextHandlers) {
	          this.canvas._hasITextHandlers = true;
	          this._initCanvasHandlers();
	        }
	
	        // Track IText instances per-canvas. Only register in this array once added
	        // to a canvas; we don't want to leak a reference to the instance forever
	        // simply because it existed at some point.
	        // (Might be added to a collection, but not on a canvas.)
	        if (_this.canvas) {
	          _this.canvas._iTextInstances = _this.canvas._iTextInstances || [];
	          _this.canvas._iTextInstances.push(_this);
	        }
	      });
	    },
	
	    initRemovedHandler: function() {
	      var _this = this;
	      this.on('removed', function() {
	        // (Might be removed from a collection, but not on a canvas.)
	        if (_this.canvas) {
	          _this.canvas._iTextInstances = _this.canvas._iTextInstances || [];
	          fabric.util.removeFromArray(_this.canvas._iTextInstances, _this);
	        }
	      });
	    },
	
	    /**
	     * @private
	     */
	    _initCanvasHandlers: function() {
	      var _this = this;
	
	      this.canvas.on('selection:cleared', function() {
	        fabric.IText.prototype.exitEditingOnOthers(_this.canvas);
	      });
	
	      this.canvas.on('mouse:up', function() {
	        if (_this.canvas._iTextInstances) {
	          _this.canvas._iTextInstances.forEach(function(obj) {
	            obj.__isMousedown = false;
	          });
	        }
	      });
	
	      this.canvas.on('object:selected', function() {
	        fabric.IText.prototype.exitEditingOnOthers(_this.canvas);
	      });
	    },
	
	    /**
	     * @private
	     */
	    _tick: function() {
	      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
	    },
	
	    /**
	     * @private
	     */
	    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {
	
	      var tickState;
	
	      tickState = {
	        isAborted: false,
	        abort: function() {
	          this.isAborted = true;
	        },
	      };
	
	      obj.animate('_currentCursorOpacity', targetOpacity, {
	        duration: duration,
	        onComplete: function() {
	          if (!tickState.isAborted) {
	            obj[completeMethod]();
	          }
	        },
	        onChange: function() {
	          if (obj.canvas) {
	            obj.canvas.clearContext(obj.canvas.contextTop || obj.ctx);
	            obj.renderCursorOrSelection();
	          }
	        },
	        abort: function() {
	          return tickState.isAborted;
	        }
	      });
	      return tickState;
	    },
	
	    /**
	     * @private
	     */
	    _onTickComplete: function() {
	
	      var _this = this;
	
	      if (this._cursorTimeout1) {
	        clearTimeout(this._cursorTimeout1);
	      }
	      this._cursorTimeout1 = setTimeout(function() {
	        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
	      }, 100);
	    },
	
	    /**
	     * Initializes delayed cursor
	     */
	    initDelayedCursor: function(restart) {
	      var _this = this,
	          delay = restart ? 0 : this.cursorDelay;
	
	      this._currentTickState && this._currentTickState.abort();
	      this._currentTickCompleteState && this._currentTickCompleteState.abort();
	      clearTimeout(this._cursorTimeout1);
	      this._currentCursorOpacity = 1;
	      if (this.canvas) {
	        this.canvas.clearContext(this.canvas.contextTop || this.ctx);
	        this.renderCursorOrSelection();
	      }
	      if (this._cursorTimeout2) {
	        clearTimeout(this._cursorTimeout2);
	      }
	      this._cursorTimeout2 = setTimeout(function() {
	        _this._tick();
	      }, delay);
	    },
	
	    /**
	     * Aborts cursor animation and clears all timeouts
	     */
	    abortCursorAnimation: function() {
	      this._currentTickState && this._currentTickState.abort();
	      this._currentTickCompleteState && this._currentTickCompleteState.abort();
	
	      clearTimeout(this._cursorTimeout1);
	      clearTimeout(this._cursorTimeout2);
	
	      this._currentCursorOpacity = 0;
	      this.canvas && this.canvas.clearContext(this.canvas.contextTop || this.ctx);
	    },
	
	    /**
	     * Selects entire text
	     */
	    selectAll: function() {
	      this.setSelectionStart(0);
	      this.setSelectionEnd(this.text.length);
	    },
	
	    /**
	     * Returns selected text
	     * @return {String}
	     */
	    getSelectedText: function() {
	      return this.text.slice(this.selectionStart, this.selectionEnd);
	    },
	
	    /**
	     * Find new selection index representing start of current word according to current selection index
	     * @param {Number} startFrom Surrent selection index
	     * @return {Number} New selection index
	     */
	    findWordBoundaryLeft: function(startFrom) {
	      var offset = 0, index = startFrom - 1;
	
	      // remove space before cursor first
	      if (this._reSpace.test(this.text.charAt(index))) {
	        while (this._reSpace.test(this.text.charAt(index))) {
	          offset++;
	          index--;
	        }
	      }
	      while (/\S/.test(this.text.charAt(index)) && index > -1) {
	        offset++;
	        index--;
	      }
	
	      return startFrom - offset;
	    },
	
	    /**
	     * Find new selection index representing end of current word according to current selection index
	     * @param {Number} startFrom Current selection index
	     * @return {Number} New selection index
	     */
	    findWordBoundaryRight: function(startFrom) {
	      var offset = 0, index = startFrom;
	
	      // remove space after cursor first
	      if (this._reSpace.test(this.text.charAt(index))) {
	        while (this._reSpace.test(this.text.charAt(index))) {
	          offset++;
	          index++;
	        }
	      }
	      while (/\S/.test(this.text.charAt(index)) && index < this.text.length) {
	        offset++;
	        index++;
	      }
	
	      return startFrom + offset;
	    },
	
	    /**
	     * Find new selection index representing start of current line according to current selection index
	     * @param {Number} startFrom Current selection index
	     * @return {Number} New selection index
	     */
	    findLineBoundaryLeft: function(startFrom) {
	      var offset = 0, index = startFrom - 1;
	
	      while (!/\n/.test(this.text.charAt(index)) && index > -1) {
	        offset++;
	        index--;
	      }
	
	      return startFrom - offset;
	    },
	
	    /**
	     * Find new selection index representing end of current line according to current selection index
	     * @param {Number} startFrom Current selection index
	     * @return {Number} New selection index
	     */
	    findLineBoundaryRight: function(startFrom) {
	      var offset = 0, index = startFrom;
	
	      while (!/\n/.test(this.text.charAt(index)) && index < this.text.length) {
	        offset++;
	        index++;
	      }
	
	      return startFrom + offset;
	    },
	
	    /**
	     * Returns number of newlines in selected text
	     * @return {Number} Number of newlines in selected text
	     */
	    getNumNewLinesInSelectedText: function() {
	      var selectedText = this.getSelectedText(),
	          numNewLines  = 0;
	
	      for (var i = 0, len = selectedText.length; i < len; i++) {
	        if (selectedText[i] === '\n') {
	          numNewLines++;
	        }
	      }
	      return numNewLines;
	    },
	
	    /**
	     * Finds index corresponding to beginning or end of a word
	     * @param {Number} selectionStart Index of a character
	     * @param {Number} direction: 1 or -1
	     * @return {Number} Index of the beginning or end of a word
	     */
	    searchWordBoundary: function(selectionStart, direction) {
	      var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,
	          _char     = this.text.charAt(index),
	          reNonWord = /[ \n\.,;!\?\-]/;
	
	      while (!reNonWord.test(_char) && index > 0 && index < this.text.length) {
	        index += direction;
	        _char = this.text.charAt(index);
	      }
	      if (reNonWord.test(_char) && _char !== '\n') {
	        index += direction === 1 ? 0 : 1;
	      }
	      return index;
	    },
	
	    /**
	     * Selects a word based on the index
	     * @param {Number} selectionStart Index of a character
	     */
	    selectWord: function(selectionStart) {
	      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
	          newSelectionEnd   = this.searchWordBoundary(selectionStart, 1);
	      /* search forward */
	
	      this.setSelectionStart(newSelectionStart);
	      this.setSelectionEnd(newSelectionEnd);
	    },
	
	    /**
	     * Selects a line based on the index
	     * @param {Number} selectionStart Index of a character
	     */
	    selectLine: function(selectionStart) {
	      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
	          newSelectionEnd   = this.findLineBoundaryRight(selectionStart);
	
	      this.setSelectionStart(newSelectionStart);
	      this.setSelectionEnd(newSelectionEnd);
	    },
	
	    /**
	     * Enters editing state
	     * @return {fabric.IText} thisArg
	     * @chainable
	     */
	    enterEditing: function() {
	      if (this.isEditing || !this.editable) {
	        return;
	      }
	
	      if (this.canvas) {
	        this.exitEditingOnOthers(this.canvas);
	      }
	
	      this.isEditing = true;
	
	      this.initHiddenTextarea();
	      this.hiddenTextarea.focus();
	      this._updateTextarea();
	      this._saveEditingProps();
	      this._setEditingProps();
	
	      this._tick();
	      this.fire('editing:entered');
	
	      if (!this.canvas) {
	        return this;
	      }
	
	      this.canvas.renderAll();
	      this.canvas.fire('text:editing:entered', { target: this });
	      this.initMouseMoveHandler();
	      return this;
	    },
	
	    exitEditingOnOthers: function(canvas) {
	      if (canvas._iTextInstances) {
	        canvas._iTextInstances.forEach(function(obj) {
	          obj.selected = false;
	          if (obj.isEditing) {
	            obj.exitEditing();
	          }
	        });
	      }
	    },
	
	    /**
	     * Initializes "mousemove" event handler
	     */
	    initMouseMoveHandler: function() {
	      var _this = this;
	      this.canvas.on('mouse:move', function(options) {
	        if (!_this.__isMousedown || !_this.isEditing) {
	          return;
	        }
	
	        var newSelectionStart = _this.getSelectionStartFromPointer(options.e);
	        if (newSelectionStart >= _this.__selectionStartOnMouseDown) {
	          _this.setSelectionStart(_this.__selectionStartOnMouseDown);
	          _this.setSelectionEnd(newSelectionStart);
	        }
	        else {
	          _this.setSelectionStart(newSelectionStart);
	          _this.setSelectionEnd(_this.__selectionStartOnMouseDown);
	        }
	      });
	    },
	
	    /**
	     * @private
	     */
	    _setEditingProps: function() {
	      this.hoverCursor = 'text';
	
	      if (this.canvas) {
	        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
	      }
	
	      this.borderColor = this.editingBorderColor;
	
	      this.hasControls = this.selectable = false;
	      this.lockMovementX = this.lockMovementY = true;
	    },
	
	    /**
	     * @private
	     */
	    _updateTextarea: function() {
	      if (!this.hiddenTextarea) {
	        return;
	      }
	
	      this.hiddenTextarea.value = this.text;
	      this.hiddenTextarea.selectionStart = this.selectionStart;
	      this.hiddenTextarea.selectionEnd = this.selectionEnd;
	    },
	
	    /**
	     * @private
	     */
	    _saveEditingProps: function() {
	      this._savedProps = {
	        hasControls: this.hasControls,
	        borderColor: this.borderColor,
	        lockMovementX: this.lockMovementX,
	        lockMovementY: this.lockMovementY,
	        hoverCursor: this.hoverCursor,
	        defaultCursor: this.canvas && this.canvas.defaultCursor,
	        moveCursor: this.canvas && this.canvas.moveCursor
	      };
	    },
	
	    /**
	     * @private
	     */
	    _restoreEditingProps: function() {
	      if (!this._savedProps) {
	        return;
	      }
	
	      this.hoverCursor = this._savedProps.overCursor;
	      this.hasControls = this._savedProps.hasControls;
	      this.borderColor = this._savedProps.borderColor;
	      this.lockMovementX = this._savedProps.lockMovementX;
	      this.lockMovementY = this._savedProps.lockMovementY;
	
	      if (this.canvas) {
	        this.canvas.defaultCursor = this._savedProps.defaultCursor;
	        this.canvas.moveCursor = this._savedProps.moveCursor;
	      }
	    },
	
	    /**
	     * Exits from editing state
	     * @return {fabric.IText} thisArg
	     * @chainable
	     */
	    exitEditing: function() {
	
	      this.selected = false;
	      this.isEditing = false;
	      this.selectable = true;
	
	      this.selectionEnd = this.selectionStart;
	      this.hiddenTextarea && this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);
	      this.hiddenTextarea = null;
	
	      this.abortCursorAnimation();
	      this._restoreEditingProps();
	      this._currentCursorOpacity = 0;
	
	      this.fire('editing:exited');
	      this.canvas && this.canvas.fire('text:editing:exited', { target: this });
	
	      return this;
	    },
	
	    /**
	     * @private
	     */
	    _removeExtraneousStyles: function() {
	      for (var prop in this.styles) {
	        if (!this._textLines[prop]) {
	          delete this.styles[prop];
	        }
	      }
	    },
	
	    /**
	     * @private
	     */
	    _removeCharsFromTo: function(start, end) {
	      while (end !== start) {
	        this._removeSingleCharAndStyle(start + 1);
	        end--;
	      }
	      this.setSelectionStart(start);
	    },
	
	    _removeSingleCharAndStyle: function(index) {
	      var isBeginningOfLine = this.text[index - 1] === '\n',
	          indexStyle        = isBeginningOfLine ? index : index - 1;
	      this.removeStyleObject(isBeginningOfLine, indexStyle);
	      this.text = this.text.slice(0, index - 1) +
	        this.text.slice(index);
	
	      this._textLines = this._splitTextIntoLines();
	    },
	
	    /**
	     * Inserts characters where cursor is (replacing selection if one exists)
	     * @param {String} _chars Characters to insert
	     * @param {Boolean} useCopiedStyle use fabric.copiedTextStyle
	     */
	    insertChars: function(_chars, useCopiedStyle) {
	      var style;
	
	      if (this.selectionEnd - this.selectionStart > 1) {
	        this._removeCharsFromTo(this.selectionStart, this.selectionEnd);
	        this.setSelectionEnd(this.selectionStart);
	      }
	
	      for (var i = 0, len = _chars.length; i < len; i++) {
	        if (useCopiedStyle) {
	          style = fabric.copiedTextStyle[i];
	        }
	        this.insertChar(_chars[i], i < len - 1, style);
	      }
	    },
	
	    /**
	     * Inserts a character where cursor is
	     * @param {String} _char Characters to insert
	     * @param {Boolean} skipUpdate trigger rendering and updates at the end of text insert
	     * @param {Object} styleObject Style to be inserted for the new char
	     */
	    insertChar: function(_char, skipUpdate, styleObject) {
	      var isEndOfLine = this.text[this.selectionStart] === '\n';
	      this.text = this.text.slice(0, this.selectionStart) +
	        _char + this.text.slice(this.selectionEnd);
	      this._textLines = this._splitTextIntoLines();
	      this.insertStyleObjects(_char, isEndOfLine, styleObject);
	      this.setSelectionStart(this.selectionStart + 1);
	      this.setSelectionEnd(this.selectionStart);
	      if (skipUpdate) {
	        return;
	      }
	      this.canvas && this.canvas.renderAll();
	      this.setCoords();
	      this.fire('changed');
	      this.canvas && this.canvas.fire('text:changed', { target: this });
	    },
	
	    /**
	     * Inserts new style object
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Boolean} isEndOfLine True if it's end of line
	     */
	    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {
	
	      this.shiftLineStyles(lineIndex, +1);
	
	      if (!this.styles[lineIndex + 1]) {
	        this.styles[lineIndex + 1] = {};
	      }
	
	      var currentCharStyle = {},
	          newLineStyles    = {};
	
	      if (this.styles[lineIndex] && this.styles[lineIndex][charIndex - 1]) {
	        currentCharStyle = this.styles[lineIndex][charIndex - 1];
	      }
	
	      // if there's nothing after cursor,
	      // we clone current char style onto the next (otherwise empty) line
	      if (isEndOfLine) {
	        newLineStyles[0] = clone(currentCharStyle);
	        this.styles[lineIndex + 1] = newLineStyles;
	      }
	      // otherwise we clone styles of all chars
	      // after cursor onto the next line, from the beginning
	      else {
	        for (var index in this.styles[lineIndex]) {
	          if (parseInt(index, 10) >= charIndex) {
	            newLineStyles[parseInt(index, 10) - charIndex] = this.styles[lineIndex][index];
	            // remove lines from the previous line since they're on a new line now
	            delete this.styles[lineIndex][index];
	          }
	        }
	        this.styles[lineIndex + 1] = newLineStyles;
	      }
	      this._forceClearCache = true;
	    },
	
	    /**
	     * Inserts style object for a given line/char index
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Object} [style] Style object to insert, if given
	     */
	    insertCharStyleObject: function(lineIndex, charIndex, style) {
	
	      var currentLineStyles       = this.styles[lineIndex],
	          currentLineStylesCloned = clone(currentLineStyles);
	
	      if (charIndex === 0 && !style) {
	        charIndex = 1;
	      }
	
	      // shift all char styles by 1 forward
	      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
	      for (var index in currentLineStylesCloned) {
	        var numericIndex = parseInt(index, 10);
	
	        if (numericIndex >= charIndex) {
	          currentLineStyles[numericIndex + 1] = currentLineStylesCloned[numericIndex];
	
	          // only delete the style if there was nothing moved there
	          if (!currentLineStylesCloned[numericIndex - 1]) {
	            delete currentLineStyles[numericIndex];
	          }
	        }
	      }
	
	      this.styles[lineIndex][charIndex] =
	        style || clone(currentLineStyles[charIndex - 1]);
	      this._forceClearCache = true;
	    },
	
	    /**
	     * Inserts style object(s)
	     * @param {String} _chars Characters at the location where style is inserted
	     * @param {Boolean} isEndOfLine True if it's end of line
	     * @param {Object} [styleObject] Style to insert
	     */
	    insertStyleObjects: function(_chars, isEndOfLine, styleObject) {
	      // removed shortcircuit over isEmptyStyles
	
	      var cursorLocation = this.get2DCursorLocation(),
	          lineIndex      = cursorLocation.lineIndex,
	          charIndex      = cursorLocation.charIndex;
	
	      if (!this._getLineStyle(lineIndex)) {
	        this._setLineStyle(lineIndex, {});
	      }
	
	      if (_chars === '\n') {
	        this.insertNewlineStyleObject(lineIndex, charIndex, isEndOfLine);
	      }
	      else {
	        this.insertCharStyleObject(lineIndex, charIndex, styleObject);
	      }
	    },
	
	    /**
	     * Shifts line styles up or down
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} offset Can be -1 or +1
	     */
	    shiftLineStyles: function(lineIndex, offset) {
	      // shift all line styles by 1 upward
	      var clonedStyles = clone(this.styles);
	      for (var line in this.styles) {
	        var numericLine = parseInt(line, 10);
	        if (numericLine > lineIndex) {
	          this.styles[numericLine + offset] = clonedStyles[numericLine];
	          if (!clonedStyles[numericLine - offset]) {
	            delete this.styles[numericLine];
	          }
	        }
	      }
	      //TODO: evaluate if delete old style lines with offset -1
	    },
	
	    /**
	     * Removes style object
	     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line
	     * @param {Number} [index] Optional index. When not given, current selectionStart is used.
	     */
	    removeStyleObject: function(isBeginningOfLine, index) {
	
	      var cursorLocation = this.get2DCursorLocation(index),
	          lineIndex      = cursorLocation.lineIndex,
	          charIndex      = cursorLocation.charIndex;
	
	      if (isBeginningOfLine) {
	
	        var textOnPreviousLine     = this._textLines[lineIndex - 1],
	            newCharIndexOnPrevLine = textOnPreviousLine
	              ? textOnPreviousLine.length
	              : 0;
	
	        if (!this.styles[lineIndex - 1]) {
	          this.styles[lineIndex - 1] = {};
	        }
	
	        for (charIndex in this.styles[lineIndex]) {
	          this.styles[lineIndex - 1][parseInt(charIndex, 10) + newCharIndexOnPrevLine]
	            = this.styles[lineIndex][charIndex];
	        }
	
	        this.shiftLineStyles(lineIndex, -1);
	
	      }
	      else {
	        var currentLineStyles = this.styles[lineIndex];
	
	        if (currentLineStyles) {
	          delete currentLineStyles[charIndex];
	          //console.log('deleting', lineIndex, charIndex + offset);
	        }
	
	        var currentLineStylesCloned = clone(currentLineStyles);
	
	        // shift all styles by 1 backwards
	        for (var i in currentLineStylesCloned) {
	          var numericIndex = parseInt(i, 10);
	          if (numericIndex >= charIndex && numericIndex !== 0) {
	            currentLineStyles[numericIndex - 1] = currentLineStylesCloned[numericIndex];
	            delete currentLineStyles[numericIndex];
	          }
	        }
	      }
	    },
	
	    /**
	     * Inserts new line
	     */
	    insertNewline: function() {
	      this.insertChars('\n');
	    }
	  });
	})();
	
	
	fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	  /**
	   * Initializes "dbclick" event handler
	   */
	  initDoubleClickSimulation: function() {
	
	    // for double click
	    this.__lastClickTime = +new Date();
	
	    // for triple click
	    this.__lastLastClickTime = +new Date();
	
	    this.__lastPointer = { };
	
	    this.on('mousedown', this.onMouseDown.bind(this));
	  },
	
	  onMouseDown: function(options) {
	
	    this.__newClickTime = +new Date();
	    var newPointer = this.canvas.getPointer(options.e);
	
	    if (this.isTripleClick(newPointer)) {
	      this.fire('tripleclick', options);
	      this._stopEvent(options.e);
	    }
	    else if (this.isDoubleClick(newPointer)) {
	      this.fire('dblclick', options);
	      this._stopEvent(options.e);
	    }
	
	    this.__lastLastClickTime = this.__lastClickTime;
	    this.__lastClickTime = this.__newClickTime;
	    this.__lastPointer = newPointer;
	    this.__lastIsEditing = this.isEditing;
	    this.__lastSelected = this.selected;
	  },
	
	  isDoubleClick: function(newPointer) {
	    return this.__newClickTime - this.__lastClickTime < 500 &&
	        this.__lastPointer.x === newPointer.x &&
	        this.__lastPointer.y === newPointer.y && this.__lastIsEditing;
	  },
	
	  isTripleClick: function(newPointer) {
	    return this.__newClickTime - this.__lastClickTime < 500 &&
	        this.__lastClickTime - this.__lastLastClickTime < 500 &&
	        this.__lastPointer.x === newPointer.x &&
	        this.__lastPointer.y === newPointer.y;
	  },
	
	  /**
	   * @private
	   */
	  _stopEvent: function(e) {
	    e.preventDefault && e.preventDefault();
	    e.stopPropagation && e.stopPropagation();
	  },
	
	  /**
	   * Initializes event handlers related to cursor or selection
	   */
	  initCursorSelectionHandlers: function() {
	    this.initSelectedHandler();
	    this.initMousedownHandler();
	    this.initMouseupHandler();
	    this.initClicks();
	  },
	
	  /**
	   * Initializes double and triple click event handlers
	   */
	  initClicks: function() {
	    this.on('dblclick', function(options) {
	      this.selectWord(this.getSelectionStartFromPointer(options.e));
	    });
	    this.on('tripleclick', function(options) {
	      this.selectLine(this.getSelectionStartFromPointer(options.e));
	    });
	  },
	
	  /**
	   * Initializes "mousedown" event handler
	   */
	  initMousedownHandler: function() {
	    this.on('mousedown', function(options) {
	
	      var pointer = this.canvas.getPointer(options.e);
	
	      this.__mousedownX = pointer.x;
	      this.__mousedownY = pointer.y;
	      this.__isMousedown = true;
	
	      if (this.hiddenTextarea && this.canvas) {
	        this.canvas.wrapperEl.appendChild(this.hiddenTextarea);
	      }
	
	      if (this.selected) {
	        this.setCursorByClick(options.e);
	      }
	
	      if (this.isEditing) {
	        this.__selectionStartOnMouseDown = this.selectionStart;
	        this.initDelayedCursor(true);
	      }
	    });
	  },
	
	  /**
	   * @private
	   */
	  _isObjectMoved: function(e) {
	    var pointer = this.canvas.getPointer(e);
	
	    return this.__mousedownX !== pointer.x ||
	           this.__mousedownY !== pointer.y;
	  },
	
	  /**
	   * Initializes "mouseup" event handler
	   */
	  initMouseupHandler: function() {
	    this.on('mouseup', function(options) {
	      this.__isMousedown = false;
	      if (this._isObjectMoved(options.e)) {
	        return;
	      }
	
	      if (this.__lastSelected) {
	        this.enterEditing();
	        this.initDelayedCursor(true);
	      }
	      this.selected = true;
	    });
	  },
	
	  /**
	   * Changes cursor location in a text depending on passed pointer (x/y) object
	   * @param {Event} e Event object
	   */
	  setCursorByClick: function(e) {
	    var newSelectionStart = this.getSelectionStartFromPointer(e);
	
	    if (e.shiftKey) {
	      if (newSelectionStart < this.selectionStart) {
	        this.setSelectionEnd(this.selectionStart);
	        this.setSelectionStart(newSelectionStart);
	      }
	      else {
	        this.setSelectionEnd(newSelectionStart);
	      }
	    }
	    else {
	      this.setSelectionStart(newSelectionStart);
	      this.setSelectionEnd(newSelectionStart);
	    }
	  },
	
	  /**
	   * Returns index of a character corresponding to where an object was clicked
	   * @param {Event} e Event object
	   * @return {Number} Index of a character
	   */
	  getSelectionStartFromPointer: function(e) {
	    var mouseOffset = this.getLocalPointer(e),
	        prevWidth = 0,
	        width = 0,
	        height = 0,
	        charIndex = 0,
	        newSelectionStart,
	        line;
	
	    for (var i = 0, len = this._textLines.length; i < len; i++) {
	      line = this._textLines[i];
	      height += this._getHeightOfLine(this.ctx, i) * this.scaleY;
	
	      var widthOfLine = this._getLineWidth(this.ctx, i),
	          lineLeftOffset = this._getLineLeftOffset(widthOfLine);
	
	      width = lineLeftOffset * this.scaleX;
	
	      if (this.flipX) {
	        // when oject is horizontally flipped we reverse chars
	        // we should reverse also style or do not revers at all.
	        this._textLines[i] = line.reverse().join('');
	      }
	
	      for (var j = 0, jlen = line.length; j < jlen; j++) {
	
	        prevWidth = width;
	
	        width += this._getWidthOfChar(this.ctx, line[j], i, this.flipX ? jlen - j : j) *
	                 this.scaleX;
	
	        if (height <= mouseOffset.y || width <= mouseOffset.x) {
	          charIndex++;
	          continue;
	        }
	
	        return this._getNewSelectionStartFromOffset(
	          mouseOffset, prevWidth, width, charIndex + i, jlen);
	      }
	
	      if (mouseOffset.y < height) {
	        //this happens just on end of lines.
	        return this._getNewSelectionStartFromOffset(
	          mouseOffset, prevWidth, width, charIndex + i - 1, jlen);
	      }
	    }
	
	    // clicked somewhere after all chars, so set at the end
	    if (typeof newSelectionStart === 'undefined') {
	      return this.text.length;
	    }
	  },
	
	  /**
	   * @private
	   */
	  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {
	
	    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
	        distanceBtwNextCharAndCursor = width - mouseOffset.x,
	        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ? 0 : 1,
	        newSelectionStart = index + offset;
	
	    // if object is horizontally flipped, mirror cursor location from the end
	    if (this.flipX) {
	      newSelectionStart = jlen - newSelectionStart;
	    }
	
	    if (newSelectionStart > this.text.length) {
	      newSelectionStart = this.text.length;
	    }
	
	    return newSelectionStart;
	  }
	});
	
	
	fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	
	  /**
	   * Initializes hidden textarea (needed to bring up keyboard in iOS)
	   */
	  initHiddenTextarea: function() {
	    this.hiddenTextarea = fabric.document.createElement('textarea');
	
	    this.hiddenTextarea.setAttribute('autocapitalize', 'off');
	    this.hiddenTextarea.style.cssText = 'position: fixed; bottom: 20px; left: 0px; opacity: 0;'
	                                        + ' width: 0px; height: 0px; z-index: -999;';
	    fabric.document.body.appendChild(this.hiddenTextarea);
	
	    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
	    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
	
	    if (!this._clickHandlerInitialized && this.canvas) {
	      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
	      this._clickHandlerInitialized = true;
	    }
	  },
	
	  /**
	   * @private
	   */
	  _keysMap: {
	    8:  'removeChars',
	    9:  'exitEditing',
	    27: 'exitEditing',
	    13: 'insertNewline',
	    33: 'moveCursorUp',
	    34: 'moveCursorDown',
	    35: 'moveCursorRight',
	    36: 'moveCursorLeft',
	    37: 'moveCursorLeft',
	    38: 'moveCursorUp',
	    39: 'moveCursorRight',
	    40: 'moveCursorDown',
	    46: 'forwardDelete'
	  },
	
	  /**
	   * @private
	   */
	  _ctrlKeysMap: {
	    65: 'selectAll',
	    88: 'cut'
	  },
	
	  onClick: function() {
	    // No need to trigger click event here, focus is enough to have the keyboard appear on Android
	    this.hiddenTextarea && this.hiddenTextarea.focus();
	  },
	
	  /**
	   * Handles keyup event
	   * @param {Event} e Event object
	   */
	  onKeyDown: function(e) {
	    if (!this.isEditing) {
	      return;
	    }
	    if (e.keyCode in this._keysMap) {
	      this[this._keysMap[e.keyCode]](e);
	    }
	    else if ((e.keyCode in this._ctrlKeysMap) && (e.ctrlKey || e.metaKey)) {
	      this[this._ctrlKeysMap[e.keyCode]](e);
	    }
	    else {
	      return;
	    }
	    e.stopImmediatePropagation();
	    e.preventDefault();
	    this.canvas && this.canvas.renderAll();
	  },
	
	  /**
	   * Handles onInput event
	   * @param {Event} e Event object
	   */
	  onInput: function(e) {
	    if (!this.isEditing || this._cancelOnInput) {
	      this._cancelOnInput = false;
	      return;
	    }
	    var offset = this.selectionStart || 0,
	        textLength = this.text.length,
	        newTextLength = this.hiddenTextarea.value.length,
	        diff = newTextLength - textLength,
	        charsToInsert = this.hiddenTextarea.value.slice(offset, offset + diff);
	    this.insertChars(charsToInsert);
	    e.stopPropagation();
	  },
	
	  /**
	   * Forward delete
	   */
	  forwardDelete: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      if (this.selectionStart === this.text.length) {
	        return;
	      }
	      this.moveCursorRight(e);
	    }
	    this.removeChars(e);
	  },
	
	  /**
	   * Copies selected text
	   * @param {Event} e Event object
	   */
	  copy: function(e) {
	    var selectedText = this.getSelectedText(),
	        clipboardData = this._getClipboardData(e);
	
	    // Check for backward compatibility with old browsers
	    if (clipboardData) {
	      clipboardData.setData('text', selectedText);
	    }
	
	    fabric.copiedText = selectedText;
	    fabric.copiedTextStyle = this.getSelectionStyles(
	                          this.selectionStart,
	                          this.selectionEnd);
	  },
	
	  /**
	   * Pastes text
	   * @param {Event} e Event object
	   */
	  paste: function(e) {
	    var copiedText = null,
	        clipboardData = this._getClipboardData(e),
	        useCopiedStyle = true;
	
	    // Check for backward compatibility with old browsers
	    if (clipboardData) {
	      copiedText = clipboardData.getData('text').replace(/\r/g, '');
	      if (!fabric.copiedTextStyle || fabric.copiedText !== copiedText) {
	        useCopiedStyle = false;
	      }
	    }
	    else {
	      copiedText = fabric.copiedText;
	    }
	
	    if (copiedText) {
	      this.insertChars(copiedText, useCopiedStyle);
	    }
	    this._cancelOnInput = true;
	  },
	
	  /**
	   * Cuts text
	   * @param {Event} e Event object
	   */
	  cut: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      return;
	    }
	
	    this.copy();
	    this.removeChars(e);
	  },
	
	  /**
	   * @private
	   * @param {Event} e Event object
	   * @return {Object} Clipboard data object
	   */
	  _getClipboardData: function(e) {
	    return e && (e.clipboardData || fabric.window.clipboardData);
	  },
	
	  /**
	   * Gets start offset of a selection
	   * @param {Event} e Event object
	   * @param {Boolean} isRight
	   * @return {Number}
	   */
	  getDownCursorOffset: function(e, isRight) {
	    var selectionProp = isRight ? this.selectionEnd : this.selectionStart,
	        cursorLocation = this.get2DCursorLocation(selectionProp),
	        _char, lineLeftOffset, lineIndex = cursorLocation.lineIndex,
	        textOnSameLineBeforeCursor = this._textLines[lineIndex].slice(0, cursorLocation.charIndex),
	        textOnSameLineAfterCursor = this._textLines[lineIndex].slice(cursorLocation.charIndex),
	        textOnNextLine = this._textLines[lineIndex + 1] || '';
	
	    // if on last line, down cursor goes to end of line
	    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
	
	      // move to the end of a text
	      return this.text.length - selectionProp;
	    }
	
	    var widthOfSameLineBeforeCursor = this._getLineWidth(this.ctx, lineIndex);
	    lineLeftOffset = this._getLineLeftOffset(widthOfSameLineBeforeCursor);
	
	    var widthOfCharsOnSameLineBeforeCursor = lineLeftOffset;
	
	    for (var i = 0, len = textOnSameLineBeforeCursor.length; i < len; i++) {
	      _char = textOnSameLineBeforeCursor[i];
	      widthOfCharsOnSameLineBeforeCursor += this._getWidthOfChar(this.ctx, _char, lineIndex, i);
	    }
	
	    var indexOnNextLine = this._getIndexOnNextLine(
	      cursorLocation, textOnNextLine, widthOfCharsOnSameLineBeforeCursor);
	
	    return textOnSameLineAfterCursor.length + 1 + indexOnNextLine;
	  },
	
	  /**
	   * @private
	   */
	  _getIndexOnNextLine: function(cursorLocation, textOnNextLine, widthOfCharsOnSameLineBeforeCursor) {
	    var lineIndex = cursorLocation.lineIndex + 1,
	        widthOfNextLine = this._getLineWidth(this.ctx, lineIndex),
	        lineLeftOffset = this._getLineLeftOffset(widthOfNextLine),
	        widthOfCharsOnNextLine = lineLeftOffset,
	        indexOnNextLine = 0,
	        foundMatch;
	
	    for (var j = 0, jlen = textOnNextLine.length; j < jlen; j++) {
	
	      var _char = textOnNextLine[j],
	          widthOfChar = this._getWidthOfChar(this.ctx, _char, lineIndex, j);
	
	      widthOfCharsOnNextLine += widthOfChar;
	
	      if (widthOfCharsOnNextLine > widthOfCharsOnSameLineBeforeCursor) {
	
	        foundMatch = true;
	
	        var leftEdge = widthOfCharsOnNextLine - widthOfChar,
	            rightEdge = widthOfCharsOnNextLine,
	            offsetFromLeftEdge = Math.abs(leftEdge - widthOfCharsOnSameLineBeforeCursor),
	            offsetFromRightEdge = Math.abs(rightEdge - widthOfCharsOnSameLineBeforeCursor);
	
	        indexOnNextLine = offsetFromRightEdge < offsetFromLeftEdge ? j + 1 : j;
	
	        break;
	      }
	    }
	
	    // reached end
	    if (!foundMatch) {
	      indexOnNextLine = textOnNextLine.length;
	    }
	
	    return indexOnNextLine;
	  },
	
	  /**
	   * Moves cursor down
	   * @param {Event} e Event object
	   */
	  moveCursorDown: function(e) {
	    this.abortCursorAnimation();
	    this._currentCursorOpacity = 1;
	
	    var offset = this.getDownCursorOffset(e, this._selectionDirection === 'right');
	
	    if (e.shiftKey) {
	      this.moveCursorDownWithShift(offset);
	    }
	    else {
	      this.moveCursorDownWithoutShift(offset);
	    }
	
	    this.initDelayedCursor();
	  },
	
	  /**
	   * Moves cursor down without keeping selection
	   * @param {Number} offset
	   */
	  moveCursorDownWithoutShift: function(offset) {
	    this._selectionDirection = 'right';
	    this.setSelectionStart(this.selectionStart + offset);
	    this.setSelectionEnd(this.selectionStart);
	  },
	
	  /**
	   * private
	   */
	  swapSelectionPoints: function() {
	    var swapSel = this.selectionEnd;
	    this.setSelectionEnd(this.selectionStart);
	    this.setSelectionStart(swapSel);
	  },
	
	  /**
	   * Moves cursor down while keeping selection
	   * @param {Number} offset
	   */
	  moveCursorDownWithShift: function(offset) {
	    if (this.selectionEnd === this.selectionStart) {
	      this._selectionDirection = 'right';
	    }
	    if (this._selectionDirection === 'right') {
	      this.setSelectionEnd(this.selectionEnd + offset);
	    }
	    else {
	      this.setSelectionStart(this.selectionStart + offset);
	    }
	    if (this.selectionEnd < this.selectionStart  && this._selectionDirection === 'left') {
	      this.swapSelectionPoints();
	      this._selectionDirection = 'right';
	    }
	    if (this.selectionEnd > this.text.length) {
	      this.setSelectionEnd(this.text.length);
	    }
	  },
	
	  /**
	   * @param {Event} e Event object
	   * @param {Boolean} isRight
	   * @return {Number}
	   */
	  getUpCursorOffset: function(e, isRight) {
	    var selectionProp = isRight ? this.selectionEnd : this.selectionStart,
	        cursorLocation = this.get2DCursorLocation(selectionProp),
	        lineIndex = cursorLocation.lineIndex;
	    // if on first line, up cursor goes to start of line
	    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
	      return selectionProp;
	    }
	
	    var textOnSameLineBeforeCursor = this._textLines[lineIndex].slice(0, cursorLocation.charIndex),
	        textOnPreviousLine = this._textLines[lineIndex - 1] || '',
	        _char,
	        widthOfSameLineBeforeCursor = this._getLineWidth(this.ctx, cursorLocation.lineIndex),
	        lineLeftOffset = this._getLineLeftOffset(widthOfSameLineBeforeCursor),
	        widthOfCharsOnSameLineBeforeCursor = lineLeftOffset;
	
	    for (var i = 0, len = textOnSameLineBeforeCursor.length; i < len; i++) {
	      _char = textOnSameLineBeforeCursor[i];
	      widthOfCharsOnSameLineBeforeCursor += this._getWidthOfChar(this.ctx, _char, lineIndex, i);
	    }
	
	    var indexOnPrevLine = this._getIndexOnPrevLine(
	      cursorLocation, textOnPreviousLine, widthOfCharsOnSameLineBeforeCursor);
	
	    return textOnPreviousLine.length - indexOnPrevLine + textOnSameLineBeforeCursor.length;
	  },
	
	  /**
	   * @private
	   */
	  _getIndexOnPrevLine: function(cursorLocation, textOnPreviousLine, widthOfCharsOnSameLineBeforeCursor) {
	
	    var lineIndex = cursorLocation.lineIndex - 1,
	        widthOfPreviousLine = this._getLineWidth(this.ctx, lineIndex),
	        lineLeftOffset = this._getLineLeftOffset(widthOfPreviousLine),
	        widthOfCharsOnPreviousLine = lineLeftOffset,
	        indexOnPrevLine = 0,
	        foundMatch;
	
	    for (var j = 0, jlen = textOnPreviousLine.length; j < jlen; j++) {
	
	      var _char = textOnPreviousLine[j],
	          widthOfChar = this._getWidthOfChar(this.ctx, _char, lineIndex, j);
	
	      widthOfCharsOnPreviousLine += widthOfChar;
	
	      if (widthOfCharsOnPreviousLine > widthOfCharsOnSameLineBeforeCursor) {
	
	        foundMatch = true;
	
	        var leftEdge = widthOfCharsOnPreviousLine - widthOfChar,
	            rightEdge = widthOfCharsOnPreviousLine,
	            offsetFromLeftEdge = Math.abs(leftEdge - widthOfCharsOnSameLineBeforeCursor),
	            offsetFromRightEdge = Math.abs(rightEdge - widthOfCharsOnSameLineBeforeCursor);
	
	        indexOnPrevLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
	
	        break;
	      }
	    }
	
	    // reached end
	    if (!foundMatch) {
	      indexOnPrevLine = textOnPreviousLine.length - 1;
	    }
	
	    return indexOnPrevLine;
	  },
	
	  /**
	   * Moves cursor up
	   * @param {Event} e Event object
	   */
	  moveCursorUp: function(e) {
	
	    this.abortCursorAnimation();
	    this._currentCursorOpacity = 1;
	
	    var offset = this.getUpCursorOffset(e, this._selectionDirection === 'right');
	    if (e.shiftKey) {
	      this.moveCursorUpWithShift(offset);
	    }
	    else {
	      this.moveCursorUpWithoutShift(offset);
	    }
	
	    this.initDelayedCursor();
	  },
	
	  /**
	   * Moves cursor up with shift
	   * @param {Number} offset
	   */
	  moveCursorUpWithShift: function(offset) {
	    if (this.selectionEnd === this.selectionStart) {
	      this._selectionDirection = 'left';
	    }
	    if (this._selectionDirection === 'right') {
	      this.setSelectionEnd(this.selectionEnd - offset);
	    }
	    else {
	      this.setSelectionStart(this.selectionStart - offset);
	    }
	    if (this.selectionEnd < this.selectionStart && this._selectionDirection === 'right') {
	      this.swapSelectionPoints();
	      this._selectionDirection = 'left';
	    }
	  },
	
	  /**
	   * Moves cursor up without shift
	   * @param {Number} offset
	   */
	  moveCursorUpWithoutShift: function(offset) {
	    if (this.selectionStart === this.selectionEnd) {
	      this.setSelectionStart(this.selectionStart - offset);
	    }
	    this.setSelectionEnd(this.selectionStart);
	
	    this._selectionDirection = 'left';
	  },
	
	  /**
	   * Moves cursor left
	   * @param {Event} e Event object
	   */
	  moveCursorLeft: function(e) {
	    if (this.selectionStart === 0 && this.selectionEnd === 0) {
	      return;
	    }
	
	    this.abortCursorAnimation();
	    this._currentCursorOpacity = 1;
	
	    if (e.shiftKey) {
	      this.moveCursorLeftWithShift(e);
	    }
	    else {
	      this.moveCursorLeftWithoutShift(e);
	    }
	
	    this.initDelayedCursor();
	  },
	
	  /**
	   * @private
	   */
	  _move: function(e, prop, direction) {
	    var propMethod = (prop === 'selectionStart' ? 'setSelectionStart' : 'setSelectionEnd');
	    if (e.altKey) {
	      this[propMethod](this['findWordBoundary' + direction](this[prop]));
	    }
	    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
	      this[propMethod](this['findLineBoundary' + direction](this[prop]));
	    }
	    else {
	      this[propMethod](this[prop] + (direction === 'Left' ? -1 : 1));
	    }
	  },
	
	  /**
	   * @private
	   */
	  _moveLeft: function(e, prop) {
	    this._move(e, prop, 'Left');
	  },
	
	  /**
	   * @private
	   */
	  _moveRight: function(e, prop) {
	    this._move(e, prop, 'Right');
	  },
	
	  /**
	   * Moves cursor left without keeping selection
	   * @param {Event} e
	   */
	  moveCursorLeftWithoutShift: function(e) {
	    this._selectionDirection = 'left';
	
	    // only move cursor when there is no selection,
	    // otherwise we discard it, and leave cursor on same place
	    if (this.selectionEnd === this.selectionStart) {
	      this._moveLeft(e, 'selectionStart');
	    }
	    this.setSelectionEnd(this.selectionStart);
	  },
	
	  /**
	   * Moves cursor left while keeping selection
	   * @param {Event} e
	   */
	  moveCursorLeftWithShift: function(e) {
	    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
	      this._moveLeft(e, 'selectionEnd');
	    }
	    else {
	      this._selectionDirection = 'left';
	      this._moveLeft(e, 'selectionStart');
	    }
	  },
	
	  /**
	   * Moves cursor right
	   * @param {Event} e Event object
	   */
	  moveCursorRight: function(e) {
	    if (this.selectionStart >= this.text.length && this.selectionEnd >= this.text.length) {
	      return;
	    }
	
	    this.abortCursorAnimation();
	    this._currentCursorOpacity = 1;
	
	    if (e.shiftKey) {
	      this.moveCursorRightWithShift(e);
	    }
	    else {
	      this.moveCursorRightWithoutShift(e);
	    }
	
	    this.initDelayedCursor();
	  },
	
	  /**
	   * Moves cursor right while keeping selection
	   * @param {Event} e
	   */
	  moveCursorRightWithShift: function(e) {
	    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
	      this._moveRight(e, 'selectionStart');
	    }
	    else {
	      this._selectionDirection = 'right';
	      this._moveRight(e, 'selectionEnd');
	    }
	  },
	
	  /**
	   * Moves cursor right without keeping selection
	   * @param {Event} e Event object
	   */
	  moveCursorRightWithoutShift: function(e) {
	    this._selectionDirection = 'right';
	
	    if (this.selectionStart === this.selectionEnd) {
	      this._moveRight(e, 'selectionStart');
	      this.setSelectionEnd(this.selectionStart);
	    }
	    else {
	      this.setSelectionEnd(this.selectionEnd + this.getNumNewLinesInSelectedText());
	      this.setSelectionStart(this.selectionEnd);
	    }
	  },
	
	  /**
	   * Removes characters selected by selection
	   * @param {Event} e Event object
	   */
	  removeChars: function(e) {
	    if (this.selectionStart === this.selectionEnd) {
	      this._removeCharsNearCursor(e);
	    }
	    else {
	      this._removeCharsFromTo(this.selectionStart, this.selectionEnd);
	    }
	
	    this.setSelectionEnd(this.selectionStart);
	
	    this._removeExtraneousStyles();
	
	    this.canvas && this.canvas.renderAll();
	
	    this.setCoords();
	    this.fire('changed');
	    this.canvas && this.canvas.fire('text:changed', { target: this });
	  },
	
	  /**
	   * @private
	   * @param {Event} e Event object
	   */
	  _removeCharsNearCursor: function(e) {
	    if (this.selectionStart === 0) {
	      return;
	    }
	    if (e.metaKey) {
	      // remove all till the start of current line
	      var leftLineBoundary = this.findLineBoundaryLeft(this.selectionStart);
	
	      this._removeCharsFromTo(leftLineBoundary, this.selectionStart);
	      this.setSelectionStart(leftLineBoundary);
	    }
	    else if (e.altKey) {
	      // remove all till the start of current word
	      var leftWordBoundary = this.findWordBoundaryLeft(this.selectionStart);
	
	      this._removeCharsFromTo(leftWordBoundary, this.selectionStart);
	      this.setSelectionStart(leftWordBoundary);
	    }
	    else {
	      this._removeSingleCharAndStyle(this.selectionStart);
	      this.setSelectionStart(this.selectionStart - 1);
	    }
	  }
	});
	
	
	/* _TO_SVG_START_ */
	(function() {
	  var toFixed = fabric.util.toFixed,
	      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
	
	  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
	
	    /**
	     * @private
	     */
	    _setSVGTextLineText: function(lineIndex, textSpans, height, textLeftOffset, textTopOffset, textBgRects) {
	      if (!this.styles[lineIndex]) {
	        fabric.Text.prototype._setSVGTextLineText.call(this,
	          lineIndex, textSpans, height, textLeftOffset, textTopOffset);
	      }
	      else {
	        this._setSVGTextLineChars(
	          lineIndex, textSpans, height, textLeftOffset, textBgRects);
	      }
	    },
	
	    /**
	     * @private
	     */
	    _setSVGTextLineChars: function(lineIndex, textSpans, height, textLeftOffset, textBgRects) {
	
	      var chars = this._textLines[lineIndex],
	          charOffset = 0,
	          lineLeftOffset = this._getSVGLineLeftOffset(lineIndex) - this.width / 2,
	          lineOffset = this._getSVGLineTopOffset(lineIndex),
	          heightOfLine = this._getHeightOfLine(this.ctx, lineIndex);
	
	      for (var i = 0, len = chars.length; i < len; i++) {
	        var styleDecl = this.styles[lineIndex][i] || { };
	
	        textSpans.push(
	          this._createTextCharSpan(
	            chars[i], styleDecl, lineLeftOffset, lineOffset.lineTop + lineOffset.offset, charOffset));
	
	        var charWidth = this._getWidthOfChar(this.ctx, chars[i], lineIndex, i);
	
	        if (styleDecl.textBackgroundColor) {
	          textBgRects.push(
	            this._createTextCharBg(
	              styleDecl, lineLeftOffset, lineOffset.lineTop, heightOfLine, charWidth, charOffset));
	        }
	
	        charOffset += charWidth;
	      }
	    },
	
	    /**
	     * @private
	     */
	    _getSVGLineLeftOffset: function(lineIndex) {
	      return fabric.util.toFixed(this._getLineLeftOffset(this.__lineWidths[lineIndex]), 2);
	    },
	
	    /**
	     * @private
	     */
	    _getSVGLineTopOffset: function(lineIndex) {
	      var lineTopOffset = 0, lastHeight = 0;
	      for (var j = 0; j < lineIndex; j++) {
	        lineTopOffset += this._getHeightOfLine(this.ctx, j);
	      }
	      lastHeight = this._getHeightOfLine(this.ctx, j);
	      return {
	        lineTop: lineTopOffset,
	        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
	      };
	    },
	
	    /**
	     * @private
	     */
	    _createTextCharBg: function(styleDecl, lineLeftOffset, lineTopOffset, heightOfLine, charWidth, charOffset) {
	      return [
	        //jscs:disable validateIndentation
	        '<rect fill="', styleDecl.textBackgroundColor,
	        '" x="', toFixed(lineLeftOffset + charOffset, NUM_FRACTION_DIGITS),
	        '" y="', toFixed(lineTopOffset - this.height/2, NUM_FRACTION_DIGITS),
	        '" width="', toFixed(charWidth, NUM_FRACTION_DIGITS),
	        '" height="', toFixed(heightOfLine / this.lineHeight, NUM_FRACTION_DIGITS),
	        '"></rect>'
	        //jscs:enable validateIndentation
	      ].join('');
	    },
	
	    /**
	     * @private
	     */
	    _createTextCharSpan: function(_char, styleDecl, lineLeftOffset, lineTopOffset, charOffset) {
	
	      var fillStyles = this.getSvgStyles.call(fabric.util.object.extend({
	        visible: true,
	        fill: this.fill,
	        stroke: this.stroke,
	        type: 'text'
	      }, styleDecl));
	
	      return [
	        //jscs:disable validateIndentation
	        '<tspan x="', lineLeftOffset + charOffset, '" y="',
	          lineTopOffset - this.height/2, '" ',
	          (styleDecl.fontFamily ? 'font-family="' + styleDecl.fontFamily.replace(/"/g, '\'') + '" ': ''),
	          (styleDecl.fontSize ? 'font-size="' + styleDecl.fontSize + '" ': ''),
	          (styleDecl.fontStyle ? 'font-style="' + styleDecl.fontStyle + '" ': ''),
	          (styleDecl.fontWeight ? 'font-weight="' + styleDecl.fontWeight + '" ': ''),
	          (styleDecl.textDecoration ? 'text-decoration="' + styleDecl.textDecoration + '" ': ''),
	          'style="', fillStyles, '">',
	          fabric.util.string.escapeXml(_char),
	        '</tspan>'
	        //jscs:enable validateIndentation
	      ].join('');
	    }
	  });
	})();
	/* _TO_SVG_END_ */
	
	
	(function(global) {
	
	  'use strict';
	
	  var fabric = global.fabric || (global.fabric = {}),
	      clone  = fabric.util.object.clone;
	
	  /**
	   * Textbox class, based on IText, allows the user to resize the text rectangle
	   * and wraps lines automatically. Textboxes have their Y scaling locked, the
	   * user can only change width. Height is adjusted automatically based on the
	   * wrapping of lines.
	   * @class fabric.Textbox
	   * @extends fabric.IText
	   * @mixes fabric.Observable
	   * @return {fabric.Textbox} thisArg
	   * @see {@link fabric.Textbox#initialize} for constructor definition
	   */
	  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {
	    /**
	     * Type of an object
	     * @type String
	     * @default
	     */
	    type: 'textbox',
	    /**
	     * Minimum width of textbox, in pixels.
	     * @type Number
	     * @default
	     */
	    minWidth: 20,
	    /**
	     * Minimum calculated width of a textbox, in pixels.
	     * @type Number
	     * @default
	     */
	    dynamicMinWidth: 0,
	    /**
	     * Cached array of text wrapping.
	     * @type Array
	     */
	    __cachedLines: null,
	    /**
	     * Constructor. Some scaling related property values are forced. Visibility
	     * of controls is also fixed; only the rotation and width controls are
	     * made available.
	     * @param {String} text Text string
	     * @param {Object} [options] Options object
	     * @return {fabric.Textbox} thisArg
	     */
	    initialize: function(text, options) {
	      this.ctx = fabric.util.createCanvasElement().getContext('2d');
	
	      this.callSuper('initialize', text, options);
	      this.set({
	        lockUniScaling: false,
	        lockScalingY: true,
	        lockScalingFlip: true,
	        hasBorders: true
	      });
	      this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());
	
	      // add width to this list of props that effect line wrapping.
	      this._dimensionAffectingProps.width = true;
	    },
	
	    /**
	     * Unlike superclass's version of this function, Textbox does not update
	     * its width.
	     * @param {CanvasRenderingContext2D} ctx Context to use for measurements
	     * @private
	     * @override
	     */
	    _initDimensions: function(ctx) {
	      if (this.__skipDimension) {
	        return;
	      }
	
	      if (!ctx) {
	        ctx = fabric.util.createCanvasElement().getContext('2d');
	        this._setTextStyles(ctx);
	      }
	
	      // clear dynamicMinWidth as it will be different after we re-wrap line
	      this.dynamicMinWidth = 0;
	
	      // wrap lines
	      this._textLines = this._splitTextIntoLines();
	
	      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
	      if (this.dynamicMinWidth > this.width) {
	        this._set('width', this.dynamicMinWidth);
	      }
	
	      // clear cache and re-calculate height
	      this._clearCache();
	      this.height = this._getTextHeight(ctx);
	      this._setLineWidths();
	    },
	
	    /**
	     * set the __lineWidths cache array to support
	     * functions that expect it to be filled
	     * @private
	     */
	    _setLineWidths: function() {
	      for (var i = 0, len = this._textLines.length; i < len; i++) {
	        this.__lineWidths[i] = this.width;
	      }
	    },
	
	    /**
	     * Generate an object that translates the style object so that it is
	     * broken up by visual lines (new lines and automatic wrapping).
	     * The original text styles object is broken up by actual lines (new lines only),
	     * which is only sufficient for Text / IText
	     * @private
	     */
	    _generateStyleMap: function() {
	      var realLineCount     = 0,
	          realLineCharCount = 0,
	          charCount         = 0,
	          map               = {};
	
	      for (var i = 0; i < this._textLines.length; i++) {
	        if (this.text[charCount] === '\n') {
	          realLineCharCount = 0;
	          charCount++;
	          realLineCount++;
	        }
	        else if (this.text[charCount] === ' ') {
	          // this case deals with space's that are removed from end of lines when wrapping
	          realLineCharCount++;
	          charCount++;
	        }
	
	        map[i] = { line: realLineCount, offset: realLineCharCount };
	
	        charCount += this._textLines[i].length;
	        realLineCharCount += this._textLines[i].length;
	      }
	
	      return map;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Boolean} [returnCloneOrEmpty=false]
	     * @private
	     */
	    _getStyleDeclaration: function(lineIndex, charIndex, returnCloneOrEmpty) {
	      if (this._styleMap) {
	        var map = this._styleMap[lineIndex];
	        lineIndex = map.line;
	        charIndex = map.offset + charIndex;
	      }
	
	      if (returnCloneOrEmpty) {
	        return (this.styles[lineIndex] && this.styles[lineIndex][charIndex])
	          ? clone(this.styles[lineIndex][charIndex])
	          : {};
	      }
	
	      return this.styles[lineIndex] && this.styles[lineIndex][charIndex] ? this.styles[lineIndex][charIndex] : null;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @param {Object} style
	     * @private
	     */
	    _setStyleDeclaration: function(lineIndex, charIndex, style) {
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      this.styles[lineIndex][charIndex] = style;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Number} charIndex
	     * @private
	     */
	    _deleteStyleDeclaration: function(lineIndex, charIndex) {
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      delete this.styles[lineIndex][charIndex];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _getLineStyle: function(lineIndex) {
	      var map = this._styleMap[lineIndex];
	      return this.styles[map.line];
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @param {Object} style
	     * @private
	     */
	    _setLineStyle: function(lineIndex, style) {
	      var map = this._styleMap[lineIndex];
	      this.styles[map.line] = style;
	    },
	
	    /**
	     * @param {Number} lineIndex
	     * @private
	     */
	    _deleteLineStyle: function(lineIndex) {
	      var map = this._styleMap[lineIndex];
	      delete this.styles[map.line];
	    },
	
	    /**
	     * Wraps text using the 'width' property of Textbox. First this function
	     * splits text on newlines, so we preserve newlines entered by the user.
	     * Then it wraps each line using the width of the Textbox by calling
	     * _wrapLine().
	     * @param {CanvasRenderingContext2D} ctx Context to use for measurements
	     * @param {String} text The string of text that is split into lines
	     * @returns {Array} Array of lines
	     */
	    _wrapText: function(ctx, text) {
	      var lines = text.split(this._reNewline), wrapped = [], i;
	
	      for (i = 0; i < lines.length; i++) {
	        wrapped = wrapped.concat(this._wrapLine(ctx, lines[i], i));
	      }
	
	      return wrapped;
	    },
	
	    /**
	     * Helper function to measure a string of text, given its lineIndex and charIndex offset
	     *
	     * @param {CanvasRenderingContext2D} ctx
	     * @param {String} text
	     * @param {number} lineIndex
	     * @param {number} charOffset
	     * @returns {number}
	     * @private
	     */
	    _measureText: function(ctx, text, lineIndex, charOffset) {
	      var width = 0, decl;
	      charOffset = charOffset || 0;
	
	      for (var i = 0; i < text.length; i++) {
	        if (this.styles && this.styles[lineIndex] && (decl = this.styles[lineIndex][i + charOffset])) {
	          ctx.save();
	          width += this._applyCharStylesGetWidth(ctx, text[i], lineIndex, i, decl);
	          ctx.restore();
	        }
	        else {
	          // @note: we intentionally pass in an empty style declaration, because if we pass in nothing, it will
	          // retry fetching style declaration
	          width += this._applyCharStylesGetWidth(ctx, text[i], lineIndex, i, {});
	        }
	      }
	
	      return width;
	    },
	
	    /**
	     * Wraps a line of text using the width of the Textbox and a context.
	     * @param {CanvasRenderingContext2D} ctx Context to use for measurements
	     * @param {String} text The string of text to split into lines
	     * @param {Number} lineIndex
	     * @returns {Array} Array of line(s) into which the given text is wrapped
	     * to.
	     */
	    _wrapLine: function(ctx, text, lineIndex) {
	      var maxWidth  = this.width,
	          lineWidth = this._measureText(ctx, text, lineIndex, 0);
	
	      // first case: does the whole line fit?
	      if (lineWidth < maxWidth) {
	        // if the current line is only one word, we need to keep track of it if it's a large word
	        if (text.indexOf(' ') === -1 && lineWidth > this.dynamicMinWidth) {
	          this.dynamicMinWidth = lineWidth;
	        }
	
	        return [text];
	      }
	
	      // if the whole line doesn't fit, we break it up into words
	      var lines            = [],
	          line             = '',
	          words            = text.split(' '),
	          offset           = 0,
	          infix            = '',
	          wordWidth        = 0,
	          largestWordWidth = 0;
	
	      while (words.length > 0) {
	        infix = line === '' ? '' : ' ';
	        wordWidth = this._measureText(ctx, words[0], lineIndex, line.length + infix.length + offset);
	        lineWidth = line === '' ? wordWidth : this._measureText(ctx, line + infix + words[0], lineIndex, offset);
	
	        if (lineWidth < maxWidth || (line === '' && wordWidth >= maxWidth)) {
	          line += infix + words.shift();
	        }
	        else {
	          offset += line.length + 1; // add 1 because each word is separated by a space
	          lines.push(line);
	          line = '';
	        }
	
	        if (words.length === 0) {
	          lines.push(line);
	        }
	
	        // keep track of largest word
	        if (wordWidth > largestWordWidth) {
	          largestWordWidth = wordWidth;
	        }
	      }
	
	      if (largestWordWidth > this.dynamicMinWidth) {
	        this.dynamicMinWidth = largestWordWidth;
	      }
	
	      return lines;
	    },
	
	    /**
	     * Gets lines of text to render in the Textbox. This function calculates
	     * text wrapping on the fly everytime it is called.
	     * @returns {Array} Array of lines in the Textbox.
	     * @override
	     */
	    _splitTextIntoLines: function() {
	      this.ctx.save();
	      this._setTextStyles(this.ctx);
	
	      var lines = this._wrapText(this.ctx, this.text);
	
	      this.ctx.restore();
	      this._textLines = lines;
	      this._styleMap = this._generateStyleMap();
	      return lines;
	    },
	
	    /**
	     * When part of a group, we don't want the Textbox's scale to increase if
	     * the group's increases. That's why we reduce the scale of the Textbox by
	     * the amount that the group's increases. This is to maintain the effective
	     * scale of the Textbox at 1, so that font-size values make sense. Otherwise
	     * the same font-size value would result in different actual size depending
	     * on the value of the scale.
	     * @param {String} key
	     * @param {Any} value
	     */
	    setOnGroup: function(key, value) {
	      if (key === 'scaleX') {
	        this.set('scaleX', Math.abs(1 / value));
	        this.set('width', (this.get('width') * value) /
	          (typeof this.__oldScaleX === 'undefined' ? 1 : this.__oldScaleX));
	        this.__oldScaleX = value;
	      }
	    },
	
	    /**
	     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start).
	     * Overrides the superclass function to take into account text wrapping.
	     *
	     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
	     */
	    get2DCursorLocation: function(selectionStart) {
	      if (typeof selectionStart === 'undefined') {
	        selectionStart = this.selectionStart;
	      }
	
	      var numLines = this._textLines.length,
	          removed  = 0;
	
	      for (var i = 0; i < numLines; i++) {
	        var line    = this._textLines[i],
	            lineLen = line.length;
	
	        if (selectionStart <= removed + lineLen) {
	          return {
	            lineIndex: i,
	            charIndex: selectionStart - removed
	          };
	        }
	
	        removed += lineLen;
	
	        if (this.text[removed] === '\n' || this.text[removed] === ' ') {
	          removed++;
	        }
	      }
	
	      return {
	        lineIndex: numLines - 1,
	        charIndex: this._textLines[numLines - 1].length
	      };
	    },
	
	    /**
	     * Overrides superclass function and uses text wrapping data to get cursor
	     * boundary offsets instead of the array of chars.
	     * @param {Array} chars Unused
	     * @param {String} typeOfBoundaries Can be 'cursor' or 'selection'
	     * @returns {Object} Object with 'top', 'left', and 'lineLeft' properties set.
	     */
	    _getCursorBoundariesOffsets: function(chars, typeOfBoundaries) {
	      var topOffset      = 0,
	          leftOffset     = 0,
	          cursorLocation = this.get2DCursorLocation(),
	          lineChars      = this._textLines[cursorLocation.lineIndex].split(''),
	          lineLeftOffset = this._getCachedLineOffset(cursorLocation.lineIndex);
	
	      for (var i = 0; i < cursorLocation.charIndex; i++) {
	        leftOffset += this._getWidthOfChar(this.ctx, lineChars[i], cursorLocation.lineIndex, i);
	      }
	
	      for (i = 0; i < cursorLocation.lineIndex; i++) {
	        topOffset += this._getHeightOfLine(this.ctx, i);
	      }
	
	      if (typeOfBoundaries === 'cursor') {
	        topOffset += (1 - this._fontSizeFraction) * this._getHeightOfLine(this.ctx, cursorLocation.lineIndex)
	          / this.lineHeight - this.getCurrentCharFontSize(cursorLocation.lineIndex, cursorLocation.charIndex)
	          * (1 - this._fontSizeFraction);
	      }
	
	      return {
	        top: topOffset,
	        left: leftOffset,
	        lineLeft: lineLeftOffset
	      };
	    },
	
	    getMinWidth: function() {
	      return Math.max(this.minWidth, this.dynamicMinWidth);
	    },
	
	    /**
	     * Returns object representation of an instance
	     * @method toObject
	     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
	     * @return {Object} object representation of an instance
	     */
	    toObject: function(propertiesToInclude) {
	      return fabric.util.object.extend(this.callSuper('toObject', propertiesToInclude), {
	        minWidth: this.minWidth
	      });
	    }
	  });
	  /**
	   * Returns fabric.Textbox instance from an object representation
	   * @static
	   * @memberOf fabric.Textbox
	   * @param {Object} object Object to create an instance from
	   * @return {fabric.Textbox} instance of fabric.Textbox
	   */
	  fabric.Textbox.fromObject = function(object) {
	    return new fabric.Textbox(object.text, clone(object));
	  };
	  /**
	   * Returns the default controls visibility required for Textboxes.
	   * @returns {Object}
	   */
	  fabric.Textbox.getTextboxControlVisibility = function() {
	    return {
	      tl: false,
	      tr: false,
	      br: false,
	      bl: false,
	      ml: true,
	      mt: false,
	      mr: true,
	      mb: false,
	      mtr: true
	    };
	  };
	  /**
	   * Contains all fabric.Textbox objects that have been created
	   * @static
	   * @memberOf fabric.Textbox
	   * @type Array
	   */
	  fabric.Textbox.instances = [];
	})( true ? exports : this);
	
	
	(function() {
	
	  /**
	   * Override _setObjectScale and add Textbox specific resizing behavior. Resizing
	   * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.
	   */
	  var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;
	
	  fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,
	                                                     lockScalingX, lockScalingY, by, lockScalingFlip) {
	
	    var t = transform.target;
	    if (t instanceof fabric.Textbox) {
	      var w = t.width * ((localMouse.x / transform.scaleX) / (t.width + t.strokeWidth));
	      if (w >= t.getMinWidth()) {
	        t.set('width', w);
	      }
	    }
	    else {
	      setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,
	        lockScalingX, lockScalingY, by, lockScalingFlip);
	    }
	  };
	
	  /**
	   * Sets controls of this group to the Textbox's special configuration if
	   * one is present in the group. Deletes _controlsVisibility otherwise, so that
	   * it gets initialized to default value at runtime.
	   */
	  fabric.Group.prototype._refreshControlsVisibility = function() {
	    if (typeof fabric.Textbox === 'undefined') {
	      return;
	    }
	    for (var i = this._objects.length; i--;) {
	      if (this._objects[i] instanceof fabric.Textbox) {
	        this.setControlsVisibility(fabric.Textbox.getTextboxControlVisibility());
	        return;
	      }
	    }
	  };
	
	  var clone = fabric.util.object.clone;
	
	  fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {
	    /**
	     * @private
	     */
	    _removeExtraneousStyles: function() {
	      for (var prop in this._styleMap) {
	        if (!this._textLines[prop]) {
	          delete this.styles[this._styleMap[prop].line];
	        }
	      }
	    },
	
	    /**
	     * Inserts style object for a given line/char index
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Object} [style] Style object to insert, if given
	     */
	    insertCharStyleObject: function(lineIndex, charIndex, style) {
	      // adjust lineIndex and charIndex
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      fabric.IText.prototype.insertCharStyleObject.apply(this, [lineIndex, charIndex, style]);
	    },
	
	    /**
	     * Inserts new style object
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} charIndex Index of a char
	     * @param {Boolean} isEndOfLine True if it's end of line
	     */
	    insertNewlineStyleObject: function(lineIndex, charIndex, isEndOfLine) {
	      // adjust lineIndex and charIndex
	      var map = this._styleMap[lineIndex];
	      lineIndex = map.line;
	      charIndex = map.offset + charIndex;
	
	      fabric.IText.prototype.insertNewlineStyleObject.apply(this, [lineIndex, charIndex, isEndOfLine]);
	    },
	
	    /**
	     * Shifts line styles up or down. This function is slightly different than the one in
	     * itext_behaviour as it takes into account the styleMap.
	     *
	     * @param {Number} lineIndex Index of a line
	     * @param {Number} offset Can be -1 or +1
	     */
	    shiftLineStyles: function(lineIndex, offset) {
	      // shift all line styles by 1 upward
	      var clonedStyles = clone(this.styles),
	          map          = this._styleMap[lineIndex];
	
	      // adjust line index
	      lineIndex = map.line;
	
	      for (var line in this.styles) {
	        var numericLine = parseInt(line, 10);
	
	        if (numericLine > lineIndex) {
	          this.styles[numericLine + offset] = clonedStyles[numericLine];
	
	          if (!clonedStyles[numericLine - offset]) {
	            delete this.styles[numericLine];
	          }
	        }
	      }
	      //TODO: evaluate if delete old style lines with offset -1
	    },
	
	    /**
	     * Figure out programatically the text on previous actual line (actual = separated by \n);
	     *
	     * @param {Number} lIndex
	     * @returns {String}
	     * @private
	     */
	    _getTextOnPreviousLine: function(lIndex) {
	      var textOnPreviousLine = this._textLines[lIndex - 1];
	
	      while (this._styleMap[lIndex - 2] && this._styleMap[lIndex - 2].line === this._styleMap[lIndex - 1].line) {
	        textOnPreviousLine = this._textLines[lIndex - 2] + textOnPreviousLine;
	
	        lIndex--;
	      }
	
	      return textOnPreviousLine;
	    },
	
	    /**
	     * Removes style object
	     * @param {Boolean} isBeginningOfLine True if cursor is at the beginning of line
	     * @param {Number} [index] Optional index. When not given, current selectionStart is used.
	     */
	    removeStyleObject: function(isBeginningOfLine, index) {
	
	      var cursorLocation = this.get2DCursorLocation(index),
	          map            = this._styleMap[cursorLocation.lineIndex],
	          lineIndex      = map.line,
	          charIndex      = map.offset + cursorLocation.charIndex;
	
	      if (isBeginningOfLine) {
	        var textOnPreviousLine     = this._getTextOnPreviousLine(cursorLocation.lineIndex),
	            newCharIndexOnPrevLine = textOnPreviousLine ? textOnPreviousLine.length : 0;
	
	        if (!this.styles[lineIndex - 1]) {
	          this.styles[lineIndex - 1] = {};
	        }
	
	        for (charIndex in this.styles[lineIndex]) {
	          this.styles[lineIndex - 1][parseInt(charIndex, 10) + newCharIndexOnPrevLine]
	            = this.styles[lineIndex][charIndex];
	        }
	
	        this.shiftLineStyles(cursorLocation.lineIndex, -1);
	
	      }
	      else {
	        var currentLineStyles = this.styles[lineIndex];
	
	        if (currentLineStyles) {
	          delete currentLineStyles[charIndex];
	          //console.log('deleting', lineIndex, charIndex + offset);
	        }
	
	        var currentLineStylesCloned = clone(currentLineStyles);
	
	        // shift all styles by 1 backwards
	        for (var i in currentLineStylesCloned) {
	          var numericIndex = parseInt(i, 10);
	          if (numericIndex >= charIndex && numericIndex !== 0) {
	            currentLineStyles[numericIndex - 1] = currentLineStylesCloned[numericIndex];
	            delete currentLineStyles[numericIndex];
	          }
	        }
	      }
	    }
	  });
	})();
	
	
	(function() {
	  var override = fabric.IText.prototype._getNewSelectionStartFromOffset;
	  /**
	   * Overrides the IText implementation and adjusts character index as there is not always a linebreak
	   *
	   * @param {Number} mouseOffset
	   * @param {Number} prevWidth
	   * @param {Number} width
	   * @param {Number} index
	   * @param {Number} jlen
	   * @returns {Number}
	   */
	  fabric.IText.prototype._getNewSelectionStartFromOffset = function(mouseOffset, prevWidth, width, index, jlen) {
	    index = override.call(this, mouseOffset, prevWidth, width, index, jlen);
	
	    // the index passed into the function is padded by the amount of lines from _textLines (to account for \n)
	    // we need to remove this padding, and pad it by actual lines, and / or spaces that are meant to be there
	    var tmp     = 0,
	        removed = 0;
	
	    // account for removed characters
	    for (var i = 0; i < this._textLines.length; i++) {
	      tmp += this._textLines[i].length;
	
	      if (tmp + removed >= index) {
	        break;
	      }
	
	      if (this.text[tmp + removed] === '\n' || this.text[tmp + removed] === ' ') {
	        removed++;
	      }
	    }
	
	    return index - i + removed;
	  };
	})();
	
	
	(function() {
	
	  if (typeof document !== 'undefined' && typeof window !== 'undefined') {
	    return;
	  }
	
	  var DOMParser = __webpack_require__(173).DOMParser,
	      URL = __webpack_require__(174),
	      HTTP = __webpack_require__(198),
	      HTTPS = __webpack_require__(225),
	
	      Canvas = __webpack_require__(172),
	      Image = __webpack_require__(172).Image;
	
	  /** @private */
	  function request(url, encoding, callback) {
	    var oURL = URL.parse(url);
	
	    // detect if http or https is used
	    if ( !oURL.port ) {
	      oURL.port = ( oURL.protocol.indexOf('https:') === 0 ) ? 443 : 80;
	    }
	
	    // assign request handler based on protocol
	    var reqHandler = (oURL.protocol.indexOf('https:') === 0 ) ? HTTPS : HTTP,
	        req = reqHandler.request({
	          hostname: oURL.hostname,
	          port: oURL.port,
	          path: oURL.path,
	          method: 'GET'
	        }, function(response) {
	          var body = '';
	          if (encoding) {
	            response.setEncoding(encoding);
	          }
	          response.on('end', function () {
	            callback(body);
	          });
	          response.on('data', function (chunk) {
	            if (response.statusCode === 200) {
	              body += chunk;
	            }
	          });
	        });
	
	    req.on('error', function(err) {
	      if (err.errno === process.ECONNREFUSED) {
	        fabric.log('ECONNREFUSED: connection refused to ' + oURL.hostname + ':' + oURL.port);
	      }
	      else {
	        fabric.log(err.message);
	      }
	      callback(null);
	    });
	
	    req.end();
	  }
	
	  /** @private */
	  function requestFs(path, callback) {
	    var fs = __webpack_require__(226);
	    fs.readFile(path, function (err, data) {
	      if (err) {
	        fabric.log(err);
	        throw err;
	      }
	      else {
	        callback(data);
	      }
	    });
	  }
	
	  fabric.util.loadImage = function(url, callback, context) {
	    function createImageAndCallBack(data) {
	      if (data) {
	        img.src = new Buffer(data, 'binary');
	        // preserving original url, which seems to be lost in node-canvas
	        img._src = url;
	        callback && callback.call(context, img);
	      }
	      else {
	        img = null;
	        callback && callback.call(context, null, true);
	      }
	    }
	    var img = new Image();
	    if (url && (url instanceof Buffer || url.indexOf('data') === 0)) {
	      img.src = img._src = url;
	      callback && callback.call(context, img);
	    }
	    else if (url && url.indexOf('http') !== 0) {
	      requestFs(url, createImageAndCallBack);
	    }
	    else if (url) {
	      request(url, 'binary', createImageAndCallBack);
	    }
	    else {
	      callback && callback.call(context, url);
	    }
	  };
	
	  fabric.loadSVGFromURL = function(url, callback, reviver) {
	    url = url.replace(/^\n\s*/, '').replace(/\?.*$/, '').trim();
	    if (url.indexOf('http') !== 0) {
	      requestFs(url, function(body) {
	        fabric.loadSVGFromString(body.toString(), callback, reviver);
	      });
	    }
	    else {
	      request(url, '', function(body) {
	        fabric.loadSVGFromString(body, callback, reviver);
	      });
	    }
	  };
	
	  fabric.loadSVGFromString = function(string, callback, reviver) {
	    var doc = new DOMParser().parseFromString(string);
	    fabric.parseSVGDocument(doc.documentElement, function(results, options) {
	      callback && callback(results, options);
	    }, reviver);
	  };
	
	  fabric.util.getScript = function(url, callback) {
	    request(url, '', function(body) {
	      eval(body);
	      callback && callback();
	    });
	  };
	
	  fabric.Image.fromObject = function(object, callback) {
	    fabric.util.loadImage(object.src, function(img) {
	      var oImg = new fabric.Image(img);
	
	      oImg._initConfig(object);
	      oImg._initFilters(object.filters, function(filters) {
	        oImg.filters = filters || [ ];
	        oImg._initFilters(object.resizeFilters, function(resizeFilters) {
	          oImg.resizeFilters = resizeFilters || [ ];
	          callback && callback(oImg);
	        });
	      });
	    });
	  };
	  /**
	   * Only available when running fabric on node.js
	   * @param {Number} width Canvas width
	   * @param {Number} height Canvas height
	   * @param {Object} [options] Options to pass to FabricCanvas.
	   * @param {Object} [nodeCanvasOptions] Options to pass to NodeCanvas.
	   * @return {Object} wrapped canvas instance
	   */
	  fabric.createCanvasForNode = function(width, height, options, nodeCanvasOptions) {
	    nodeCanvasOptions = nodeCanvasOptions || options;
	
	    var canvasEl = fabric.document.createElement('canvas'),
	        nodeCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions);
	
	    // jsdom doesn't create style on canvas element, so here be temp. workaround
	    canvasEl.style = { };
	
	    canvasEl.width = nodeCanvas.width;
	    canvasEl.height = nodeCanvas.height;
	
	    var FabricCanvas = fabric.Canvas || fabric.StaticCanvas,
	        fabricCanvas = new FabricCanvas(canvasEl, options);
	
	    fabricCanvas.contextContainer = nodeCanvas.getContext('2d');
	    fabricCanvas.nodeCanvas = nodeCanvas;
	    fabricCanvas.Font = Canvas.Font;
	
	    return fabricCanvas;
	  };
	
	  /** @ignore */
	  fabric.StaticCanvas.prototype.createPNGStream = function() {
	    return this.nodeCanvas.createPNGStream();
	  };
	
	  fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
	    return this.nodeCanvas.createJPEGStream(opts);
	  };
	
	  var origSetWidth = fabric.StaticCanvas.prototype.setWidth;
	  fabric.StaticCanvas.prototype.setWidth = function(width, options) {
	    origSetWidth.call(this, width, options);
	    this.nodeCanvas.width = width;
	    return this;
	  };
	  if (fabric.Canvas) {
	    fabric.Canvas.prototype.setWidth = fabric.StaticCanvas.prototype.setWidth;
	  }
	
	  var origSetHeight = fabric.StaticCanvas.prototype.setHeight;
	  fabric.StaticCanvas.prototype.setHeight = function(height, options) {
	    origSetHeight.call(this, height, options);
	    this.nodeCanvas.height = height;
	    return this;
	  };
	  if (fabric.Canvas) {
	    fabric.Canvas.prototype.setHeight = fabric.StaticCanvas.prototype.setHeight;
	  }
	
	})();
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(167).Buffer, __webpack_require__(5)))

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(168)
	var ieee754 = __webpack_require__(169)
	var isArray = __webpack_require__(170)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 168 */
/***/ (function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function getLens (b64) {
	  var len = b64.length
	
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=')
	  if (validLen === -1) validLen = len
	
	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4)
	
	  return [validLen, placeHoldersLen]
	}
	
	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}
	
	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}
	
	function toByteArray (b64) {
	  var tmp
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]
	
	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
	
	  var curByte = 0
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen
	
	  var i
	  for (i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)]
	    arr[curByte++] = (tmp >> 16) & 0xFF
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF)
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    )
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    )
	  }
	
	  return parts.join('')
	}


/***/ }),
/* 169 */
/***/ (function(module, exports) {

	/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ }),
/* 170 */
/***/ (function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ }),
/* 171 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 172 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 173 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	 * Copyright Joyent, Inc. and other Node contributors.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a
	 * copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to permit
	 * persons to whom the Software is furnished to do so, subject to the
	 * following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included
	 * in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	 * USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */
	
	'use strict';
	
	var punycode = __webpack_require__(175);
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	/*
	 * define these here so at least they only have to be
	 * compiled once on the first module load.
	 */
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	  portPattern = /:[0-9]*$/,
	
	  // Special case for a simple path URL
	  simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
	
	  /*
	   * RFC 2396: characters reserved for delimiting URLs.
	   * We actually just auto-escape these.
	   */
	  delims = [
	    '<', '>', '"', '`', ' ', '\r', '\n', '\t'
	  ],
	
	  // RFC 2396: characters not allowed for various reasons.
	  unwise = [
	    '{', '}', '|', '\\', '^', '`'
	  ].concat(delims),
	
	  // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	  autoEscape = ['\''].concat(unwise),
	  /*
	   * Characters that are never ever allowed in a hostname.
	   * Note that any invalid chars are also handled, but these
	   * are the ones that are *expected* to be seen, so we fast-path
	   * them.
	   */
	  nonHostChars = [
	    '%', '/', '?', ';', '#'
	  ].concat(autoEscape),
	  hostEndingChars = [
	    '/', '?', '#'
	  ],
	  hostnameMaxLen = 255,
	  hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	  hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	  // protocols that can allow "unsafe" and "unwise" chars.
	  unsafeProtocol = {
	    javascript: true,
	    'javascript:': true
	  },
	  // protocols that never have a hostname.
	  hostlessProtocol = {
	    javascript: true,
	    'javascript:': true
	  },
	  // protocols that always contain a // bit.
	  slashedProtocol = {
	    http: true,
	    https: true,
	    ftp: true,
	    gopher: true,
	    file: true,
	    'http:': true,
	    'https:': true,
	    'ftp:': true,
	    'gopher:': true,
	    'file:': true
	  },
	  querystring = __webpack_require__(177);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && typeof url === 'object' && url instanceof Url) { return url; }
	
	  var u = new Url();
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
	  if (typeof url !== 'string') {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  /*
	   * Copy chrome, IE, opera backslash-handling behavior.
	   * Back slashes before the query string get converted to forward slashes
	   * See: https://code.google.com/p/chromium/issues/detail?id=25916
	   */
	  var queryIndex = url.indexOf('?'),
	    splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
	    uSplit = url.split(splitter),
	    slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);
	
	  var rest = url;
	
	  /*
	   * trim before proceeding.
	   * This is to support parse stuff like "  http://foo.com  \n"
	   */
	  rest = rest.trim();
	
	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  /*
	   * figure out if it's got a host
	   * user@server is *always* interpreted as a hostname, and url
	   * resolution will treat //foo/bar as host=foo,path=bar because that's
	   * how the browser resolves relative URLs.
	   */
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
	
	    /*
	     * there's a hostname.
	     * the first instance of /, ?, ;, or # ends the host.
	     *
	     * If there is an @ in the hostname, then non-host chars *are* allowed
	     * to the left of the last @ sign, unless some host-ending character
	     * comes *before* the @-sign.
	     * URLs are obnoxious.
	     *
	     * ex:
	     * http://a@b@c/ => user:a@b host:c
	     * http://a@b?@c => user:a host:c path:/?@c
	     */
	
	    /*
	     * v0.12 TODO(isaacs): This is not quite how Chrome does things.
	     * Review our test case against browsers more comprehensively.
	     */
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
	    }
	
	    /*
	     * at this point, either we have an explicit point where the
	     * auth portion cannot go past, or the last @ char is the decider.
	     */
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      /*
	       * atSign must be in auth portion.
	       * http://a@b/c@d => host:b auth:a path:/c@d
	       */
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    /*
	     * Now we have a portion which is definitely the auth.
	     * Pull that off.
	     */
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) { hostEnd = hec; }
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1) { hostEnd = rest.length; }
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    /*
	     * we've indicated that there is a hostname,
	     * so even if it's empty, it has to be present.
	     */
	    this.hostname = this.hostname || '';
	
	    /*
	     * if hostname begins with [ and ends with ]
	     * assume that it's an IPv6 address.
	     */
	    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) { continue; }
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              /*
	               * we replace non-ASCII char with a temporary placeholder
	               * we need this to make sure size of hostname is not
	               * broken by replacing non-ASCII by nothing
	               */
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      /*
	       * IDNA Support: Returns a punycoded representation of "domain".
	       * It only converts parts of the domain name that
	       * have non-ASCII characters, i.e. it doesn't matter if
	       * you call it with a domain that already is ASCII-only.
	       */
	      this.hostname = punycode.toASCII(this.hostname);
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    /*
	     * strip [ and ] from the hostname
	     * the host field still retains them, though
	     */
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  /*
	   * now rest is set to the post-host stuff.
	   * chop off any delim chars.
	   */
	  if (!unsafeProtocol[lowerProto]) {
	
	    /*
	     * First, make 100% sure that any "autoEscape" chars get
	     * escaped, even if encodeURIComponent doesn't think they
	     * need to be.
	     */
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1) { continue; }
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) { this.pathname = rest; }
	  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  // to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  /*
	   * ensure it's an object, and not a string url.
	   * If it's an obj, this is a no-op.
	   * this way, you can call url_format() on strings
	   * to clean up potentially wonky urls.
	   */
	  if (typeof obj === 'string') { obj = urlParse(obj); }
	  if (!(obj instanceof Url)) { return Url.prototype.format.call(obj); }
	  return obj.format();
	}
	
	Url.prototype.format = function () {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	    pathname = this.pathname || '',
	    hash = this.hash || '',
	    host = false,
	    query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query && typeof this.query === 'object' && Object.keys(this.query).length) {
	    query = querystring.stringify(this.query, {
	      arrayFormat: 'repeat',
	      addQueryPrefix: false
	    });
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') { protocol += ':'; }
	
	  /*
	   * only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	   * unless they had them to begin with.
	   */
	  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') { pathname = '/' + pathname; }
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') { hash = '#' + hash; }
	  if (search && search.charAt(0) !== '?') { search = '?' + search; }
	
	  pathname = pathname.replace(/[?#]/g, function (match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function (relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) { return relative; }
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function (relative) {
	  if (typeof relative === 'string') {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }
	
	  /*
	   * hash is always overridden, no matter what.
	   * even href="" will remove it.
	   */
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol') { result[rkey] = relative[rkey]; }
	    }
	
	    // urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
	      result.pathname = '/';
	      result.path = result.pathname;
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    /*
	     * if it's a known url protocol, then changing
	     * the protocol does weird things
	     * first, if it's not file:, then we MUST have a host,
	     * and if there was a path
	     * to begin with, then we MUST have a path.
	     * if it is file:, then the host is dropped,
	     * because that's known to be hostless.
	     * anything else is assumed to be absolute.
	     */
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift())) { }
	      if (!relative.host) { relative.host = ''; }
	      if (!relative.hostname) { relative.hostname = ''; }
	      if (relPath[0] !== '') { relPath.unshift(''); }
	      if (relPath.length < 2) { relPath.unshift(''); }
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
	    isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
	    mustEndAbs = isRelAbs || isSourceAbs || (result.host && relative.pathname),
	    removeAllDots = mustEndAbs,
	    srcPath = result.pathname && result.pathname.split('/') || [],
	    relPath = relative.pathname && relative.pathname.split('/') || [],
	    psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  /*
	   * if the url is a non-slashed url, then relative
	   * links like ../.. should be able
	   * to crawl up to the hostname, as well.  This is strange.
	   * result.protocol has already been set by now.
	   * Later on, put the first path part into the host field.
	   */
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') { srcPath[0] = result.host; } else { srcPath.unshift(result.host); }
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') { relPath[0] = relative.host; } else { relPath.unshift(relative.host); }
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = relative.host || relative.host === '' ? relative.host : result.host;
	    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    /*
	     * it's relative
	     * throw away the existing file, and take the new path instead.
	     */
	    if (!srcPath) { srcPath = []; }
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (relative.search != null) {
	    /*
	     * just pull out the search.
	     * like href='?foo'.
	     * Put this after the other two cases because it simplifies the booleans
	     */
	    if (psychotic) {
	      result.host = srcPath.shift();
	      result.hostname = result.host;
	      /*
	       * occationaly the auth can get stuck only in host
	       * this especially happens in cases like
	       * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	       */
	      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.hostname = authInHost.shift();
	        result.host = result.hostname;
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    // to support http.request
	    if (result.pathname !== null || result.search !== null) {
	      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    /*
	     * no path at all.  easy.
	     * we've already handled the other stuff above.
	     */
	    result.pathname = null;
	    // to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  /*
	   * if a url ENDs in . or .., then it must get a trailing slash.
	   * however, if it ends in anything else non-slashy,
	   * then it must NOT get a trailing slash.
	   */
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';
	
	  /*
	   * strip single dots, resolve double dots to parent dir
	   * if the path tries to go above the root, `up` ends up > 0
	   */
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
	    result.host = result.hostname;
	    /*
	     * occationaly the auth can get stuck only in host
	     * this especially happens in cases like
	     * url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	     */
	    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.hostname = authInHost.shift();
	      result.host = result.hostname;
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (srcPath.length > 0) {
	    result.pathname = srcPath.join('/');
	  } else {
	    result.pathname = null;
	    result.path = null;
	  }
	
	  // to support request.http
	  if (result.pathname !== null || result.search !== null) {
	    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function () {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) { this.hostname = host; }
	};
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.4.1 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw new RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * https://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.4.1',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) {
				// in Node.js, io.js, or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else {
				// in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else {
			// in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(176)(module), (function() { return this; }())))

/***/ }),
/* 176 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var stringify = __webpack_require__(178);
	var parse = __webpack_require__(197);
	var formats = __webpack_require__(196);
	
	module.exports = {
	    formats: formats,
	    parse: parse,
	    stringify: stringify
	};


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var getSideChannel = __webpack_require__(179);
	var utils = __webpack_require__(195);
	var formats = __webpack_require__(196);
	var has = Object.prototype.hasOwnProperty;
	
	var arrayPrefixGenerators = {
	    brackets: function brackets(prefix) {
	        return prefix + '[]';
	    },
	    comma: 'comma',
	    indices: function indices(prefix, key) {
	        return prefix + '[' + key + ']';
	    },
	    repeat: function repeat(prefix) {
	        return prefix;
	    }
	};
	
	var isArray = Array.isArray;
	var push = Array.prototype.push;
	var pushToArray = function (arr, valueOrArray) {
	    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
	};
	
	var toISO = Date.prototype.toISOString;
	
	var defaultFormat = formats['default'];
	var defaults = {
	    addQueryPrefix: false,
	    allowDots: false,
	    charset: 'utf-8',
	    charsetSentinel: false,
	    delimiter: '&',
	    encode: true,
	    encoder: utils.encode,
	    encodeValuesOnly: false,
	    format: defaultFormat,
	    formatter: formats.formatters[defaultFormat],
	    // deprecated
	    indices: false,
	    serializeDate: function serializeDate(date) {
	        return toISO.call(date);
	    },
	    skipNulls: false,
	    strictNullHandling: false
	};
	
	var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
	    return typeof v === 'string'
	        || typeof v === 'number'
	        || typeof v === 'boolean'
	        || typeof v === 'symbol'
	        || typeof v === 'bigint';
	};
	
	var sentinel = {};
	
	var stringify = function stringify(
	    object,
	    prefix,
	    generateArrayPrefix,
	    commaRoundTrip,
	    strictNullHandling,
	    skipNulls,
	    encoder,
	    filter,
	    sort,
	    allowDots,
	    serializeDate,
	    format,
	    formatter,
	    encodeValuesOnly,
	    charset,
	    sideChannel
	) {
	    var obj = object;
	
	    var tmpSc = sideChannel;
	    var step = 0;
	    var findFlag = false;
	    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
	        // Where object last appeared in the ref tree
	        var pos = tmpSc.get(object);
	        step += 1;
	        if (typeof pos !== 'undefined') {
	            if (pos === step) {
	                throw new RangeError('Cyclic object value');
	            } else {
	                findFlag = true; // Break while
	            }
	        }
	        if (typeof tmpSc.get(sentinel) === 'undefined') {
	            step = 0;
	        }
	    }
	
	    if (typeof filter === 'function') {
	        obj = filter(prefix, obj);
	    } else if (obj instanceof Date) {
	        obj = serializeDate(obj);
	    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
	        obj = utils.maybeMap(obj, function (value) {
	            if (value instanceof Date) {
	                return serializeDate(value);
	            }
	            return value;
	        });
	    }
	
	    if (obj === null) {
	        if (strictNullHandling) {
	            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;
	        }
	
	        obj = '';
	    }
	
	    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
	        if (encoder) {
	            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);
	            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];
	        }
	        return [formatter(prefix) + '=' + formatter(String(obj))];
	    }
	
	    var values = [];
	
	    if (typeof obj === 'undefined') {
	        return values;
	    }
	
	    var objKeys;
	    if (generateArrayPrefix === 'comma' && isArray(obj)) {
	        // we need to join elements in
	        if (encodeValuesOnly && encoder) {
	            obj = utils.maybeMap(obj, encoder);
	        }
	        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];
	    } else if (isArray(filter)) {
	        objKeys = filter;
	    } else {
	        var keys = Object.keys(obj);
	        objKeys = sort ? keys.sort(sort) : keys;
	    }
	
	    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;
	
	    for (var j = 0; j < objKeys.length; ++j) {
	        var key = objKeys[j];
	        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];
	
	        if (skipNulls && value === null) {
	            continue;
	        }
	
	        var keyPrefix = isArray(obj)
	            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix
	            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');
	
	        sideChannel.set(object, step);
	        var valueSideChannel = getSideChannel();
	        valueSideChannel.set(sentinel, sideChannel);
	        pushToArray(values, stringify(
	            value,
	            keyPrefix,
	            generateArrayPrefix,
	            commaRoundTrip,
	            strictNullHandling,
	            skipNulls,
	            generateArrayPrefix === 'comma' && encodeValuesOnly && isArray(obj) ? null : encoder,
	            filter,
	            sort,
	            allowDots,
	            serializeDate,
	            format,
	            formatter,
	            encodeValuesOnly,
	            charset,
	            valueSideChannel
	        ));
	    }
	
	    return values;
	};
	
	var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
	    if (!opts) {
	        return defaults;
	    }
	
	    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
	        throw new TypeError('Encoder has to be a function.');
	    }
	
	    var charset = opts.charset || defaults.charset;
	    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
	        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
	    }
	
	    var format = formats['default'];
	    if (typeof opts.format !== 'undefined') {
	        if (!has.call(formats.formatters, opts.format)) {
	            throw new TypeError('Unknown format option provided.');
	        }
	        format = opts.format;
	    }
	    var formatter = formats.formatters[format];
	
	    var filter = defaults.filter;
	    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
	        filter = opts.filter;
	    }
	
	    return {
	        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
	        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
	        charset: charset,
	        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
	        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
	        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
	        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
	        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
	        filter: filter,
	        format: format,
	        formatter: formatter,
	        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
	        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
	        sort: typeof opts.sort === 'function' ? opts.sort : null,
	        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
	    };
	};
	
	module.exports = function (object, opts) {
	    var obj = object;
	    var options = normalizeStringifyOptions(opts);
	
	    var objKeys;
	    var filter;
	
	    if (typeof options.filter === 'function') {
	        filter = options.filter;
	        obj = filter('', obj);
	    } else if (isArray(options.filter)) {
	        filter = options.filter;
	        objKeys = filter;
	    }
	
	    var keys = [];
	
	    if (typeof obj !== 'object' || obj === null) {
	        return '';
	    }
	
	    var arrayFormat;
	    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
	        arrayFormat = opts.arrayFormat;
	    } else if (opts && 'indices' in opts) {
	        arrayFormat = opts.indices ? 'indices' : 'repeat';
	    } else {
	        arrayFormat = 'indices';
	    }
	
	    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
	    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
	        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
	    }
	    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;
	
	    if (!objKeys) {
	        objKeys = Object.keys(obj);
	    }
	
	    if (options.sort) {
	        objKeys.sort(options.sort);
	    }
	
	    var sideChannel = getSideChannel();
	    for (var i = 0; i < objKeys.length; ++i) {
	        var key = objKeys[i];
	
	        if (options.skipNulls && obj[key] === null) {
	            continue;
	        }
	        pushToArray(keys, stringify(
	            obj[key],
	            key,
	            generateArrayPrefix,
	            commaRoundTrip,
	            options.strictNullHandling,
	            options.skipNulls,
	            options.encode ? options.encoder : null,
	            options.filter,
	            options.sort,
	            options.allowDots,
	            options.serializeDate,
	            options.format,
	            options.formatter,
	            options.encodeValuesOnly,
	            options.charset,
	            sideChannel
	        ));
	    }
	
	    var joined = keys.join(options.delimiter);
	    var prefix = options.addQueryPrefix === true ? '?' : '';
	
	    if (options.charsetSentinel) {
	        if (options.charset === 'iso-8859-1') {
	            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
	            prefix += 'utf8=%26%2310003%3B&';
	        } else {
	            // encodeURIComponent('')
	            prefix += 'utf8=%E2%9C%93&';
	        }
	    }
	
	    return joined.length > 0 ? prefix + joined : '';
	};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var GetIntrinsic = __webpack_require__(180);
	var callBound = __webpack_require__(187);
	var inspect = __webpack_require__(193);
	
	var $TypeError = GetIntrinsic('%TypeError%');
	var $WeakMap = GetIntrinsic('%WeakMap%', true);
	var $Map = GetIntrinsic('%Map%', true);
	
	var $weakMapGet = callBound('WeakMap.prototype.get', true);
	var $weakMapSet = callBound('WeakMap.prototype.set', true);
	var $weakMapHas = callBound('WeakMap.prototype.has', true);
	var $mapGet = callBound('Map.prototype.get', true);
	var $mapSet = callBound('Map.prototype.set', true);
	var $mapHas = callBound('Map.prototype.has', true);
	
	/*
	 * This function traverses the list returning the node corresponding to the
	 * given key.
	 *
	 * That node is also moved to the head of the list, so that if it's accessed
	 * again we don't need to traverse the whole list. By doing so, all the recently
	 * used nodes can be accessed relatively quickly.
	 */
	var listGetNode = function (list, key) { // eslint-disable-line consistent-return
		for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
			if (curr.key === key) {
				prev.next = curr.next;
				curr.next = list.next;
				list.next = curr; // eslint-disable-line no-param-reassign
				return curr;
			}
		}
	};
	
	var listGet = function (objects, key) {
		var node = listGetNode(objects, key);
		return node && node.value;
	};
	var listSet = function (objects, key, value) {
		var node = listGetNode(objects, key);
		if (node) {
			node.value = value;
		} else {
			// Prepend the new node to the beginning of the list
			objects.next = { // eslint-disable-line no-param-reassign
				key: key,
				next: objects.next,
				value: value
			};
		}
	};
	var listHas = function (objects, key) {
		return !!listGetNode(objects, key);
	};
	
	module.exports = function getSideChannel() {
		var $wm;
		var $m;
		var $o;
		var channel = {
			assert: function (key) {
				if (!channel.has(key)) {
					throw new $TypeError('Side channel does not contain ' + inspect(key));
				}
			},
			get: function (key) { // eslint-disable-line consistent-return
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapGet($wm, key);
					}
				} else if ($Map) {
					if ($m) {
						return $mapGet($m, key);
					}
				} else {
					if ($o) { // eslint-disable-line no-lonely-if
						return listGet($o, key);
					}
				}
			},
			has: function (key) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if ($wm) {
						return $weakMapHas($wm, key);
					}
				} else if ($Map) {
					if ($m) {
						return $mapHas($m, key);
					}
				} else {
					if ($o) { // eslint-disable-line no-lonely-if
						return listHas($o, key);
					}
				}
				return false;
			},
			set: function (key, value) {
				if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
					if (!$wm) {
						$wm = new $WeakMap();
					}
					$weakMapSet($wm, key, value);
				} else if ($Map) {
					if (!$m) {
						$m = new $Map();
					}
					$mapSet($m, key, value);
				} else {
					if (!$o) {
						/*
						 * Initialize the linked list as an empty node, so that we don't have
						 * to special-case handling of the first node: we can always refer to
						 * it as (previous node).next, instead of something like (list).head
						 */
						$o = { key: {}, next: null };
					}
					listSet($o, key, value);
				}
			}
		};
		return channel;
	};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var undefined;
	
	var $SyntaxError = SyntaxError;
	var $Function = Function;
	var $TypeError = TypeError;
	
	// eslint-disable-next-line consistent-return
	var getEvalledConstructor = function (expressionSyntax) {
		try {
			return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
		} catch (e) {}
	};
	
	var $gOPD = Object.getOwnPropertyDescriptor;
	if ($gOPD) {
		try {
			$gOPD({}, '');
		} catch (e) {
			$gOPD = null; // this is IE 8, which has a broken gOPD
		}
	}
	
	var throwTypeError = function () {
		throw new $TypeError();
	};
	var ThrowTypeError = $gOPD
		? (function () {
			try {
				// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
				arguments.callee; // IE 8 does not throw here
				return throwTypeError;
			} catch (calleeThrows) {
				try {
					// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
					return $gOPD(arguments, 'callee').get;
				} catch (gOPDthrows) {
					return throwTypeError;
				}
			}
		}())
		: throwTypeError;
	
	var hasSymbols = __webpack_require__(181)();
	var hasProto = __webpack_require__(183)();
	
	var getProto = Object.getPrototypeOf || (
		hasProto
			? function (x) { return x.__proto__; } // eslint-disable-line no-proto
			: null
	);
	
	var needsEval = {};
	
	var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
	
	var INTRINSICS = {
		'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
		'%Array%': Array,
		'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
		'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
		'%AsyncFromSyncIteratorPrototype%': undefined,
		'%AsyncFunction%': needsEval,
		'%AsyncGenerator%': needsEval,
		'%AsyncGeneratorFunction%': needsEval,
		'%AsyncIteratorPrototype%': needsEval,
		'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
		'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
		'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
		'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
		'%Boolean%': Boolean,
		'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
		'%Date%': Date,
		'%decodeURI%': decodeURI,
		'%decodeURIComponent%': decodeURIComponent,
		'%encodeURI%': encodeURI,
		'%encodeURIComponent%': encodeURIComponent,
		'%Error%': Error,
		'%eval%': eval, // eslint-disable-line no-eval
		'%EvalError%': EvalError,
		'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
		'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
		'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
		'%Function%': $Function,
		'%GeneratorFunction%': needsEval,
		'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
		'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
		'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
		'%isFinite%': isFinite,
		'%isNaN%': isNaN,
		'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
		'%JSON%': typeof JSON === 'object' ? JSON : undefined,
		'%Map%': typeof Map === 'undefined' ? undefined : Map,
		'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
		'%Math%': Math,
		'%Number%': Number,
		'%Object%': Object,
		'%parseFloat%': parseFloat,
		'%parseInt%': parseInt,
		'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
		'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
		'%RangeError%': RangeError,
		'%ReferenceError%': ReferenceError,
		'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
		'%RegExp%': RegExp,
		'%Set%': typeof Set === 'undefined' ? undefined : Set,
		'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
		'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
		'%String%': String,
		'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
		'%Symbol%': hasSymbols ? Symbol : undefined,
		'%SyntaxError%': $SyntaxError,
		'%ThrowTypeError%': ThrowTypeError,
		'%TypedArray%': TypedArray,
		'%TypeError%': $TypeError,
		'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
		'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
		'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
		'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
		'%URIError%': URIError,
		'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
		'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
		'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
	};
	
	if (getProto) {
		try {
			null.error; // eslint-disable-line no-unused-expressions
		} catch (e) {
			// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
			var errorProto = getProto(getProto(e));
			INTRINSICS['%Error.prototype%'] = errorProto;
		}
	}
	
	var doEval = function doEval(name) {
		var value;
		if (name === '%AsyncFunction%') {
			value = getEvalledConstructor('async function () {}');
		} else if (name === '%GeneratorFunction%') {
			value = getEvalledConstructor('function* () {}');
		} else if (name === '%AsyncGeneratorFunction%') {
			value = getEvalledConstructor('async function* () {}');
		} else if (name === '%AsyncGenerator%') {
			var fn = doEval('%AsyncGeneratorFunction%');
			if (fn) {
				value = fn.prototype;
			}
		} else if (name === '%AsyncIteratorPrototype%') {
			var gen = doEval('%AsyncGenerator%');
			if (gen && getProto) {
				value = getProto(gen.prototype);
			}
		}
	
		INTRINSICS[name] = value;
	
		return value;
	};
	
	var LEGACY_ALIASES = {
		'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
		'%ArrayPrototype%': ['Array', 'prototype'],
		'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
		'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
		'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
		'%ArrayProto_values%': ['Array', 'prototype', 'values'],
		'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
		'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
		'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
		'%BooleanPrototype%': ['Boolean', 'prototype'],
		'%DataViewPrototype%': ['DataView', 'prototype'],
		'%DatePrototype%': ['Date', 'prototype'],
		'%ErrorPrototype%': ['Error', 'prototype'],
		'%EvalErrorPrototype%': ['EvalError', 'prototype'],
		'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
		'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
		'%FunctionPrototype%': ['Function', 'prototype'],
		'%Generator%': ['GeneratorFunction', 'prototype'],
		'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
		'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
		'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
		'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
		'%JSONParse%': ['JSON', 'parse'],
		'%JSONStringify%': ['JSON', 'stringify'],
		'%MapPrototype%': ['Map', 'prototype'],
		'%NumberPrototype%': ['Number', 'prototype'],
		'%ObjectPrototype%': ['Object', 'prototype'],
		'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
		'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
		'%PromisePrototype%': ['Promise', 'prototype'],
		'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
		'%Promise_all%': ['Promise', 'all'],
		'%Promise_reject%': ['Promise', 'reject'],
		'%Promise_resolve%': ['Promise', 'resolve'],
		'%RangeErrorPrototype%': ['RangeError', 'prototype'],
		'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
		'%RegExpPrototype%': ['RegExp', 'prototype'],
		'%SetPrototype%': ['Set', 'prototype'],
		'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
		'%StringPrototype%': ['String', 'prototype'],
		'%SymbolPrototype%': ['Symbol', 'prototype'],
		'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
		'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
		'%TypeErrorPrototype%': ['TypeError', 'prototype'],
		'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
		'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
		'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
		'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
		'%URIErrorPrototype%': ['URIError', 'prototype'],
		'%WeakMapPrototype%': ['WeakMap', 'prototype'],
		'%WeakSetPrototype%': ['WeakSet', 'prototype']
	};
	
	var bind = __webpack_require__(184);
	var hasOwn = __webpack_require__(186);
	var $concat = bind.call(Function.call, Array.prototype.concat);
	var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
	var $replace = bind.call(Function.call, String.prototype.replace);
	var $strSlice = bind.call(Function.call, String.prototype.slice);
	var $exec = bind.call(Function.call, RegExp.prototype.exec);
	
	/* adapted from https://github.com/lodash/lodash/blob/4.17.15/public/lodash.js#L6735-L6744 */
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
	var stringToPath = function stringToPath(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === '%' && last !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
		} else if (last === '%' && first !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
		}
		var result = [];
		$replace(string, rePropName, function (match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
		});
		return result;
	};
	/* end adaptation */
	
	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = '%' + alias[0] + '%';
		}
	
		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) {
				value = doEval(intrinsicName);
			}
			if (typeof value === 'undefined' && !allowMissing) {
				throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
			}
	
			return {
				alias: alias,
				name: intrinsicName,
				value: value
			};
		}
	
		throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
	};
	
	module.exports = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== 'string' || name.length === 0) {
			throw new $TypeError('intrinsic name must be a non-empty string');
		}
		if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
			throw new $TypeError('"allowMissing" argument must be a boolean');
		}
	
		if ($exec(/^%?[^%]*%?$/, name) === null) {
			throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
		}
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
	
		var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;
	
		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}
	
		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if (
				(
					(first === '"' || first === "'" || first === '`')
					|| (last === '"' || last === "'" || last === '`')
				)
				&& first !== last
			) {
				throw new $SyntaxError('property names with quotes must have matching quotes');
			}
			if (part === 'constructor' || !isOwn) {
				skipFurtherCaching = true;
			}
	
			intrinsicBaseName += '.' + part;
			intrinsicRealName = '%' + intrinsicBaseName + '%';
	
			if (hasOwn(INTRINSICS, intrinsicRealName)) {
				value = INTRINSICS[intrinsicRealName];
			} else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) {
						throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
					}
					return void undefined;
				}
				if ($gOPD && (i + 1) >= parts.length) {
					var desc = $gOPD(value, part);
					isOwn = !!desc;
	
					// By convention, when a data property is converted to an accessor
					// property to emulate a data property that does not suffer from
					// the override mistake, that accessor's getter is marked with
					// an `originalValue` property. Here, when we detect this, we
					// uphold the illusion by pretending to see that original data
					// property, i.e., returning the value rather than the getter
					// itself.
					if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
						value = desc.get;
					} else {
						value = value[part];
					}
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}
	
				if (isOwn && !skipFurtherCaching) {
					INTRINSICS[intrinsicRealName] = value;
				}
			}
		}
		return value;
	};


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var origSymbol = typeof Symbol !== 'undefined' && Symbol;
	var hasSymbolSham = __webpack_require__(182);
	
	module.exports = function hasNativeSymbols() {
		if (typeof origSymbol !== 'function') { return false; }
		if (typeof Symbol !== 'function') { return false; }
		if (typeof origSymbol('foo') !== 'symbol') { return false; }
		if (typeof Symbol('bar') !== 'symbol') { return false; }
	
		return hasSymbolSham();
	};


/***/ }),
/* 182 */
/***/ (function(module, exports) {

	'use strict';
	
	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	module.exports = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }
	
		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }
	
		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }
	
		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }
	
		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
	
		var symVal = 42;
		obj[sym] = symVal;
		for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }
	
		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }
	
		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }
	
		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }
	
		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}
	
		return true;
	};


/***/ }),
/* 183 */
/***/ (function(module, exports) {

	'use strict';
	
	var test = {
		foo: {}
	};
	
	var $Object = Object;
	
	module.exports = function hasProto() {
		return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
	};


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var implementation = __webpack_require__(185);
	
	module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 185 */
/***/ (function(module, exports) {

	'use strict';
	
	/* eslint no-invalid-this: 1 */
	
	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = '[object Function]';
	
	var concatty = function concatty(a, b) {
	    var arr = [];
	
	    for (var i = 0; i < a.length; i += 1) {
	        arr[i] = a[i];
	    }
	    for (var j = 0; j < b.length; j += 1) {
	        arr[j + a.length] = b[j];
	    }
	
	    return arr;
	};
	
	var slicy = function slicy(arrLike, offset) {
	    var arr = [];
	    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
	        arr[j] = arrLike[i];
	    }
	    return arr;
	};
	
	var joiny = function (arr, joiner) {
	    var str = '';
	    for (var i = 0; i < arr.length; i += 1) {
	        str += arr[i];
	        if (i + 1 < arr.length) {
	            str += joiner;
	        }
	    }
	    return str;
	};
	
	module.exports = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slicy(arguments, 1);
	
	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                concatty(args, arguments)
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        }
	        return target.apply(
	            that,
	            concatty(args, arguments)
	        );
	
	    };
	
	    var boundLength = max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs[i] = '$' + i;
	    }
	
	    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
	
	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }
	
	    return bound;
	};


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind = __webpack_require__(184);
	
	/** @type {(o: {}, p: PropertyKey) => p is keyof o} */
	module.exports = bind.call(call, $hasOwn);


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var GetIntrinsic = __webpack_require__(180);
	
	var callBind = __webpack_require__(188);
	
	var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
	
	module.exports = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic(name, !!allowMissing);
		if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
			return callBind(intrinsic);
		}
		return intrinsic;
	};


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var bind = __webpack_require__(184);
	var GetIntrinsic = __webpack_require__(180);
	var setFunctionLength = __webpack_require__(189);
	
	var $TypeError = GetIntrinsic('%TypeError%');
	var $apply = GetIntrinsic('%Function.prototype.apply%');
	var $call = GetIntrinsic('%Function.prototype.call%');
	var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
	
	var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
	var $max = GetIntrinsic('%Math.max%');
	
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
		} catch (e) {
			// IE 8 has a broken defineProperty
			$defineProperty = null;
		}
	}
	
	module.exports = function callBind(originalFunction) {
		if (typeof originalFunction !== 'function') {
			throw new $TypeError('a function is required');
		}
		var func = $reflectApply(bind, $call, arguments);
		return setFunctionLength(
			func,
			1 + $max(0, originalFunction.length - (arguments.length - 1)),
			true
		);
	};
	
	var applyBind = function applyBind() {
		return $reflectApply(bind, $apply, arguments);
	};
	
	if ($defineProperty) {
		$defineProperty(module.exports, 'apply', { value: applyBind });
	} else {
		module.exports.apply = applyBind;
	}


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var GetIntrinsic = __webpack_require__(180);
	var define = __webpack_require__(190);
	var hasDescriptors = __webpack_require__(191)();
	var gOPD = __webpack_require__(192);
	
	var $TypeError = GetIntrinsic('%TypeError%');
	var $floor = GetIntrinsic('%Math.floor%');
	
	/** @typedef {(...args: unknown[]) => unknown} Func */
	
	/** @type {<T extends Func = Func>(fn: T, length: number, loose?: boolean) => T} */
	module.exports = function setFunctionLength(fn, length) {
		if (typeof fn !== 'function') {
			throw new $TypeError('`fn` is not a function');
		}
		if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
			throw new $TypeError('`length` must be a positive 32-bit integer');
		}
	
		var loose = arguments.length > 2 && !!arguments[2];
	
		var functionLengthIsConfigurable = true;
		var functionLengthIsWritable = true;
		if ('length' in fn && gOPD) {
			var desc = gOPD(fn, 'length');
			if (desc && !desc.configurable) {
				functionLengthIsConfigurable = false;
			}
			if (desc && !desc.writable) {
				functionLengthIsWritable = false;
			}
		}
	
		if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
			if (hasDescriptors) {
				define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
			} else {
				define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
			}
		}
		return fn;
	};


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var hasPropertyDescriptors = __webpack_require__(191)();
	
	var GetIntrinsic = __webpack_require__(180);
	
	var $defineProperty = hasPropertyDescriptors && GetIntrinsic('%Object.defineProperty%', true);
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
		} catch (e) {
			// IE 8 has a broken defineProperty
			$defineProperty = false;
		}
	}
	
	var $SyntaxError = GetIntrinsic('%SyntaxError%');
	var $TypeError = GetIntrinsic('%TypeError%');
	
	var gopd = __webpack_require__(192);
	
	/** @type {(obj: Record<PropertyKey, unknown>, property: PropertyKey, value: unknown, nonEnumerable?: boolean | null, nonWritable?: boolean | null, nonConfigurable?: boolean | null, loose?: boolean) => void} */
	module.exports = function defineDataProperty(
		obj,
		property,
		value
	) {
		if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
			throw new $TypeError('`obj` must be an object or a function`');
		}
		if (typeof property !== 'string' && typeof property !== 'symbol') {
			throw new $TypeError('`property` must be a string or a symbol`');
		}
		if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
			throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
			throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
			throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
			throw new $TypeError('`loose`, if provided, must be a boolean');
		}
	
		var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
		var nonWritable = arguments.length > 4 ? arguments[4] : null;
		var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
		var loose = arguments.length > 6 ? arguments[6] : false;
	
		/* @type {false | TypedPropertyDescriptor<unknown>} */
		var desc = !!gopd && gopd(obj, property);
	
		if ($defineProperty) {
			$defineProperty(obj, property, {
				configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
				enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
				value: value,
				writable: nonWritable === null && desc ? desc.writable : !nonWritable
			});
		} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
			// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
			obj[property] = value; // eslint-disable-line no-param-reassign
		} else {
			throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
		}
	};


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var GetIntrinsic = __webpack_require__(180);
	
	var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
	
	var hasPropertyDescriptors = function hasPropertyDescriptors() {
		if ($defineProperty) {
			try {
				$defineProperty({}, 'a', { value: 1 });
				return true;
			} catch (e) {
				// IE 8 has a broken defineProperty
				return false;
			}
		}
		return false;
	};
	
	hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
		// node v0.6 has a bug where array lengths can be Set but not Defined
		if (!hasPropertyDescriptors()) {
			return null;
		}
		try {
			return $defineProperty([], 'length', { value: 1 }).length !== 1;
		} catch (e) {
			// In Firefox 4-22, defining length on an array throws an exception.
			return true;
		}
	};
	
	module.exports = hasPropertyDescriptors;


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var GetIntrinsic = __webpack_require__(180);
	
	var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
	
	if ($gOPD) {
		try {
			$gOPD([], 'length');
		} catch (e) {
			// IE 8 has a broken gOPD
			$gOPD = null;
		}
	}
	
	module.exports = $gOPD;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var hasMap = typeof Map === 'function' && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === 'function' && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
	var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
	var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
	var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
	var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
	var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
	var booleanValueOf = Boolean.prototype.valueOf;
	var objectToString = Object.prototype.toString;
	var functionToString = Function.prototype.toString;
	var $match = String.prototype.match;
	var $slice = String.prototype.slice;
	var $replace = String.prototype.replace;
	var $toUpperCase = String.prototype.toUpperCase;
	var $toLowerCase = String.prototype.toLowerCase;
	var $test = RegExp.prototype.test;
	var $concat = Array.prototype.concat;
	var $join = Array.prototype.join;
	var $arrSlice = Array.prototype.slice;
	var $floor = Math.floor;
	var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
	var gOPS = Object.getOwnPropertySymbols;
	var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
	var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
	// ie, `has-tostringtag/shams
	var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')
	    ? Symbol.toStringTag
	    : null;
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	
	var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (
	    [].__proto__ === Array.prototype // eslint-disable-line no-proto
	        ? function (O) {
	            return O.__proto__; // eslint-disable-line no-proto
	        }
	        : null
	);
	
	function addNumericSeparator(num, str) {
	    if (
	        num === Infinity
	        || num === -Infinity
	        || num !== num
	        || (num && num > -1000 && num < 1000)
	        || $test.call(/e/, str)
	    ) {
	        return str;
	    }
	    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
	    if (typeof num === 'number') {
	        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
	        if (int !== num) {
	            var intStr = String(int);
	            var dec = $slice.call(str, intStr.length + 1);
	            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
	        }
	    }
	    return $replace.call(str, sepRegex, '$&_');
	}
	
	var utilInspect = __webpack_require__(194);
	var inspectCustom = utilInspect.custom;
	var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
	
	module.exports = function inspect_(obj, options, depth, seen) {
	    var opts = options || {};
	
	    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
	        throw new TypeError('option "quoteStyle" must be "single" or "double"');
	    }
	    if (
	        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'
	            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity
	            : opts.maxStringLength !== null
	        )
	    ) {
	        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
	    }
	    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;
	    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
	        throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
	    }
	
	    if (
	        has(opts, 'indent')
	        && opts.indent !== null
	        && opts.indent !== '\t'
	        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)
	    ) {
	        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
	    }
	    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
	        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
	    }
	    var numericSeparator = opts.numericSeparator;
	
	    if (typeof obj === 'undefined') {
	        return 'undefined';
	    }
	    if (obj === null) {
	        return 'null';
	    }
	    if (typeof obj === 'boolean') {
	        return obj ? 'true' : 'false';
	    }
	
	    if (typeof obj === 'string') {
	        return inspectString(obj, opts);
	    }
	    if (typeof obj === 'number') {
	        if (obj === 0) {
	            return Infinity / obj > 0 ? '0' : '-0';
	        }
	        var str = String(obj);
	        return numericSeparator ? addNumericSeparator(obj, str) : str;
	    }
	    if (typeof obj === 'bigint') {
	        var bigIntStr = String(obj) + 'n';
	        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
	    }
	
	    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
	    if (typeof depth === 'undefined') { depth = 0; }
	    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
	        return isArray(obj) ? '[Array]' : '[Object]';
	    }
	
	    var indent = getIndent(opts, depth);
	
	    if (typeof seen === 'undefined') {
	        seen = [];
	    } else if (indexOf(seen, obj) >= 0) {
	        return '[Circular]';
	    }
	
	    function inspect(value, from, noIndent) {
	        if (from) {
	            seen = $arrSlice.call(seen);
	            seen.push(from);
	        }
	        if (noIndent) {
	            var newOpts = {
	                depth: opts.depth
	            };
	            if (has(opts, 'quoteStyle')) {
	                newOpts.quoteStyle = opts.quoteStyle;
	            }
	            return inspect_(value, newOpts, depth + 1, seen);
	        }
	        return inspect_(value, opts, depth + 1, seen);
	    }
	
	    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable
	        var name = nameOf(obj);
	        var keys = arrObjKeys(obj, inspect);
	        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
	    }
	    if (isSymbol(obj)) {
	        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
	        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
	    }
	    if (isElement(obj)) {
	        var s = '<' + $toLowerCase.call(String(obj.nodeName));
	        var attrs = obj.attributes || [];
	        for (var i = 0; i < attrs.length; i++) {
	            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
	        }
	        s += '>';
	        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
	        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
	        return s;
	    }
	    if (isArray(obj)) {
	        if (obj.length === 0) { return '[]'; }
	        var xs = arrObjKeys(obj, inspect);
	        if (indent && !singleLineValues(xs)) {
	            return '[' + indentedJoin(xs, indent) + ']';
	        }
	        return '[ ' + $join.call(xs, ', ') + ' ]';
	    }
	    if (isError(obj)) {
	        var parts = arrObjKeys(obj, inspect);
	        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
	            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
	        }
	        if (parts.length === 0) { return '[' + String(obj) + ']'; }
	        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
	    }
	    if (typeof obj === 'object' && customInspect) {
	        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
	            return utilInspect(obj, { depth: maxDepth - depth });
	        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
	            return obj.inspect();
	        }
	    }
	    if (isMap(obj)) {
	        var mapParts = [];
	        if (mapForEach) {
	            mapForEach.call(obj, function (value, key) {
	                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
	            });
	        }
	        return collectionOf('Map', mapSize.call(obj), mapParts, indent);
	    }
	    if (isSet(obj)) {
	        var setParts = [];
	        if (setForEach) {
	            setForEach.call(obj, function (value) {
	                setParts.push(inspect(value, obj));
	            });
	        }
	        return collectionOf('Set', setSize.call(obj), setParts, indent);
	    }
	    if (isWeakMap(obj)) {
	        return weakCollectionOf('WeakMap');
	    }
	    if (isWeakSet(obj)) {
	        return weakCollectionOf('WeakSet');
	    }
	    if (isWeakRef(obj)) {
	        return weakCollectionOf('WeakRef');
	    }
	    if (isNumber(obj)) {
	        return markBoxed(inspect(Number(obj)));
	    }
	    if (isBigInt(obj)) {
	        return markBoxed(inspect(bigIntValueOf.call(obj)));
	    }
	    if (isBoolean(obj)) {
	        return markBoxed(booleanValueOf.call(obj));
	    }
	    if (isString(obj)) {
	        return markBoxed(inspect(String(obj)));
	    }
	    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
	    /* eslint-env browser */
	    if (typeof window !== 'undefined' && obj === window) {
	        return '{ [object Window] }';
	    }
	    if (obj === global) {
	        return '{ [object globalThis] }';
	    }
	    if (!isDate(obj) && !isRegExp(obj)) {
	        var ys = arrObjKeys(obj, inspect);
	        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
	        var protoTag = obj instanceof Object ? '' : 'null prototype';
	        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
	        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
	        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
	        if (ys.length === 0) { return tag + '{}'; }
	        if (indent) {
	            return tag + '{' + indentedJoin(ys, indent) + '}';
	        }
	        return tag + '{ ' + $join.call(ys, ', ') + ' }';
	    }
	    return String(obj);
	};
	
	function wrapQuotes(s, defaultStyle, opts) {
	    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
	    return quoteChar + s + quoteChar;
	}
	
	function quote(s) {
	    return $replace.call(String(s), /"/g, '&quot;');
	}
	
	function isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	function isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }
	
	// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
	function isSymbol(obj) {
	    if (hasShammedSymbols) {
	        return obj && typeof obj === 'object' && obj instanceof Symbol;
	    }
	    if (typeof obj === 'symbol') {
	        return true;
	    }
	    if (!obj || typeof obj !== 'object' || !symToString) {
	        return false;
	    }
	    try {
	        symToString.call(obj);
	        return true;
	    } catch (e) {}
	    return false;
	}
	
	function isBigInt(obj) {
	    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
	        return false;
	    }
	    try {
	        bigIntValueOf.call(obj);
	        return true;
	    } catch (e) {}
	    return false;
	}
	
	var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
	function has(obj, key) {
	    return hasOwn.call(obj, key);
	}
	
	function toStr(obj) {
	    return objectToString.call(obj);
	}
	
	function nameOf(f) {
	    if (f.name) { return f.name; }
	    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
	    if (m) { return m[1]; }
	    return null;
	}
	
	function indexOf(xs, x) {
	    if (xs.indexOf) { return xs.indexOf(x); }
	    for (var i = 0, l = xs.length; i < l; i++) {
	        if (xs[i] === x) { return i; }
	    }
	    return -1;
	}
	
	function isMap(x) {
	    if (!mapSize || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        mapSize.call(x);
	        try {
	            setSize.call(x);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof Map; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}
	
	function isWeakMap(x) {
	    if (!weakMapHas || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakMapHas.call(x, weakMapHas);
	        try {
	            weakSetHas.call(x, weakSetHas);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}
	
	function isWeakRef(x) {
	    if (!weakRefDeref || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakRefDeref.call(x);
	        return true;
	    } catch (e) {}
	    return false;
	}
	
	function isSet(x) {
	    if (!setSize || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        setSize.call(x);
	        try {
	            mapSize.call(x);
	        } catch (m) {
	            return true;
	        }
	        return x instanceof Set; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}
	
	function isWeakSet(x) {
	    if (!weakSetHas || !x || typeof x !== 'object') {
	        return false;
	    }
	    try {
	        weakSetHas.call(x, weakSetHas);
	        try {
	            weakMapHas.call(x, weakMapHas);
	        } catch (s) {
	            return true;
	        }
	        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
	    } catch (e) {}
	    return false;
	}
	
	function isElement(x) {
	    if (!x || typeof x !== 'object') { return false; }
	    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
	        return true;
	    }
	    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
	}
	
	function inspectString(str, opts) {
	    if (str.length > opts.maxStringLength) {
	        var remaining = str.length - opts.maxStringLength;
	        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
	        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
	    }
	    // eslint-disable-next-line no-control-regex
	    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
	    return wrapQuotes(s, 'single', opts);
	}
	
	function lowbyte(c) {
	    var n = c.charCodeAt(0);
	    var x = {
	        8: 'b',
	        9: 't',
	        10: 'n',
	        12: 'f',
	        13: 'r'
	    }[n];
	    if (x) { return '\\' + x; }
	    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
	}
	
	function markBoxed(str) {
	    return 'Object(' + str + ')';
	}
	
	function weakCollectionOf(type) {
	    return type + ' { ? }';
	}
	
	function collectionOf(type, size, entries, indent) {
	    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
	    return type + ' (' + size + ') {' + joinedEntries + '}';
	}
	
	function singleLineValues(xs) {
	    for (var i = 0; i < xs.length; i++) {
	        if (indexOf(xs[i], '\n') >= 0) {
	            return false;
	        }
	    }
	    return true;
	}
	
	function getIndent(opts, depth) {
	    var baseIndent;
	    if (opts.indent === '\t') {
	        baseIndent = '\t';
	    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
	        baseIndent = $join.call(Array(opts.indent + 1), ' ');
	    } else {
	        return null;
	    }
	    return {
	        base: baseIndent,
	        prev: $join.call(Array(depth + 1), baseIndent)
	    };
	}
	
	function indentedJoin(xs, indent) {
	    if (xs.length === 0) { return ''; }
	    var lineJoiner = '\n' + indent.prev + indent.base;
	    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
	}
	
	function arrObjKeys(obj, inspect) {
	    var isArr = isArray(obj);
	    var xs = [];
	    if (isArr) {
	        xs.length = obj.length;
	        for (var i = 0; i < obj.length; i++) {
	            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
	        }
	    }
	    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
	    var symMap;
	    if (hasShammedSymbols) {
	        symMap = {};
	        for (var k = 0; k < syms.length; k++) {
	            symMap['$' + syms[k]] = syms[k];
	        }
	    }
	
	    for (var key in obj) { // eslint-disable-line no-restricted-syntax
	        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
	        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
	        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
	            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
	            continue; // eslint-disable-line no-restricted-syntax, no-continue
	        } else if ($test.call(/[^\w$]/, key)) {
	            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
	        } else {
	            xs.push(key + ': ' + inspect(obj[key], obj));
	        }
	    }
	    if (typeof gOPS === 'function') {
	        for (var j = 0; j < syms.length; j++) {
	            if (isEnumerable.call(obj, syms[j])) {
	                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
	            }
	        }
	    }
	    return xs;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 194 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var formats = __webpack_require__(196);
	
	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;
	
	var hexTable = (function () {
	    var array = [];
	    for (var i = 0; i < 256; ++i) {
	        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
	    }
	
	    return array;
	}());
	
	var compactQueue = function compactQueue(queue) {
	    while (queue.length > 1) {
	        var item = queue.pop();
	        var obj = item.obj[item.prop];
	
	        if (isArray(obj)) {
	            var compacted = [];
	
	            for (var j = 0; j < obj.length; ++j) {
	                if (typeof obj[j] !== 'undefined') {
	                    compacted.push(obj[j]);
	                }
	            }
	
	            item.obj[item.prop] = compacted;
	        }
	    }
	};
	
	var arrayToObject = function arrayToObject(source, options) {
	    var obj = options && options.plainObjects ? Object.create(null) : {};
	    for (var i = 0; i < source.length; ++i) {
	        if (typeof source[i] !== 'undefined') {
	            obj[i] = source[i];
	        }
	    }
	
	    return obj;
	};
	
	var merge = function merge(target, source, options) {
	    /* eslint no-param-reassign: 0 */
	    if (!source) {
	        return target;
	    }
	
	    if (typeof source !== 'object') {
	        if (isArray(target)) {
	            target.push(source);
	        } else if (target && typeof target === 'object') {
	            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
	                target[source] = true;
	            }
	        } else {
	            return [target, source];
	        }
	
	        return target;
	    }
	
	    if (!target || typeof target !== 'object') {
	        return [target].concat(source);
	    }
	
	    var mergeTarget = target;
	    if (isArray(target) && !isArray(source)) {
	        mergeTarget = arrayToObject(target, options);
	    }
	
	    if (isArray(target) && isArray(source)) {
	        source.forEach(function (item, i) {
	            if (has.call(target, i)) {
	                var targetItem = target[i];
	                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
	                    target[i] = merge(targetItem, item, options);
	                } else {
	                    target.push(item);
	                }
	            } else {
	                target[i] = item;
	            }
	        });
	        return target;
	    }
	
	    return Object.keys(source).reduce(function (acc, key) {
	        var value = source[key];
	
	        if (has.call(acc, key)) {
	            acc[key] = merge(acc[key], value, options);
	        } else {
	            acc[key] = value;
	        }
	        return acc;
	    }, mergeTarget);
	};
	
	var assign = function assignSingleSource(target, source) {
	    return Object.keys(source).reduce(function (acc, key) {
	        acc[key] = source[key];
	        return acc;
	    }, target);
	};
	
	var decode = function (str, decoder, charset) {
	    var strWithoutPlus = str.replace(/\+/g, ' ');
	    if (charset === 'iso-8859-1') {
	        // unescape never throws, no try...catch needed:
	        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
	    }
	    // utf-8
	    try {
	        return decodeURIComponent(strWithoutPlus);
	    } catch (e) {
	        return strWithoutPlus;
	    }
	};
	
	var encode = function encode(str, defaultEncoder, charset, kind, format) {
	    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
	    // It has been adapted here for stricter adherence to RFC 3986
	    if (str.length === 0) {
	        return str;
	    }
	
	    var string = str;
	    if (typeof str === 'symbol') {
	        string = Symbol.prototype.toString.call(str);
	    } else if (typeof str !== 'string') {
	        string = String(str);
	    }
	
	    if (charset === 'iso-8859-1') {
	        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
	            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
	        });
	    }
	
	    var out = '';
	    for (var i = 0; i < string.length; ++i) {
	        var c = string.charCodeAt(i);
	
	        if (
	            c === 0x2D // -
	            || c === 0x2E // .
	            || c === 0x5F // _
	            || c === 0x7E // ~
	            || (c >= 0x30 && c <= 0x39) // 0-9
	            || (c >= 0x41 && c <= 0x5A) // a-z
	            || (c >= 0x61 && c <= 0x7A) // A-Z
	            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )
	        ) {
	            out += string.charAt(i);
	            continue;
	        }
	
	        if (c < 0x80) {
	            out = out + hexTable[c];
	            continue;
	        }
	
	        if (c < 0x800) {
	            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }
	
	        if (c < 0xD800 || c >= 0xE000) {
	            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
	            continue;
	        }
	
	        i += 1;
	        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
	        /* eslint operator-linebreak: [2, "before"] */
	        out += hexTable[0xF0 | (c >> 18)]
	            + hexTable[0x80 | ((c >> 12) & 0x3F)]
	            + hexTable[0x80 | ((c >> 6) & 0x3F)]
	            + hexTable[0x80 | (c & 0x3F)];
	    }
	
	    return out;
	};
	
	var compact = function compact(value) {
	    var queue = [{ obj: { o: value }, prop: 'o' }];
	    var refs = [];
	
	    for (var i = 0; i < queue.length; ++i) {
	        var item = queue[i];
	        var obj = item.obj[item.prop];
	
	        var keys = Object.keys(obj);
	        for (var j = 0; j < keys.length; ++j) {
	            var key = keys[j];
	            var val = obj[key];
	            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
	                queue.push({ obj: obj, prop: key });
	                refs.push(val);
	            }
	        }
	    }
	
	    compactQueue(queue);
	
	    return value;
	};
	
	var isRegExp = function isRegExp(obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};
	
	var isBuffer = function isBuffer(obj) {
	    if (!obj || typeof obj !== 'object') {
	        return false;
	    }
	
	    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
	};
	
	var combine = function combine(a, b) {
	    return [].concat(a, b);
	};
	
	var maybeMap = function maybeMap(val, fn) {
	    if (isArray(val)) {
	        var mapped = [];
	        for (var i = 0; i < val.length; i += 1) {
	            mapped.push(fn(val[i]));
	        }
	        return mapped;
	    }
	    return fn(val);
	};
	
	module.exports = {
	    arrayToObject: arrayToObject,
	    assign: assign,
	    combine: combine,
	    compact: compact,
	    decode: decode,
	    encode: encode,
	    isBuffer: isBuffer,
	    isRegExp: isRegExp,
	    maybeMap: maybeMap,
	    merge: merge
	};


/***/ }),
/* 196 */
/***/ (function(module, exports) {

	'use strict';
	
	var replace = String.prototype.replace;
	var percentTwenties = /%20/g;
	
	var Format = {
	    RFC1738: 'RFC1738',
	    RFC3986: 'RFC3986'
	};
	
	module.exports = {
	    'default': Format.RFC3986,
	    formatters: {
	        RFC1738: function (value) {
	            return replace.call(value, percentTwenties, '+');
	        },
	        RFC3986: function (value) {
	            return String(value);
	        }
	    },
	    RFC1738: Format.RFC1738,
	    RFC3986: Format.RFC3986
	};


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var utils = __webpack_require__(195);
	
	var has = Object.prototype.hasOwnProperty;
	var isArray = Array.isArray;
	
	var defaults = {
	    allowDots: false,
	    allowPrototypes: false,
	    allowSparse: false,
	    arrayLimit: 20,
	    charset: 'utf-8',
	    charsetSentinel: false,
	    comma: false,
	    decoder: utils.decode,
	    delimiter: '&',
	    depth: 5,
	    ignoreQueryPrefix: false,
	    interpretNumericEntities: false,
	    parameterLimit: 1000,
	    parseArrays: true,
	    plainObjects: false,
	    strictNullHandling: false
	};
	
	var interpretNumericEntities = function (str) {
	    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
	        return String.fromCharCode(parseInt(numberStr, 10));
	    });
	};
	
	var parseArrayValue = function (val, options) {
	    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
	        return val.split(',');
	    }
	
	    return val;
	};
	
	// This is what browsers will submit when the  character occurs in an
	// application/x-www-form-urlencoded body and the encoding of the page containing
	// the form is iso-8859-1, or when the submitted form has an accept-charset
	// attribute of iso-8859-1. Presumably also with other charsets that do not contain
	// the  character, such as us-ascii.
	var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')
	
	// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
	var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')
	
	var parseValues = function parseQueryStringValues(str, options) {
	    var obj = { __proto__: null };
	
	    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
	    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
	    var parts = cleanStr.split(options.delimiter, limit);
	    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
	    var i;
	
	    var charset = options.charset;
	    if (options.charsetSentinel) {
	        for (i = 0; i < parts.length; ++i) {
	            if (parts[i].indexOf('utf8=') === 0) {
	                if (parts[i] === charsetSentinel) {
	                    charset = 'utf-8';
	                } else if (parts[i] === isoSentinel) {
	                    charset = 'iso-8859-1';
	                }
	                skipIndex = i;
	                i = parts.length; // The eslint settings do not allow break;
	            }
	        }
	    }
	
	    for (i = 0; i < parts.length; ++i) {
	        if (i === skipIndex) {
	            continue;
	        }
	        var part = parts[i];
	
	        var bracketEqualsPos = part.indexOf(']=');
	        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
	
	        var key, val;
	        if (pos === -1) {
	            key = options.decoder(part, defaults.decoder, charset, 'key');
	            val = options.strictNullHandling ? null : '';
	        } else {
	            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
	            val = utils.maybeMap(
	                parseArrayValue(part.slice(pos + 1), options),
	                function (encodedVal) {
	                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');
	                }
	            );
	        }
	
	        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
	            val = interpretNumericEntities(val);
	        }
	
	        if (part.indexOf('[]=') > -1) {
	            val = isArray(val) ? [val] : val;
	        }
	
	        if (has.call(obj, key)) {
	            obj[key] = utils.combine(obj[key], val);
	        } else {
	            obj[key] = val;
	        }
	    }
	
	    return obj;
	};
	
	var parseObject = function (chain, val, options, valuesParsed) {
	    var leaf = valuesParsed ? val : parseArrayValue(val, options);
	
	    for (var i = chain.length - 1; i >= 0; --i) {
	        var obj;
	        var root = chain[i];
	
	        if (root === '[]' && options.parseArrays) {
	            obj = [].concat(leaf);
	        } else {
	            obj = options.plainObjects ? Object.create(null) : {};
	            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
	            var index = parseInt(cleanRoot, 10);
	            if (!options.parseArrays && cleanRoot === '') {
	                obj = { 0: leaf };
	            } else if (
	                !isNaN(index)
	                && root !== cleanRoot
	                && String(index) === cleanRoot
	                && index >= 0
	                && (options.parseArrays && index <= options.arrayLimit)
	            ) {
	                obj = [];
	                obj[index] = leaf;
	            } else if (cleanRoot !== '__proto__') {
	                obj[cleanRoot] = leaf;
	            }
	        }
	
	        leaf = obj;
	    }
	
	    return leaf;
	};
	
	var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
	    if (!givenKey) {
	        return;
	    }
	
	    // Transform dot notation to bracket notation
	    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;
	
	    // The regex chunks
	
	    var brackets = /(\[[^[\]]*])/;
	    var child = /(\[[^[\]]*])/g;
	
	    // Get the parent
	
	    var segment = options.depth > 0 && brackets.exec(key);
	    var parent = segment ? key.slice(0, segment.index) : key;
	
	    // Stash the parent if it exists
	
	    var keys = [];
	    if (parent) {
	        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
	        if (!options.plainObjects && has.call(Object.prototype, parent)) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }
	
	        keys.push(parent);
	    }
	
	    // Loop through children appending to the array until we hit depth
	
	    var i = 0;
	    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
	        i += 1;
	        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
	            if (!options.allowPrototypes) {
	                return;
	            }
	        }
	        keys.push(segment[1]);
	    }
	
	    // If there's a remainder, just add whatever is left
	
	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }
	
	    return parseObject(keys, val, options, valuesParsed);
	};
	
	var normalizeParseOptions = function normalizeParseOptions(opts) {
	    if (!opts) {
	        return defaults;
	    }
	
	    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
	        throw new TypeError('Decoder has to be a function.');
	    }
	
	    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
	        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
	    }
	    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
	
	    return {
	        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
	        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
	        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
	        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
	        charset: charset,
	        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
	        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
	        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
	        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
	        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
	        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
	        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
	        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
	        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
	        parseArrays: opts.parseArrays !== false,
	        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
	        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
	    };
	};
	
	module.exports = function (str, opts) {
	    var options = normalizeParseOptions(opts);
	
	    if (str === '' || str === null || typeof str === 'undefined') {
	        return options.plainObjects ? Object.create(null) : {};
	    }
	
	    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
	    var obj = options.plainObjects ? Object.create(null) : {};
	
	    // Iterate over the keys and setup the new object
	
	    var keys = Object.keys(tempObj);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
	        obj = utils.merge(obj, newObj, options);
	    }
	
	    if (options.allowSparse === true) {
	        return obj;
	    }
	
	    return utils.compact(obj);
	};


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var ClientRequest = __webpack_require__(199)
	var response = __webpack_require__(202)
	var extend = __webpack_require__(223)
	var statusCodes = __webpack_require__(224)
	var url = __webpack_require__(174)
	
	var http = exports
	
	http.request = function (opts, cb) {
		if (typeof opts === 'string')
			opts = url.parse(opts)
		else
			opts = extend(opts)
	
		// Normally, the page is loaded from http or https, so not specifying a protocol
		// will result in a (valid) protocol-relative url. However, this won't work if
		// the protocol is something else, like 'file:'
		var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''
	
		var protocol = opts.protocol || defaultProtocol
		var host = opts.hostname || opts.host
		var port = opts.port
		var path = opts.path || '/'
	
		// Necessary for IPv6 addresses
		if (host && host.indexOf(':') !== -1)
			host = '[' + host + ']'
	
		// This may be a relative url. The browser should always be able to interpret it correctly.
		opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
		opts.method = (opts.method || 'GET').toUpperCase()
		opts.headers = opts.headers || {}
	
		// Also valid opts.auth, opts.mode
	
		var req = new ClientRequest(opts)
		if (cb)
			req.on('response', cb)
		return req
	}
	
	http.get = function get (opts, cb) {
		var req = http.request(opts, cb)
		req.end()
		return req
	}
	
	http.ClientRequest = ClientRequest
	http.IncomingMessage = response.IncomingMessage
	
	http.Agent = function () {}
	http.Agent.defaultMaxSockets = 4
	
	http.globalAgent = new http.Agent()
	
	http.STATUS_CODES = statusCodes
	
	http.METHODS = [
		'CHECKOUT',
		'CONNECT',
		'COPY',
		'DELETE',
		'GET',
		'HEAD',
		'LOCK',
		'M-SEARCH',
		'MERGE',
		'MKACTIVITY',
		'MKCOL',
		'MOVE',
		'NOTIFY',
		'OPTIONS',
		'PATCH',
		'POST',
		'PROPFIND',
		'PROPPATCH',
		'PURGE',
		'PUT',
		'REPORT',
		'SEARCH',
		'SUBSCRIBE',
		'TRACE',
		'UNLOCK',
		'UNSUBSCRIBE'
	]
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global, process) {var capability = __webpack_require__(200)
	var inherits = __webpack_require__(201)
	var response = __webpack_require__(202)
	var stream = __webpack_require__(203)
	var toArrayBuffer = __webpack_require__(222)
	
	var IncomingMessage = response.IncomingMessage
	var rStates = response.readyStates
	
	function decideMode (preferBinary, useFetch) {
		if (capability.fetch && useFetch) {
			return 'fetch'
		} else if (capability.mozchunkedarraybuffer) {
			return 'moz-chunked-arraybuffer'
		} else if (capability.msstream) {
			return 'ms-stream'
		} else if (capability.arraybuffer && preferBinary) {
			return 'arraybuffer'
		} else if (capability.vbArray && preferBinary) {
			return 'text:vbarray'
		} else {
			return 'text'
		}
	}
	
	var ClientRequest = module.exports = function (opts) {
		var self = this
		stream.Writable.call(self)
	
		self._opts = opts
		self._body = []
		self._headers = {}
		if (opts.auth)
			self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
		Object.keys(opts.headers).forEach(function (name) {
			self.setHeader(name, opts.headers[name])
		})
	
		var preferBinary
		var useFetch = true
		if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
			// If the use of XHR should be preferred. Not typically needed.
			useFetch = false
			preferBinary = true
		} else if (opts.mode === 'prefer-streaming') {
			// If streaming is a high priority but binary compatibility and
			// the accuracy of the 'content-type' header aren't
			preferBinary = false
		} else if (opts.mode === 'allow-wrong-content-type') {
			// If streaming is more important than preserving the 'content-type' header
			preferBinary = !capability.overrideMimeType
		} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
			// Use binary if text streaming may corrupt data or the content-type header, or for speed
			preferBinary = true
		} else {
			throw new Error('Invalid value for opts.mode')
		}
		self._mode = decideMode(preferBinary, useFetch)
		self._fetchTimer = null
	
		self.on('finish', function () {
			self._onFinish()
		})
	}
	
	inherits(ClientRequest, stream.Writable)
	
	ClientRequest.prototype.setHeader = function (name, value) {
		var self = this
		var lowerName = name.toLowerCase()
		// This check is not necessary, but it prevents warnings from browsers about setting unsafe
		// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
		// http-browserify did it, so I will too.
		if (unsafeHeaders.indexOf(lowerName) !== -1)
			return
	
		self._headers[lowerName] = {
			name: name,
			value: value
		}
	}
	
	ClientRequest.prototype.getHeader = function (name) {
		var header = this._headers[name.toLowerCase()]
		if (header)
			return header.value
		return null
	}
	
	ClientRequest.prototype.removeHeader = function (name) {
		var self = this
		delete self._headers[name.toLowerCase()]
	}
	
	ClientRequest.prototype._onFinish = function () {
		var self = this
	
		if (self._destroyed)
			return
		var opts = self._opts
	
		var headersObj = self._headers
		var body = null
		if (opts.method !== 'GET' && opts.method !== 'HEAD') {
			if (capability.arraybuffer) {
				body = toArrayBuffer(Buffer.concat(self._body))
			} else if (capability.blobConstructor) {
				body = new global.Blob(self._body.map(function (buffer) {
					return toArrayBuffer(buffer)
				}), {
					type: (headersObj['content-type'] || {}).value || ''
				})
			} else {
				// get utf8 string
				body = Buffer.concat(self._body).toString()
			}
		}
	
		// create flattened list of headers
		var headersList = []
		Object.keys(headersObj).forEach(function (keyName) {
			var name = headersObj[keyName].name
			var value = headersObj[keyName].value
			if (Array.isArray(value)) {
				value.forEach(function (v) {
					headersList.push([name, v])
				})
			} else {
				headersList.push([name, value])
			}
		})
	
		if (self._mode === 'fetch') {
			var signal = null
			var fetchTimer = null
			if (capability.abortController) {
				var controller = new AbortController()
				signal = controller.signal
				self._fetchAbortController = controller
	
				if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
					self._fetchTimer = global.setTimeout(function () {
						self.emit('requestTimeout')
						if (self._fetchAbortController)
							self._fetchAbortController.abort()
					}, opts.requestTimeout)
				}
			}
	
			global.fetch(self._opts.url, {
				method: self._opts.method,
				headers: headersList,
				body: body || undefined,
				mode: 'cors',
				credentials: opts.withCredentials ? 'include' : 'same-origin',
				signal: signal
			}).then(function (response) {
				self._fetchResponse = response
				self._connect()
			}, function (reason) {
				global.clearTimeout(self._fetchTimer)
				if (!self._destroyed)
					self.emit('error', reason)
			})
		} else {
			var xhr = self._xhr = new global.XMLHttpRequest()
			try {
				xhr.open(self._opts.method, self._opts.url, true)
			} catch (err) {
				process.nextTick(function () {
					self.emit('error', err)
				})
				return
			}
	
			// Can't set responseType on really old browsers
			if ('responseType' in xhr)
				xhr.responseType = self._mode.split(':')[0]
	
			if ('withCredentials' in xhr)
				xhr.withCredentials = !!opts.withCredentials
	
			if (self._mode === 'text' && 'overrideMimeType' in xhr)
				xhr.overrideMimeType('text/plain; charset=x-user-defined')
	
			if ('requestTimeout' in opts) {
				xhr.timeout = opts.requestTimeout
				xhr.ontimeout = function () {
					self.emit('requestTimeout')
				}
			}
	
			headersList.forEach(function (header) {
				xhr.setRequestHeader(header[0], header[1])
			})
	
			self._response = null
			xhr.onreadystatechange = function () {
				switch (xhr.readyState) {
					case rStates.LOADING:
					case rStates.DONE:
						self._onXHRProgress()
						break
				}
			}
			// Necessary for streaming in Firefox, since xhr.response is ONLY defined
			// in onprogress, not in onreadystatechange with xhr.readyState = 3
			if (self._mode === 'moz-chunked-arraybuffer') {
				xhr.onprogress = function () {
					self._onXHRProgress()
				}
			}
	
			xhr.onerror = function () {
				if (self._destroyed)
					return
				self.emit('error', new Error('XHR error'))
			}
	
			try {
				xhr.send(body)
			} catch (err) {
				process.nextTick(function () {
					self.emit('error', err)
				})
				return
			}
		}
	}
	
	/**
	 * Checks if xhr.status is readable and non-zero, indicating no error.
	 * Even though the spec says it should be available in readyState 3,
	 * accessing it throws an exception in IE8
	 */
	function statusValid (xhr) {
		try {
			var status = xhr.status
			return (status !== null && status !== 0)
		} catch (e) {
			return false
		}
	}
	
	ClientRequest.prototype._onXHRProgress = function () {
		var self = this
	
		if (!statusValid(self._xhr) || self._destroyed)
			return
	
		if (!self._response)
			self._connect()
	
		self._response._onXHRProgress()
	}
	
	ClientRequest.prototype._connect = function () {
		var self = this
	
		if (self._destroyed)
			return
	
		self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
		self._response.on('error', function(err) {
			self.emit('error', err)
		})
	
		self.emit('response', self._response)
	}
	
	ClientRequest.prototype._write = function (chunk, encoding, cb) {
		var self = this
	
		self._body.push(chunk)
		cb()
	}
	
	ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
		var self = this
		self._destroyed = true
		global.clearTimeout(self._fetchTimer)
		if (self._response)
			self._response._destroyed = true
		if (self._xhr)
			self._xhr.abort()
		else if (self._fetchAbortController)
			self._fetchAbortController.abort()
	}
	
	ClientRequest.prototype.end = function (data, encoding, cb) {
		var self = this
		if (typeof data === 'function') {
			cb = data
			data = undefined
		}
	
		stream.Writable.prototype.end.call(self, data, encoding, cb)
	}
	
	ClientRequest.prototype.flushHeaders = function () {}
	ClientRequest.prototype.setTimeout = function () {}
	ClientRequest.prototype.setNoDelay = function () {}
	ClientRequest.prototype.setSocketKeepAlive = function () {}
	
	// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
	var unsafeHeaders = [
		'accept-charset',
		'accept-encoding',
		'access-control-request-headers',
		'access-control-request-method',
		'connection',
		'content-length',
		'cookie',
		'cookie2',
		'date',
		'dnt',
		'expect',
		'host',
		'keep-alive',
		'origin',
		'referer',
		'te',
		'trailer',
		'transfer-encoding',
		'upgrade',
		'via'
	]
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(167).Buffer, (function() { return this; }()), __webpack_require__(5)))

/***/ }),
/* 200 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)
	
	exports.writableStream = isFunction(global.WritableStream)
	
	exports.abortController = isFunction(global.AbortController)
	
	exports.blobConstructor = false
	try {
		new Blob([new ArrayBuffer(1)])
		exports.blobConstructor = true
	} catch (e) {}
	
	// The xhr request to example.com may violate some restrictive CSP configurations,
	// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
	// and assume support for certain features below.
	var xhr
	function getXHR () {
		// Cache the xhr value
		if (xhr !== undefined) return xhr
	
		if (global.XMLHttpRequest) {
			xhr = new global.XMLHttpRequest()
			// If XDomainRequest is available (ie only, where xhr might not work
			// cross domain), use the page location. Otherwise use example.com
			// Note: this doesn't actually make an http request.
			try {
				xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
			} catch(e) {
				xhr = null
			}
		} else {
			// Service workers don't have XHR
			xhr = null
		}
		return xhr
	}
	
	function checkTypeSupport (type) {
		var xhr = getXHR()
		if (!xhr) return false
		try {
			xhr.responseType = type
			return xhr.responseType === type
		} catch (e) {}
		return false
	}
	
	// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
	// Safari 7.1 appears to have fixed this bug.
	var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
	var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)
	
	// If fetch is supported, then arraybuffer will be supported too. Skip calling
	// checkTypeSupport(), since that calls getXHR().
	exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))
	
	// These next two tests unavoidably show warnings in Chrome. Since fetch will always
	// be used if it's available, just return false for these to avoid the warnings.
	exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
	exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
		checkTypeSupport('moz-chunked-arraybuffer')
	
	// If fetch is supported, then overrideMimeType will be supported too. Skip calling
	// getXHR().
	exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)
	
	exports.vbArray = isFunction(global.VBArray)
	
	function isFunction (value) {
		return typeof value === 'function'
	}
	
	xhr = null // Help gc
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 201 */
/***/ (function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      })
	    }
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor
	      var TempCtor = function () {}
	      TempCtor.prototype = superCtor.prototype
	      ctor.prototype = new TempCtor()
	      ctor.prototype.constructor = ctor
	    }
	  }
	}


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, Buffer, global) {var capability = __webpack_require__(200)
	var inherits = __webpack_require__(201)
	var stream = __webpack_require__(203)
	
	var rStates = exports.readyStates = {
		UNSENT: 0,
		OPENED: 1,
		HEADERS_RECEIVED: 2,
		LOADING: 3,
		DONE: 4
	}
	
	var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
		var self = this
		stream.Readable.call(self)
	
		self._mode = mode
		self.headers = {}
		self.rawHeaders = []
		self.trailers = {}
		self.rawTrailers = []
	
		// Fake the 'close' event, but only once 'end' fires
		self.on('end', function () {
			// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
			process.nextTick(function () {
				self.emit('close')
			})
		})
	
		if (mode === 'fetch') {
			self._fetchResponse = response
	
			self.url = response.url
			self.statusCode = response.status
			self.statusMessage = response.statusText
			
			response.headers.forEach(function (header, key){
				self.headers[key.toLowerCase()] = header
				self.rawHeaders.push(key, header)
			})
	
			if (capability.writableStream) {
				var writable = new WritableStream({
					write: function (chunk) {
						return new Promise(function (resolve, reject) {
							if (self._destroyed) {
								reject()
							} else if(self.push(new Buffer(chunk))) {
								resolve()
							} else {
								self._resumeFetch = resolve
							}
						})
					},
					close: function () {
						global.clearTimeout(fetchTimer)
						if (!self._destroyed)
							self.push(null)
					},
					abort: function (err) {
						if (!self._destroyed)
							self.emit('error', err)
					}
				})
	
				try {
					response.body.pipeTo(writable).catch(function (err) {
						global.clearTimeout(fetchTimer)
						if (!self._destroyed)
							self.emit('error', err)
					})
					return
				} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
			}
			// fallback for when writableStream or pipeTo aren't available
			var reader = response.body.getReader()
			function read () {
				reader.read().then(function (result) {
					if (self._destroyed)
						return
					if (result.done) {
						global.clearTimeout(fetchTimer)
						self.push(null)
						return
					}
					self.push(new Buffer(result.value))
					read()
				}).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
			}
			read()
		} else {
			self._xhr = xhr
			self._pos = 0
	
			self.url = xhr.responseURL
			self.statusCode = xhr.status
			self.statusMessage = xhr.statusText
			var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
			headers.forEach(function (header) {
				var matches = header.match(/^([^:]+):\s*(.*)/)
				if (matches) {
					var key = matches[1].toLowerCase()
					if (key === 'set-cookie') {
						if (self.headers[key] === undefined) {
							self.headers[key] = []
						}
						self.headers[key].push(matches[2])
					} else if (self.headers[key] !== undefined) {
						self.headers[key] += ', ' + matches[2]
					} else {
						self.headers[key] = matches[2]
					}
					self.rawHeaders.push(matches[1], matches[2])
				}
			})
	
			self._charset = 'x-user-defined'
			if (!capability.overrideMimeType) {
				var mimeType = self.rawHeaders['mime-type']
				if (mimeType) {
					var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
					if (charsetMatch) {
						self._charset = charsetMatch[1].toLowerCase()
					}
				}
				if (!self._charset)
					self._charset = 'utf-8' // best guess
			}
		}
	}
	
	inherits(IncomingMessage, stream.Readable)
	
	IncomingMessage.prototype._read = function () {
		var self = this
	
		var resolve = self._resumeFetch
		if (resolve) {
			self._resumeFetch = null
			resolve()
		}
	}
	
	IncomingMessage.prototype._onXHRProgress = function () {
		var self = this
	
		var xhr = self._xhr
	
		var response = null
		switch (self._mode) {
			case 'text:vbarray': // For IE9
				if (xhr.readyState !== rStates.DONE)
					break
				try {
					// This fails in IE8
					response = new global.VBArray(xhr.responseBody).toArray()
				} catch (e) {}
				if (response !== null) {
					self.push(new Buffer(response))
					break
				}
				// Falls through in IE8	
			case 'text':
				try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
					response = xhr.responseText
				} catch (e) {
					self._mode = 'text:vbarray'
					break
				}
				if (response.length > self._pos) {
					var newData = response.substr(self._pos)
					if (self._charset === 'x-user-defined') {
						var buffer = new Buffer(newData.length)
						for (var i = 0; i < newData.length; i++)
							buffer[i] = newData.charCodeAt(i) & 0xff
	
						self.push(buffer)
					} else {
						self.push(newData, self._charset)
					}
					self._pos = response.length
				}
				break
			case 'arraybuffer':
				if (xhr.readyState !== rStates.DONE || !xhr.response)
					break
				response = xhr.response
				self.push(new Buffer(new Uint8Array(response)))
				break
			case 'moz-chunked-arraybuffer': // take whole
				response = xhr.response
				if (xhr.readyState !== rStates.LOADING || !response)
					break
				self.push(new Buffer(new Uint8Array(response)))
				break
			case 'ms-stream':
				response = xhr.response
				if (xhr.readyState !== rStates.LOADING)
					break
				var reader = new global.MSStreamReader()
				reader.onprogress = function () {
					if (reader.result.byteLength > self._pos) {
						self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
						self._pos = reader.result.byteLength
					}
				}
				reader.onload = function () {
					self.push(null)
				}
				// reader.onerror = ??? // TODO: this
				reader.readAsArrayBuffer(response)
				break
		}
	
		// The ms-stream case handles end separately in reader.onload()
		if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
			self.push(null)
		}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(167).Buffer, (function() { return this; }())))

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(204);
	exports.Stream = exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(215);
	exports.Duplex = __webpack_require__(214);
	exports.Transform = __webpack_require__(220);
	exports.PassThrough = __webpack_require__(221);


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	/*<replacement>*/
	
	var pna = __webpack_require__(205);
	/*</replacement>*/
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(170);
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	/*<replacement>*/
	var EE = __webpack_require__(206).EventEmitter;
	
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream = __webpack_require__(207);
	/*</replacement>*/
	
	/*<replacement>*/
	
	var Buffer = __webpack_require__(208).Buffer;
	var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	
	/*</replacement>*/
	
	/*<replacement>*/
	var util = Object.create(__webpack_require__(209));
	util.inherits = __webpack_require__(201);
	/*</replacement>*/
	
	/*<replacement>*/
	var debugUtil = __webpack_require__(210);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	var BufferList = __webpack_require__(211);
	var destroyImpl = __webpack_require__(213);
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
	
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);
	
	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}
	
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(214);
	
	  options = options || {};
	
	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  var isDuplex = stream instanceof Duplex;
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var readableHwm = options.readableHighWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	
	  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = Math.floor(this.highWaterMark);
	
	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	
	  // has it been destroyed
	  this.destroyed = false;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(219).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(214);
	
	  if (!(this instanceof Readable)) return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;
	
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	  }
	
	  Stream.call(this);
	}
	
	Object.defineProperty(Readable.prototype, 'destroyed', {
	  get: function () {
	    if (this._readableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed;
	  },
	  set: function (value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._readableState) {
	      return;
	    }
	
	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	  }
	});
	
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  this.push(null);
	  cb(err);
	};
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  var skipChunkCheck;
	
	  if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (encoding !== state.encoding) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = '';
	      }
	      skipChunkCheck = true;
	    }
	  } else {
	    skipChunkCheck = true;
	  }
	
	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  return readableAddChunk(this, chunk, null, true, false);
	};
	
	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	  var state = stream._readableState;
	  if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else {
	    var er;
	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
	    if (er) {
	      stream.emit('error', er);
	    } else if (state.objectMode || chunk && chunk.length > 0) {
	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
	        chunk = _uint8ArrayToBuffer(chunk);
	      }
	
	      if (addToFront) {
	        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
	      } else if (state.ended) {
	        stream.emit('error', new Error('stream.push() after EOF'));
	      } else {
	        state.reading = false;
	        if (state.decoder && !encoding) {
	          chunk = state.decoder.write(chunk);
	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	        } else {
	          addChunk(stream, state, chunk, false);
	        }
	      }
	    } else if (!addToFront) {
	      state.reading = false;
	    }
	  }
	
	  return needMoreData(state);
	}
	
	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync) {
	    stream.emit('data', chunk);
	    stream.read(0);
	  } else {
	    // update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	
	    if (state.needReadable) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}
	
	function chunkInvalid(state, chunk) {
	  var er;
	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(219).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}
	
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (n !== 0) state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }
	
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;
	
	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	
	  if (ret !== null) this.emit('data', ret);
	
	  return ret;
	};
	
	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    pna.nextTick(maybeReadMore_, stream, state);
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};
	
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	
	  var endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);
	
	    cleanedUp = true;
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	
	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', state.awaitDrain);
	        state.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	
	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	  var unpipeInfo = { hasUnpiped: false };
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	
	    if (!dest) dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this, { hasUnpiped: false });
	    }return this;
	  }
	
	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this, unpipeInfo);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        pna.nextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    pna.nextTick(resume_, stream, state);
	  }
	}
	
	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }
	
	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var _this = this;
	
	  var state = this._readableState;
	  var paused = false;
	
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) _this.push(chunk);
	    }
	
	    _this.push(null);
	  });
	
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	
	    var ret = _this.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }
	
	  // proxy certain important events.
	  for (var n = 0; n < kProxyEvents.length; n++) {
	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	  }
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  this._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return this;
	};
	
	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function () {
	    return this._readableState.highWaterMark;
	  }
	});
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }
	
	  return ret;
	}
	
	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}
	
	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = Buffer.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    pna.nextTick(endReadableNT, state, stream);
	  }
	}
	
	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}
	
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)))

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	if (typeof process === 'undefined' ||
	    !process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = { nextTick: nextTick };
	} else {
	  module.exports = process
	}
	
	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 206 */
/***/ (function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(206).EventEmitter;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	/* eslint-disable node/no-deprecated-api */
	var buffer = __webpack_require__(167)
	var Buffer = buffer.Buffer
	
	// alternative to using Object.keys for old browsers
	function copyProps (src, dst) {
	  for (var key in src) {
	    dst[key] = src[key]
	  }
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
	  module.exports = buffer
	} else {
	  // Copy properties from require('buffer')
	  copyProps(buffer, exports)
	  exports.Buffer = SafeBuffer
	}
	
	function SafeBuffer (arg, encodingOrOffset, length) {
	  return Buffer(arg, encodingOrOffset, length)
	}
	
	// Copy static methods from Buffer
	copyProps(Buffer, SafeBuffer)
	
	SafeBuffer.from = function (arg, encodingOrOffset, length) {
	  if (typeof arg === 'number') {
	    throw new TypeError('Argument must not be a number')
	  }
	  return Buffer(arg, encodingOrOffset, length)
	}
	
	SafeBuffer.alloc = function (size, fill, encoding) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  var buf = Buffer(size)
	  if (fill !== undefined) {
	    if (typeof encoding === 'string') {
	      buf.fill(fill, encoding)
	    } else {
	      buf.fill(fill)
	    }
	  } else {
	    buf.fill(0)
	  }
	  return buf
	}
	
	SafeBuffer.allocUnsafe = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return Buffer(size)
	}
	
	SafeBuffer.allocUnsafeSlow = function (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('Argument must be a number')
	  }
	  return buffer.SlowBuffer(size)
	}


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(167).Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


/***/ }),
/* 210 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Buffer = __webpack_require__(208).Buffer;
	var util = __webpack_require__(212);
	
	function copyBuffer(src, target, offset) {
	  src.copy(target, offset);
	}
	
	module.exports = function () {
	  function BufferList() {
	    _classCallCheck(this, BufferList);
	
	    this.head = null;
	    this.tail = null;
	    this.length = 0;
	  }
	
	  BufferList.prototype.push = function push(v) {
	    var entry = { data: v, next: null };
	    if (this.length > 0) this.tail.next = entry;else this.head = entry;
	    this.tail = entry;
	    ++this.length;
	  };
	
	  BufferList.prototype.unshift = function unshift(v) {
	    var entry = { data: v, next: this.head };
	    if (this.length === 0) this.tail = entry;
	    this.head = entry;
	    ++this.length;
	  };
	
	  BufferList.prototype.shift = function shift() {
	    if (this.length === 0) return;
	    var ret = this.head.data;
	    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	    --this.length;
	    return ret;
	  };
	
	  BufferList.prototype.clear = function clear() {
	    this.head = this.tail = null;
	    this.length = 0;
	  };
	
	  BufferList.prototype.join = function join(s) {
	    if (this.length === 0) return '';
	    var p = this.head;
	    var ret = '' + p.data;
	    while (p = p.next) {
	      ret += s + p.data;
	    }return ret;
	  };
	
	  BufferList.prototype.concat = function concat(n) {
	    if (this.length === 0) return Buffer.alloc(0);
	    var ret = Buffer.allocUnsafe(n >>> 0);
	    var p = this.head;
	    var i = 0;
	    while (p) {
	      copyBuffer(p.data, ret, i);
	      i += p.data.length;
	      p = p.next;
	    }
	    return ret;
	  };
	
	  return BufferList;
	}();
	
	if (util && util.inspect && util.inspect.custom) {
	  module.exports.prototype[util.inspect.custom] = function () {
	    var obj = util.inspect({ length: this.length });
	    return this.constructor.name + ' ' + obj;
	  };
	}

/***/ }),
/* 212 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	/*<replacement>*/
	
	var pna = __webpack_require__(205);
	/*</replacement>*/
	
	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
	  var _this = this;
	
	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;
	
	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        pna.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        pna.nextTick(emitErrorNT, this, err);
	      }
	    }
	
	    return this;
	  }
	
	  // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks
	
	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  }
	
	  // if this is a duplex stream mark the writable part as destroyed as well
	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }
	
	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        pna.nextTick(emitErrorNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        pna.nextTick(emitErrorNT, _this, err);
	      }
	    } else if (cb) {
	      cb(err);
	    }
	  });
	
	  return this;
	}
	
	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }
	
	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}
	
	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}
	
	module.exports = {
	  destroy: destroy,
	  undestroy: undestroy
	};

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	'use strict';
	
	/*<replacement>*/
	
	var pna = __webpack_require__(205);
	/*</replacement>*/
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var util = Object.create(__webpack_require__(209));
	util.inherits = __webpack_require__(201);
	/*</replacement>*/
	
	var Readable = __webpack_require__(204);
	var Writable = __webpack_require__(215);
	
	util.inherits(Duplex, Readable);
	
	{
	  // avoid scope creep, the keys array can then be collected
	  var keys = objectKeys(Writable.prototype);
	  for (var v = 0; v < keys.length; v++) {
	    var method = keys[v];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}
	
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false) this.readable = false;
	
	  if (options && options.writable === false) this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function () {
	    return this._writableState.highWaterMark;
	  }
	});
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  pna.nextTick(onEndNT, this);
	}
	
	function onEndNT(self) {
	  self.end();
	}
	
	Object.defineProperty(Duplex.prototype, 'destroyed', {
	  get: function () {
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed && this._writableState.destroyed;
	  },
	  set: function (value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return;
	    }
	
	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	    this._writableState.destroyed = value;
	  }
	});
	
	Duplex.prototype._destroy = function (err, cb) {
	  this.push(null);
	  this.end();
	
	  pna.nextTick(cb, err);
	};

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.
	
	'use strict';
	
	/*<replacement>*/
	
	var pna = __webpack_require__(205);
	/*</replacement>*/
	
	module.exports = Writable;
	
	/* <replacement> */
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}
	
	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	
	  this.next = null;
	  this.entry = null;
	  this.finish = function () {
	    onCorkedFinish(_this, state);
	  };
	}
	/* </replacement> */
	
	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	/*<replacement>*/
	var util = Object.create(__webpack_require__(209));
	util.inherits = __webpack_require__(201);
	/*</replacement>*/
	
	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(218)
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream = __webpack_require__(207);
	/*</replacement>*/
	
	/*<replacement>*/
	
	var Buffer = __webpack_require__(208).Buffer;
	var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	
	/*</replacement>*/
	
	var destroyImpl = __webpack_require__(213);
	
	util.inherits(Writable, Stream);
	
	function nop() {}
	
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(214);
	
	  options = options || {};
	
	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  var isDuplex = stream instanceof Duplex;
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var writableHwm = options.writableHighWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	
	  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = Math.floor(this.highWaterMark);
	
	  // if _final has been called
	  this.finalCalled = false;
	
	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // has it been destroyed
	  this.destroyed = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	
	  // count buffered requests
	  this.bufferedRequestCount = 0;
	
	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	    });
	  } catch (_) {}
	})();
	
	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;
	      if (this !== Writable) return false;
	
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}
	
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(214);
	
	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.
	
	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	
	    if (typeof options.writev === 'function') this._writev = options.writev;
	
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	
	    if (typeof options.final === 'function') this._final = options.final;
	  }
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};
	
	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  pna.nextTick(cb, er);
	}
	
	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    pna.nextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = !state.objectMode && _isUint8Array(chunk);
	
	  if (isBuf && !Buffer.isBuffer(chunk)) {
	    chunk = _uint8ArrayToBuffer(chunk);
	  }
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function') cb = nop;
	
	  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function () {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer.from(chunk, encoding);
	  }
	  return chunk;
	}
	
	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function () {
	    return this._writableState.highWaterMark;
	  }
	});
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    var newChunk = decodeChunk(state, chunk, encoding);
	    if (chunk !== newChunk) {
	      isBuf = true;
	      encoding = 'buffer';
	      chunk = newChunk;
	    }
	  }
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = {
	      chunk: chunk,
	      encoding: encoding,
	      isBuf: isBuf,
	      callback: cb,
	      next: null
	    };
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	
	  if (sync) {
	    // defer the callback if we are being called synchronously
	    // to avoid piling up things on the stack
	    pna.nextTick(cb, er);
	    // this can emit finish, and it will always happen
	    // after error
	    pna.nextTick(finishMaybe, stream, state);
	    stream._writableState.errorEmitted = true;
	    stream.emit('error', er);
	  } else {
	    // the caller expect this to happen before if
	    // it is async
	    cb(er);
	    stream._writableState.errorEmitted = true;
	    stream.emit('error', er);
	    // this can emit finish, but finish must
	    // always follow error
	    finishMaybe(stream, state);
	  }
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);
	
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	
	    var count = 0;
	    var allBuffers = true;
	    while (entry) {
	      buffer[count] = entry;
	      if (!entry.isBuf) allBuffers = false;
	      entry = entry.next;
	      count += 1;
	    }
	    buffer.allBuffers = allBuffers;
	
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
	
	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	    state.bufferedRequestCount = 0;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      state.bufferedRequestCount--;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending) endWritable(this, state, cb);
	};
	
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
	  stream._final(function (err) {
	    state.pendingcb--;
	    if (err) {
	      stream.emit('error', err);
	    }
	    state.prefinished = true;
	    stream.emit('prefinish');
	    finishMaybe(stream, state);
	  });
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function') {
	      state.pendingcb++;
	      state.finalCalled = true;
	      pna.nextTick(callFinal, stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      state.finished = true;
	      stream.emit('finish');
	    }
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	
	function onCorkedFinish(corkReq, state, err) {
	  var entry = corkReq.entry;
	  corkReq.entry = null;
	  while (entry) {
	    var cb = entry.callback;
	    state.pendingcb--;
	    cb(err);
	    entry = entry.next;
	  }
	
	  // reuse the free corkReq.
	  state.corkedRequestsFree.next = corkReq;
	}
	
	Object.defineProperty(Writable.prototype, 'destroyed', {
	  get: function () {
	    if (this._writableState === undefined) {
	      return false;
	    }
	    return this._writableState.destroyed;
	  },
	  set: function (value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._writableState) {
	      return;
	    }
	
	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._writableState.destroyed = value;
	  }
	});
	
	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  this.end();
	  cb(err);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(216).setImmediate, (function() { return this; }())))

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
	            (typeof self !== "undefined" && self) ||
	            window;
	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(scope, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(217);
	// On some exotic environments, it's not clear which object `setimmediate` was
	// able to install onto.  Search each possibility in the same order as the
	// `setimmediate` library.
	exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
	                       (typeof global !== "undefined" && global.setImmediate) ||
	                       (this && this.setImmediate);
	exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
	                         (typeof global !== "undefined" && global.clearImmediate) ||
	                         (this && this.clearImmediate);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 68
	        installReadyStateChangeImplementation();
	
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)))

/***/ }),
/* 218 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */
	
	module.exports = deprecate;
	
	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */
	
	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	}
	
	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */
	
	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	/*<replacement>*/
	
	var Buffer = __webpack_require__(208).Buffer;
	/*</replacement>*/
	
	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};
	
	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	};
	
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	exports.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}
	
	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};
	
	StringDecoder.prototype.end = utf8End;
	
	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;
	
	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};
	
	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}
	
	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}
	
	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}
	
	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf, p);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}
	
	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}
	
	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}
	
	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}
	
	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}
	
	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}
	
	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}
	
	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}
	
	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	'use strict';
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(214);
	
	/*<replacement>*/
	var util = Object.create(__webpack_require__(209));
	util.inherits = __webpack_require__(201);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb) {
	    return this.emit('error', new Error('write callback called multiple times'));
	  }
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data != null) // single equals check for both `null` and `undefined`
	    this.push(data);
	
	  cb(er);
	
	  var rs = this._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}
	
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  };
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }
	
	  // When the writable side finishes, then flush out anything remaining.
	  this.on('prefinish', prefinish);
	}
	
	function prefinish() {
	  var _this = this;
	
	  if (typeof this._flush === 'function') {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}
	
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};
	
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	Transform.prototype._destroy = function (err, cb) {
	  var _this2 = this;
	
	  Duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	    _this2.emit('close');
	  });
	};
	
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	
	  if (data != null) // single equals check for both `null` and `undefined`
	    stream.push(data);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
	
	  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
	
	  return stream.push(null);
	}

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	'use strict';
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(220);
	
	/*<replacement>*/
	var util = Object.create(__webpack_require__(209));
	util.inherits = __webpack_require__(201);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

	var Buffer = __webpack_require__(167).Buffer
	
	module.exports = function (buf) {
		// If the buffer is backed by a Uint8Array, a faster version will work
		if (buf instanceof Uint8Array) {
			// If the buffer isn't a subarray, return the underlying ArrayBuffer
			if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
				return buf.buffer
			} else if (typeof buf.buffer.slice === 'function') {
				// Otherwise we need to get a proper copy
				return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
			}
		}
	
		if (Buffer.isBuffer(buf)) {
			// This is the slow version that will work with any Buffer
			// implementation (even in old browsers)
			var arrayCopy = new Uint8Array(buf.length)
			var len = buf.length
			for (var i = 0; i < len; i++) {
				arrayCopy[i] = buf[i]
			}
			return arrayCopy.buffer
		} else {
			throw new Error('Argument must be a Buffer')
		}
	}


/***/ }),
/* 223 */
/***/ (function(module, exports) {

	module.exports = extend
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function extend() {
	    var target = {}
	
	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }
	
	    return target
	}


/***/ }),
/* 224 */
/***/ (function(module, exports) {

	module.exports = {
	  "100": "Continue",
	  "101": "Switching Protocols",
	  "102": "Processing",
	  "200": "OK",
	  "201": "Created",
	  "202": "Accepted",
	  "203": "Non-Authoritative Information",
	  "204": "No Content",
	  "205": "Reset Content",
	  "206": "Partial Content",
	  "207": "Multi-Status",
	  "208": "Already Reported",
	  "226": "IM Used",
	  "300": "Multiple Choices",
	  "301": "Moved Permanently",
	  "302": "Found",
	  "303": "See Other",
	  "304": "Not Modified",
	  "305": "Use Proxy",
	  "307": "Temporary Redirect",
	  "308": "Permanent Redirect",
	  "400": "Bad Request",
	  "401": "Unauthorized",
	  "402": "Payment Required",
	  "403": "Forbidden",
	  "404": "Not Found",
	  "405": "Method Not Allowed",
	  "406": "Not Acceptable",
	  "407": "Proxy Authentication Required",
	  "408": "Request Timeout",
	  "409": "Conflict",
	  "410": "Gone",
	  "411": "Length Required",
	  "412": "Precondition Failed",
	  "413": "Payload Too Large",
	  "414": "URI Too Long",
	  "415": "Unsupported Media Type",
	  "416": "Range Not Satisfiable",
	  "417": "Expectation Failed",
	  "418": "I'm a teapot",
	  "421": "Misdirected Request",
	  "422": "Unprocessable Entity",
	  "423": "Locked",
	  "424": "Failed Dependency",
	  "425": "Unordered Collection",
	  "426": "Upgrade Required",
	  "428": "Precondition Required",
	  "429": "Too Many Requests",
	  "431": "Request Header Fields Too Large",
	  "451": "Unavailable For Legal Reasons",
	  "500": "Internal Server Error",
	  "501": "Not Implemented",
	  "502": "Bad Gateway",
	  "503": "Service Unavailable",
	  "504": "Gateway Timeout",
	  "505": "HTTP Version Not Supported",
	  "506": "Variant Also Negotiates",
	  "507": "Insufficient Storage",
	  "508": "Loop Detected",
	  "509": "Bandwidth Limit Exceeded",
	  "510": "Not Extended",
	  "511": "Network Authentication Required"
	}


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	var http = __webpack_require__(198);
	
	var https = module.exports;
	
	for (var key in http) {
	    if (http.hasOwnProperty(key)) https[key] = http[key];
	};
	
	https.request = function (params, cb) {
	    if (!params) params = {};
	    params.scheme = 'https';
	    params.protocol = 'https:';
	    return http.request.call(this, params, cb);
	}


/***/ }),
/* 226 */
/***/ (function(module, exports) {

	/* (ignored) */

/***/ })
/******/ ]);
//# sourceMappingURL=bundle.js.map